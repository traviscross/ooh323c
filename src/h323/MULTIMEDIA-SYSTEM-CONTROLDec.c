/*
 * Copyright (C) 2004 by Objective Systems, Inc.
 *
 * This software is furnished under an open source license and may be
 * used and copied only in accordance with the terms of this license.
 * The text of the license may generally be found in the root
 * directory of this installation in the COPYING file.  It
 * can also be viewed online at the following URL:
 *
 *   http://www.obj-sys.com/open/license.html
 *
 * Any redistributions of this file including modified versions must
 * maintain this copyright notice.
 *
 *****************************************************************************/

#include "ooasn1.h"
#include "MULTIMEDIA-SYSTEM-CONTROL.h"
#include "asn1CEvtHndlr.h"

/**************************************************************/
/*                                                            */
/*  SequenceNumber                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245SequenceNumber (OOCTXT* pctxt, H245SequenceNumber* pvalue)
{
   int stat = ASN_OK;

   stat = decodeConsUInt8 (pctxt, pvalue, 0U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, *pvalue);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CapabilityTableEntryNumber                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CapabilityTableEntryNumber (OOCTXT* pctxt, H245CapabilityTableEntryNumber* pvalue)
{
   int stat = ASN_OK;

   stat = decodeConsUInt16 (pctxt, pvalue, 1U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, *pvalue);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CapabilityDescriptorNumber                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CapabilityDescriptorNumber (OOCTXT* pctxt, H245CapabilityDescriptorNumber* pvalue)
{
   int stat = ASN_OK;

   stat = decodeConsUInt8 (pctxt, pvalue, 0U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, *pvalue);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LogicalChannelNumber                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245LogicalChannelNumber (OOCTXT* pctxt, H245LogicalChannelNumber* pvalue)
{
   int stat = ASN_OK;

   stat = decodeConsUInt16 (pctxt, pvalue, 1U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, *pvalue);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexTableEntryNumber                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplexTableEntryNumber (OOCTXT* pctxt, H245MultiplexTableEntryNumber* pvalue)
{
   int stat = ASN_OK;

   stat = decodeConsUInt8 (pctxt, pvalue, 1U, 15U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, *pvalue);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  McuNumber                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245McuNumber (OOCTXT* pctxt, H245McuNumber* pvalue)
{
   int stat = ASN_OK;

   stat = decodeConsUInt8 (pctxt, pvalue, 0U, 192U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, *pvalue);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalNumber                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245TerminalNumber (OOCTXT* pctxt, H245TerminalNumber* pvalue)
{
   int stat = ASN_OK;

   stat = decodeConsUInt8 (pctxt, pvalue, 0U, 192U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, *pvalue);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalID                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245TerminalID (OOCTXT* pctxt, H245TerminalID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 128, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConferenceID                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ConferenceID (OOCTXT* pctxt, H245ConferenceID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 32, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Password                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245Password (OOCTXT* pctxt, H245Password* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 32, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaximumBitRate                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MaximumBitRate (OOCTXT* pctxt, H245MaximumBitRate* pvalue)
{
   int stat = ASN_OK;

   stat = decodeConsUnsigned (pctxt, pvalue, 0U, ASN1UINT_MAX);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, *pvalue);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CapabilityIdentifier_uuid                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CapabilityIdentifier_uuid (OOCTXT* pctxt, H245CapabilityIdentifier_uuid* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 16, 16, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ParameterIdentifier_uuid                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ParameterIdentifier_uuid (OOCTXT* pctxt, H245ParameterIdentifier_uuid* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 16, 16, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NetworkAccessParameters_externalReference                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NetworkAccessParameters_externalReference (OOCTXT* pctxt, H245NetworkAccessParameters_externalReference* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 255, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Q2931Address_address_nsapAddress                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245Q2931Address_address_nsapAddress (OOCTXT* pctxt, H245Q2931Address_address_nsapAddress* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 20, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Q2931Address_subaddress                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245Q2931Address_subaddress (OOCTXT* pctxt, H245Q2931Address_subaddress* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 20, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnicastAddress_iPAddress_network                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245UnicastAddress_iPAddress_network (OOCTXT* pctxt, H245UnicastAddress_iPAddress_network* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 4, 4, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnicastAddress_iPXAddress_node                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245UnicastAddress_iPXAddress_node (OOCTXT* pctxt, H245UnicastAddress_iPXAddress_node* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 6, 6, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnicastAddress_iPXAddress_netnum                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245UnicastAddress_iPXAddress_netnum (OOCTXT* pctxt, H245UnicastAddress_iPXAddress_netnum* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 4, 4, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnicastAddress_iPXAddress_tsapIdentifier                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245UnicastAddress_iPXAddress_tsapIdentifier (OOCTXT* pctxt, H245UnicastAddress_iPXAddress_tsapIdentifier* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 2, 2, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnicastAddress_iP6Address_network                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245UnicastAddress_iP6Address_network (OOCTXT* pctxt, H245UnicastAddress_iP6Address_network* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 16, 16, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnicastAddress_netBios                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245UnicastAddress_netBios (OOCTXT* pctxt, H245UnicastAddress_netBios* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 16, 16, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnicastAddress_iPSourceRouteAddress_network               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245UnicastAddress_iPSourceRouteAddress_network (OOCTXT* pctxt, H245UnicastAddress_iPSourceRouteAddress_network* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 4, 4, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnicastAddress_iPSourceRouteAddress_route_element         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245UnicastAddress_iPSourceRouteAddress_route_element (OOCTXT* pctxt, H245UnicastAddress_iPSourceRouteAddress_route_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 4, 4, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnicastAddress_nsap                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245UnicastAddress_nsap (OOCTXT* pctxt, H245UnicastAddress_nsap* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 20, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MulticastAddress_iPAddress_network                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MulticastAddress_iPAddress_network (OOCTXT* pctxt, H245MulticastAddress_iPAddress_network* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 4, 4, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MulticastAddress_iP6Address_network                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MulticastAddress_iP6Address_network (OOCTXT* pctxt, H245MulticastAddress_iP6Address_network* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 16, 16, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MulticastAddress_nsap                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MulticastAddress_nsap (OOCTXT* pctxt, H245MulticastAddress_nsap* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 20, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EscrowData_escrowValue                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245EscrowData_escrowValue (OOCTXT* pctxt, H245EscrowData_escrowValue* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 65535, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeBitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeBitStrValue (pctxt, pvalue->numbits, pvalue->data);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SubstituteConferenceIDCommand_conferenceIdentifier        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245SubstituteConferenceIDCommand_conferenceIdentifier (OOCTXT* pctxt, H245SubstituteConferenceIDCommand_conferenceIdentifier* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 16, 16, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VendorIdentification_productNumber                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245VendorIdentification_productNumber (OOCTXT* pctxt, H245VendorIdentification_productNumber* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VendorIdentification_versionNumber                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245VendorIdentification_versionNumber (OOCTXT* pctxt, H245VendorIdentification_versionNumber* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->numocts, pvalue->data);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NonStandardIdentifier_h221NonStandard                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NonStandardIdentifier_h221NonStandard (OOCTXT* pctxt, H245NonStandardIdentifier_h221NonStandard* pvalue)
{
   int stat = ASN_OK;

   /* decode t35CountryCode */

   rtInvokeStartElement (pctxt, "t35CountryCode", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->t35CountryCode, 0U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->t35CountryCode);

   rtInvokeEndElement (pctxt, "t35CountryCode", -1);

   /* decode t35Extension */

   rtInvokeStartElement (pctxt, "t35Extension", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->t35Extension, 0U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->t35Extension);

   rtInvokeEndElement (pctxt, "t35Extension", -1);

   /* decode manufacturerCode */

   rtInvokeStartElement (pctxt, "manufacturerCode", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->manufacturerCode, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->manufacturerCode);

   rtInvokeEndElement (pctxt, "manufacturerCode", -1);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NonStandardIdentifier                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NonStandardIdentifier (OOCTXT* pctxt, H245NonStandardIdentifier* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* object */
      case 0:
         rtInvokeStartElement (pctxt, "object", -1);

         pvalue->u.object = ALLOC_ASN1ELEM (pctxt, ASN1OBJID);
         if (pvalue->u.object == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = decodeObjectIdentifier (pctxt, pvalue->u.object);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         rtInvokeOidValue (pctxt, pvalue->u.object->numids, pvalue->u.object->subid);

         rtInvokeEndElement (pctxt, "object", -1);

         break;

      /* h221NonStandard */
      case 1:
         rtInvokeStartElement (pctxt, "h221NonStandard", -1);

         pvalue->u.h221NonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardIdentifier_h221NonStandard);
         if (pvalue->u.h221NonStandard == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H245NonStandardIdentifier_h221NonStandard (pctxt, pvalue->u.h221NonStandard);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

         rtInvokeEndElement (pctxt, "h221NonStandard", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NonStandardParameter                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NonStandardParameter (OOCTXT* pctxt, H245NonStandardParameter* pvalue)
{
   int stat = ASN_OK;

   /* decode nonStandardIdentifier */

   rtInvokeStartElement (pctxt, "nonStandardIdentifier", -1);

   stat = asn1PD_H245NonStandardIdentifier (pctxt, &pvalue->nonStandardIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "nonStandardIdentifier", -1);

   /* decode data */

   rtInvokeStartElement (pctxt, "data", -1);

   stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->data);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->data.numocts, pvalue->data.data);

   rtInvokeEndElement (pctxt, "data", -1);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NonStandardMessage                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NonStandardMessage (OOCTXT* pctxt, H245NonStandardMessage* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode nonStandardData */

   rtInvokeStartElement (pctxt, "nonStandardData", -1);

   stat = asn1PD_H245NonStandardParameter (pctxt, &pvalue->nonStandardData);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "nonStandardData", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MasterSlaveDetermination                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MasterSlaveDetermination (OOCTXT* pctxt, H245MasterSlaveDetermination* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode terminalType */

   rtInvokeStartElement (pctxt, "terminalType", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->terminalType, 0U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->terminalType);

   rtInvokeEndElement (pctxt, "terminalType", -1);

   /* decode statusDeterminationNumber */

   rtInvokeStartElement (pctxt, "statusDeterminationNumber", -1);

   stat = decodeConsUnsigned (pctxt, &pvalue->statusDeterminationNumber, 0U, 16777215U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->statusDeterminationNumber);

   rtInvokeEndElement (pctxt, "statusDeterminationNumber", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VCCapability_aal1                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245VCCapability_aal1 (OOCTXT* pctxt, H245VCCapability_aal1* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode nullClockRecovery */

   rtInvokeStartElement (pctxt, "nullClockRecovery", -1);

   stat = DECODEBIT (pctxt, &pvalue->nullClockRecovery);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->nullClockRecovery);

   rtInvokeEndElement (pctxt, "nullClockRecovery", -1);

   /* decode srtsClockRecovery */

   rtInvokeStartElement (pctxt, "srtsClockRecovery", -1);

   stat = DECODEBIT (pctxt, &pvalue->srtsClockRecovery);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->srtsClockRecovery);

   rtInvokeEndElement (pctxt, "srtsClockRecovery", -1);

   /* decode adaptiveClockRecovery */

   rtInvokeStartElement (pctxt, "adaptiveClockRecovery", -1);

   stat = DECODEBIT (pctxt, &pvalue->adaptiveClockRecovery);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->adaptiveClockRecovery);

   rtInvokeEndElement (pctxt, "adaptiveClockRecovery", -1);

   /* decode nullErrorCorrection */

   rtInvokeStartElement (pctxt, "nullErrorCorrection", -1);

   stat = DECODEBIT (pctxt, &pvalue->nullErrorCorrection);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->nullErrorCorrection);

   rtInvokeEndElement (pctxt, "nullErrorCorrection", -1);

   /* decode longInterleaver */

   rtInvokeStartElement (pctxt, "longInterleaver", -1);

   stat = DECODEBIT (pctxt, &pvalue->longInterleaver);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->longInterleaver);

   rtInvokeEndElement (pctxt, "longInterleaver", -1);

   /* decode shortInterleaver */

   rtInvokeStartElement (pctxt, "shortInterleaver", -1);

   stat = DECODEBIT (pctxt, &pvalue->shortInterleaver);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->shortInterleaver);

   rtInvokeEndElement (pctxt, "shortInterleaver", -1);

   /* decode errorCorrectionOnly */

   rtInvokeStartElement (pctxt, "errorCorrectionOnly", -1);

   stat = DECODEBIT (pctxt, &pvalue->errorCorrectionOnly);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->errorCorrectionOnly);

   rtInvokeEndElement (pctxt, "errorCorrectionOnly", -1);

   /* decode structuredDataTransfer */

   rtInvokeStartElement (pctxt, "structuredDataTransfer", -1);

   stat = DECODEBIT (pctxt, &pvalue->structuredDataTransfer);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->structuredDataTransfer);

   rtInvokeEndElement (pctxt, "structuredDataTransfer", -1);

   /* decode partiallyFilledCells */

   rtInvokeStartElement (pctxt, "partiallyFilledCells", -1);

   stat = DECODEBIT (pctxt, &pvalue->partiallyFilledCells);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->partiallyFilledCells);

   rtInvokeEndElement (pctxt, "partiallyFilledCells", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VCCapability_aal5                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245VCCapability_aal5 (OOCTXT* pctxt, H245VCCapability_aal5* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode forwardMaximumSDUSize */

   rtInvokeStartElement (pctxt, "forwardMaximumSDUSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->forwardMaximumSDUSize, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->forwardMaximumSDUSize);

   rtInvokeEndElement (pctxt, "forwardMaximumSDUSize", -1);

   /* decode backwardMaximumSDUSize */

   rtInvokeStartElement (pctxt, "backwardMaximumSDUSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->backwardMaximumSDUSize, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->backwardMaximumSDUSize);

   rtInvokeEndElement (pctxt, "backwardMaximumSDUSize", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VCCapability_availableBitRates_type_rangeOfBitRates       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245VCCapability_availableBitRates_type_rangeOfBitRates (OOCTXT* pctxt, H245VCCapability_availableBitRates_type_rangeOfBitRates* pvalue)
{
   int stat = ASN_OK;

   /* decode lowerBitRate */

   rtInvokeStartElement (pctxt, "lowerBitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->lowerBitRate, 1U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->lowerBitRate);

   rtInvokeEndElement (pctxt, "lowerBitRate", -1);

   /* decode higherBitRate */

   rtInvokeStartElement (pctxt, "higherBitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->higherBitRate, 1U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->higherBitRate);

   rtInvokeEndElement (pctxt, "higherBitRate", -1);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VCCapability_availableBitRates_type                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245VCCapability_availableBitRates_type (OOCTXT* pctxt, H245VCCapability_availableBitRates_type* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* singleBitRate */
      case 0:
         rtInvokeStartElement (pctxt, "singleBitRate", -1);

         stat = decodeConsUInt16 (pctxt, &pvalue->u.singleBitRate, 1U, 65535U);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         rtInvokeUIntValue (pctxt, pvalue->u.singleBitRate);

         rtInvokeEndElement (pctxt, "singleBitRate", -1);

         break;

      /* rangeOfBitRates */
      case 1:
         rtInvokeStartElement (pctxt, "rangeOfBitRates", -1);

         pvalue->u.rangeOfBitRates = ALLOC_ASN1ELEM (pctxt, H245VCCapability_availableBitRates_type_rangeOfBitRates);
         if (pvalue->u.rangeOfBitRates == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H245VCCapability_availableBitRates_type_rangeOfBitRates (pctxt, pvalue->u.rangeOfBitRates);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

         rtInvokeEndElement (pctxt, "rangeOfBitRates", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VCCapability_availableBitRates                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245VCCapability_availableBitRates (OOCTXT* pctxt, H245VCCapability_availableBitRates* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode type */

   rtInvokeStartElement (pctxt, "type", -1);

   stat = asn1PD_H245VCCapability_availableBitRates_type (pctxt, &pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "type", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Q2931Address_address                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245Q2931Address_address (OOCTXT* pctxt, H245Q2931Address_address* pvalue)
{
   static Asn1SizeCnst internationalNumber_lsize1 = { 0, 1, 16, 0 };
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* internationalNumber */
         case 0:
            rtInvokeStartElement (pctxt, "internationalNumber", -1);

            stat = addSizeConstraint (pctxt, &internationalNumber_lsize1);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            stat = decodeConstrainedStringEx (pctxt, &pvalue->u.internationalNumber, NUM_CANSET, 4, 4, 4);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeCharStrValue (pctxt, pvalue->u.internationalNumber);

            rtInvokeEndElement (pctxt, "internationalNumber", -1);

            break;

         /* nsapAddress */
         case 1:
            rtInvokeStartElement (pctxt, "nsapAddress", -1);

            pvalue->u.nsapAddress = ALLOC_ASN1ELEM (pctxt, H245Q2931Address_address_nsapAddress);
            if (pvalue->u.nsapAddress == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245Q2931Address_address_nsapAddress (pctxt, pvalue->u.nsapAddress);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nsapAddress", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Q2931Address                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245Q2931Address (OOCTXT* pctxt, H245Q2931Address* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.subaddressPresent = optbit;

   /* decode address */

   rtInvokeStartElement (pctxt, "address", -1);

   stat = asn1PD_H245Q2931Address_address (pctxt, &pvalue->address);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "address", -1);

   /* decode subaddress */

   if (pvalue->m.subaddressPresent) {
      rtInvokeStartElement (pctxt, "subaddress", -1);

      stat = asn1PD_H245Q2931Address_subaddress (pctxt, &pvalue->subaddress);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "subaddress", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VCCapability_aal1ViaGateway_gatewayAddress                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245VCCapability_aal1ViaGateway_gatewayAddress (OOCTXT* pctxt, H245VCCapability_aal1ViaGateway_gatewayAddress* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   H245Q2931Address* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245Q2931Address);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245Q2931Address (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VCCapability_aal1ViaGateway                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245VCCapability_aal1ViaGateway (OOCTXT* pctxt, H245VCCapability_aal1ViaGateway* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode gatewayAddress */

   rtInvokeStartElement (pctxt, "gatewayAddress", -1);

   stat = asn1PD_H245VCCapability_aal1ViaGateway_gatewayAddress (pctxt, &pvalue->gatewayAddress);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "gatewayAddress", -1);

   /* decode nullClockRecovery */

   rtInvokeStartElement (pctxt, "nullClockRecovery", -1);

   stat = DECODEBIT (pctxt, &pvalue->nullClockRecovery);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->nullClockRecovery);

   rtInvokeEndElement (pctxt, "nullClockRecovery", -1);

   /* decode srtsClockRecovery */

   rtInvokeStartElement (pctxt, "srtsClockRecovery", -1);

   stat = DECODEBIT (pctxt, &pvalue->srtsClockRecovery);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->srtsClockRecovery);

   rtInvokeEndElement (pctxt, "srtsClockRecovery", -1);

   /* decode adaptiveClockRecovery */

   rtInvokeStartElement (pctxt, "adaptiveClockRecovery", -1);

   stat = DECODEBIT (pctxt, &pvalue->adaptiveClockRecovery);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->adaptiveClockRecovery);

   rtInvokeEndElement (pctxt, "adaptiveClockRecovery", -1);

   /* decode nullErrorCorrection */

   rtInvokeStartElement (pctxt, "nullErrorCorrection", -1);

   stat = DECODEBIT (pctxt, &pvalue->nullErrorCorrection);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->nullErrorCorrection);

   rtInvokeEndElement (pctxt, "nullErrorCorrection", -1);

   /* decode longInterleaver */

   rtInvokeStartElement (pctxt, "longInterleaver", -1);

   stat = DECODEBIT (pctxt, &pvalue->longInterleaver);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->longInterleaver);

   rtInvokeEndElement (pctxt, "longInterleaver", -1);

   /* decode shortInterleaver */

   rtInvokeStartElement (pctxt, "shortInterleaver", -1);

   stat = DECODEBIT (pctxt, &pvalue->shortInterleaver);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->shortInterleaver);

   rtInvokeEndElement (pctxt, "shortInterleaver", -1);

   /* decode errorCorrectionOnly */

   rtInvokeStartElement (pctxt, "errorCorrectionOnly", -1);

   stat = DECODEBIT (pctxt, &pvalue->errorCorrectionOnly);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->errorCorrectionOnly);

   rtInvokeEndElement (pctxt, "errorCorrectionOnly", -1);

   /* decode structuredDataTransfer */

   rtInvokeStartElement (pctxt, "structuredDataTransfer", -1);

   stat = DECODEBIT (pctxt, &pvalue->structuredDataTransfer);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->structuredDataTransfer);

   rtInvokeEndElement (pctxt, "structuredDataTransfer", -1);

   /* decode partiallyFilledCells */

   rtInvokeStartElement (pctxt, "partiallyFilledCells", -1);

   stat = DECODEBIT (pctxt, &pvalue->partiallyFilledCells);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->partiallyFilledCells);

   rtInvokeEndElement (pctxt, "partiallyFilledCells", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VCCapability                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245VCCapability (OOCTXT* pctxt, H245VCCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.aal1Present = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.aal5Present = optbit;

   /* decode aal1 */

   if (pvalue->m.aal1Present) {
      rtInvokeStartElement (pctxt, "aal1", -1);

      stat = asn1PD_H245VCCapability_aal1 (pctxt, &pvalue->aal1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "aal1", -1);
   }

   /* decode aal5 */

   if (pvalue->m.aal5Present) {
      rtInvokeStartElement (pctxt, "aal5", -1);

      stat = asn1PD_H245VCCapability_aal5 (pctxt, &pvalue->aal5);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "aal5", -1);
   }

   /* decode transportStream */

   rtInvokeStartElement (pctxt, "transportStream", -1);

   stat = DECODEBIT (pctxt, &pvalue->transportStream);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->transportStream);

   rtInvokeEndElement (pctxt, "transportStream", -1);

   /* decode programStream */

   rtInvokeStartElement (pctxt, "programStream", -1);

   stat = DECODEBIT (pctxt, &pvalue->programStream);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->programStream);

   rtInvokeEndElement (pctxt, "programStream", -1);

   /* decode availableBitRates */

   rtInvokeStartElement (pctxt, "availableBitRates", -1);

   stat = asn1PD_H245VCCapability_availableBitRates (pctxt, &pvalue->availableBitRates);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "availableBitRates", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 1 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.aal1ViaGatewayPresent = 1;

                     rtInvokeStartElement (pctxt, "aal1ViaGateway", -1);

                     stat = asn1PD_H245VCCapability_aal1ViaGateway (pctxt, &pvalue->aal1ViaGateway);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "aal1ViaGateway", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 1) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SetOfH245VCCapability                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245_SetOfH245VCCapability (OOCTXT* pctxt, H245_SetOfH245VCCapability* pvalue)
{
   int stat = ASN_OK;
   H245VCCapability* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         rtInvokeStartElement (pctxt, "elem", xx1);

         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245VCCapability);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H245VCCapability (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         rtInvokeEndElement (pctxt, "elem", xx1);

         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H222Capability                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H222Capability (OOCTXT* pctxt, H245H222Capability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode numberOfVCs */

   rtInvokeStartElement (pctxt, "numberOfVCs", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->numberOfVCs, 1U, 256U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->numberOfVCs);

   rtInvokeEndElement (pctxt, "numberOfVCs", -1);

   /* decode vcCapability */

   rtInvokeStartElement (pctxt, "vcCapability", -1);

   stat = asn1PD_H245_SetOfH245VCCapability (pctxt, &pvalue->vcCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "vcCapability", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223Capability_h223MultiplexTableCapability_enhanced      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223Capability_h223MultiplexTableCapability_enhanced (OOCTXT* pctxt, H245H223Capability_h223MultiplexTableCapability_enhanced* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode maximumNestingDepth */

   rtInvokeStartElement (pctxt, "maximumNestingDepth", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->maximumNestingDepth, 1U, 15U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maximumNestingDepth);

   rtInvokeEndElement (pctxt, "maximumNestingDepth", -1);

   /* decode maximumElementListSize */

   rtInvokeStartElement (pctxt, "maximumElementListSize", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->maximumElementListSize, 2U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maximumElementListSize);

   rtInvokeEndElement (pctxt, "maximumElementListSize", -1);

   /* decode maximumSubElementListSize */

   rtInvokeStartElement (pctxt, "maximumSubElementListSize", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->maximumSubElementListSize, 2U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maximumSubElementListSize);

   rtInvokeEndElement (pctxt, "maximumSubElementListSize", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223Capability_h223MultiplexTableCapability               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223Capability_h223MultiplexTableCapability (OOCTXT* pctxt, H245H223Capability_h223MultiplexTableCapability* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* basic */
      case 0:
         rtInvokeStartElement (pctxt, "basic", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "basic", -1);

         break;

      /* enhanced */
      case 1:
         rtInvokeStartElement (pctxt, "enhanced", -1);

         pvalue->u.enhanced = ALLOC_ASN1ELEM (pctxt, H245H223Capability_h223MultiplexTableCapability_enhanced);
         if (pvalue->u.enhanced == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H245H223Capability_h223MultiplexTableCapability_enhanced (pctxt, pvalue->u.enhanced);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

         rtInvokeEndElement (pctxt, "enhanced", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223Capability_mobileOperationTransmitCapability          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223Capability_mobileOperationTransmitCapability (OOCTXT* pctxt, H245H223Capability_mobileOperationTransmitCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode modeChangeCapability */

   rtInvokeStartElement (pctxt, "modeChangeCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->modeChangeCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->modeChangeCapability);

   rtInvokeEndElement (pctxt, "modeChangeCapability", -1);

   /* decode h223AnnexA */

   rtInvokeStartElement (pctxt, "h223AnnexA", -1);

   stat = DECODEBIT (pctxt, &pvalue->h223AnnexA);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->h223AnnexA);

   rtInvokeEndElement (pctxt, "h223AnnexA", -1);

   /* decode h223AnnexADoubleFlag */

   rtInvokeStartElement (pctxt, "h223AnnexADoubleFlag", -1);

   stat = DECODEBIT (pctxt, &pvalue->h223AnnexADoubleFlag);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->h223AnnexADoubleFlag);

   rtInvokeEndElement (pctxt, "h223AnnexADoubleFlag", -1);

   /* decode h223AnnexB */

   rtInvokeStartElement (pctxt, "h223AnnexB", -1);

   stat = DECODEBIT (pctxt, &pvalue->h223AnnexB);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->h223AnnexB);

   rtInvokeEndElement (pctxt, "h223AnnexB", -1);

   /* decode h223AnnexBwithHeader */

   rtInvokeStartElement (pctxt, "h223AnnexBwithHeader", -1);

   stat = DECODEBIT (pctxt, &pvalue->h223AnnexBwithHeader);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->h223AnnexBwithHeader);

   rtInvokeEndElement (pctxt, "h223AnnexBwithHeader", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223AnnexCCapability                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223AnnexCCapability (OOCTXT* pctxt, H245H223AnnexCCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   /* decode videoWithAL1M */

   rtInvokeStartElement (pctxt, "videoWithAL1M", -1);

   stat = DECODEBIT (pctxt, &pvalue->videoWithAL1M);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->videoWithAL1M);

   rtInvokeEndElement (pctxt, "videoWithAL1M", -1);

   /* decode videoWithAL2M */

   rtInvokeStartElement (pctxt, "videoWithAL2M", -1);

   stat = DECODEBIT (pctxt, &pvalue->videoWithAL2M);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->videoWithAL2M);

   rtInvokeEndElement (pctxt, "videoWithAL2M", -1);

   /* decode videoWithAL3M */

   rtInvokeStartElement (pctxt, "videoWithAL3M", -1);

   stat = DECODEBIT (pctxt, &pvalue->videoWithAL3M);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->videoWithAL3M);

   rtInvokeEndElement (pctxt, "videoWithAL3M", -1);

   /* decode audioWithAL1M */

   rtInvokeStartElement (pctxt, "audioWithAL1M", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioWithAL1M);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->audioWithAL1M);

   rtInvokeEndElement (pctxt, "audioWithAL1M", -1);

   /* decode audioWithAL2M */

   rtInvokeStartElement (pctxt, "audioWithAL2M", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioWithAL2M);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->audioWithAL2M);

   rtInvokeEndElement (pctxt, "audioWithAL2M", -1);

   /* decode audioWithAL3M */

   rtInvokeStartElement (pctxt, "audioWithAL3M", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioWithAL3M);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->audioWithAL3M);

   rtInvokeEndElement (pctxt, "audioWithAL3M", -1);

   /* decode dataWithAL1M */

   rtInvokeStartElement (pctxt, "dataWithAL1M", -1);

   stat = DECODEBIT (pctxt, &pvalue->dataWithAL1M);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->dataWithAL1M);

   rtInvokeEndElement (pctxt, "dataWithAL1M", -1);

   /* decode dataWithAL2M */

   rtInvokeStartElement (pctxt, "dataWithAL2M", -1);

   stat = DECODEBIT (pctxt, &pvalue->dataWithAL2M);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->dataWithAL2M);

   rtInvokeEndElement (pctxt, "dataWithAL2M", -1);

   /* decode dataWithAL3M */

   rtInvokeStartElement (pctxt, "dataWithAL3M", -1);

   stat = DECODEBIT (pctxt, &pvalue->dataWithAL3M);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->dataWithAL3M);

   rtInvokeEndElement (pctxt, "dataWithAL3M", -1);

   /* decode alpduInterleaving */

   rtInvokeStartElement (pctxt, "alpduInterleaving", -1);

   stat = DECODEBIT (pctxt, &pvalue->alpduInterleaving);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->alpduInterleaving);

   rtInvokeEndElement (pctxt, "alpduInterleaving", -1);

   /* decode maximumAL1MPDUSize */

   rtInvokeStartElement (pctxt, "maximumAL1MPDUSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maximumAL1MPDUSize, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maximumAL1MPDUSize);

   rtInvokeEndElement (pctxt, "maximumAL1MPDUSize", -1);

   /* decode maximumAL2MSDUSize */

   rtInvokeStartElement (pctxt, "maximumAL2MSDUSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maximumAL2MSDUSize, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maximumAL2MSDUSize);

   rtInvokeEndElement (pctxt, "maximumAL2MSDUSize", -1);

   /* decode maximumAL3MSDUSize */

   rtInvokeStartElement (pctxt, "maximumAL3MSDUSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maximumAL3MSDUSize, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maximumAL3MSDUSize);

   rtInvokeEndElement (pctxt, "maximumAL3MSDUSize", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 1 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.rsCodeCapabilityPresent = 1;

                     rtInvokeStartElement (pctxt, "rsCodeCapability", -1);

                     stat = DECODEBIT (pctxt, &pvalue->rsCodeCapability);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeBoolValue (pctxt, pvalue->rsCodeCapability);

                     rtInvokeEndElement (pctxt, "rsCodeCapability", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 1) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223Capability_mobileMultilinkFrameCapability             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223Capability_mobileMultilinkFrameCapability (OOCTXT* pctxt, H245H223Capability_mobileMultilinkFrameCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode maximumSampleSize */

   rtInvokeStartElement (pctxt, "maximumSampleSize", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->maximumSampleSize, 1U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maximumSampleSize);

   rtInvokeEndElement (pctxt, "maximumSampleSize", -1);

   /* decode maximumPayloadLength */

   rtInvokeStartElement (pctxt, "maximumPayloadLength", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maximumPayloadLength, 1U, 65025U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maximumPayloadLength);

   rtInvokeEndElement (pctxt, "maximumPayloadLength", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223Capability                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223Capability (OOCTXT* pctxt, H245H223Capability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   /* decode transportWithI_frames */

   rtInvokeStartElement (pctxt, "transportWithI_frames", -1);

   stat = DECODEBIT (pctxt, &pvalue->transportWithI_frames);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->transportWithI_frames);

   rtInvokeEndElement (pctxt, "transportWithI_frames", -1);

   /* decode videoWithAL1 */

   rtInvokeStartElement (pctxt, "videoWithAL1", -1);

   stat = DECODEBIT (pctxt, &pvalue->videoWithAL1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->videoWithAL1);

   rtInvokeEndElement (pctxt, "videoWithAL1", -1);

   /* decode videoWithAL2 */

   rtInvokeStartElement (pctxt, "videoWithAL2", -1);

   stat = DECODEBIT (pctxt, &pvalue->videoWithAL2);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->videoWithAL2);

   rtInvokeEndElement (pctxt, "videoWithAL2", -1);

   /* decode videoWithAL3 */

   rtInvokeStartElement (pctxt, "videoWithAL3", -1);

   stat = DECODEBIT (pctxt, &pvalue->videoWithAL3);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->videoWithAL3);

   rtInvokeEndElement (pctxt, "videoWithAL3", -1);

   /* decode audioWithAL1 */

   rtInvokeStartElement (pctxt, "audioWithAL1", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioWithAL1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->audioWithAL1);

   rtInvokeEndElement (pctxt, "audioWithAL1", -1);

   /* decode audioWithAL2 */

   rtInvokeStartElement (pctxt, "audioWithAL2", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioWithAL2);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->audioWithAL2);

   rtInvokeEndElement (pctxt, "audioWithAL2", -1);

   /* decode audioWithAL3 */

   rtInvokeStartElement (pctxt, "audioWithAL3", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioWithAL3);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->audioWithAL3);

   rtInvokeEndElement (pctxt, "audioWithAL3", -1);

   /* decode dataWithAL1 */

   rtInvokeStartElement (pctxt, "dataWithAL1", -1);

   stat = DECODEBIT (pctxt, &pvalue->dataWithAL1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->dataWithAL1);

   rtInvokeEndElement (pctxt, "dataWithAL1", -1);

   /* decode dataWithAL2 */

   rtInvokeStartElement (pctxt, "dataWithAL2", -1);

   stat = DECODEBIT (pctxt, &pvalue->dataWithAL2);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->dataWithAL2);

   rtInvokeEndElement (pctxt, "dataWithAL2", -1);

   /* decode dataWithAL3 */

   rtInvokeStartElement (pctxt, "dataWithAL3", -1);

   stat = DECODEBIT (pctxt, &pvalue->dataWithAL3);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->dataWithAL3);

   rtInvokeEndElement (pctxt, "dataWithAL3", -1);

   /* decode maximumAl2SDUSize */

   rtInvokeStartElement (pctxt, "maximumAl2SDUSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maximumAl2SDUSize, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maximumAl2SDUSize);

   rtInvokeEndElement (pctxt, "maximumAl2SDUSize", -1);

   /* decode maximumAl3SDUSize */

   rtInvokeStartElement (pctxt, "maximumAl3SDUSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maximumAl3SDUSize, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maximumAl3SDUSize);

   rtInvokeEndElement (pctxt, "maximumAl3SDUSize", -1);

   /* decode maximumDelayJitter */

   rtInvokeStartElement (pctxt, "maximumDelayJitter", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maximumDelayJitter, 0U, 1023U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maximumDelayJitter);

   rtInvokeEndElement (pctxt, "maximumDelayJitter", -1);

   /* decode h223MultiplexTableCapability */

   rtInvokeStartElement (pctxt, "h223MultiplexTableCapability", -1);

   stat = asn1PD_H245H223Capability_h223MultiplexTableCapability (pctxt, &pvalue->h223MultiplexTableCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "h223MultiplexTableCapability", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 6 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.maxMUXPDUSizeCapabilityPresent = 1;

                     rtInvokeStartElement (pctxt, "maxMUXPDUSizeCapability", -1);

                     stat = DECODEBIT (pctxt, &pvalue->maxMUXPDUSizeCapability);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeBoolValue (pctxt, pvalue->maxMUXPDUSizeCapability);

                     rtInvokeEndElement (pctxt, "maxMUXPDUSizeCapability", -1);
                     break;

                  case 1:
                     pvalue->m.nsrpSupportPresent = 1;

                     rtInvokeStartElement (pctxt, "nsrpSupport", -1);

                     stat = DECODEBIT (pctxt, &pvalue->nsrpSupport);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeBoolValue (pctxt, pvalue->nsrpSupport);

                     rtInvokeEndElement (pctxt, "nsrpSupport", -1);
                     break;

                  case 2:
                     pvalue->m.mobileOperationTransmitCapabilityPresent = 1;

                     rtInvokeStartElement (pctxt, "mobileOperationTransmitCapability", -1);

                     stat = asn1PD_H245H223Capability_mobileOperationTransmitCapability (pctxt, &pvalue->mobileOperationTransmitCapability);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "mobileOperationTransmitCapability", -1);
                     break;

                  case 3:
                     pvalue->m.h223AnnexCCapabilityPresent = 1;

                     rtInvokeStartElement (pctxt, "h223AnnexCCapability", -1);

                     stat = asn1PD_H245H223AnnexCCapability (pctxt, &pvalue->h223AnnexCCapability);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "h223AnnexCCapability", -1);
                     break;

                  case 4:
                     pvalue->m.bitRatePresent = 1;

                     rtInvokeStartElement (pctxt, "bitRate", -1);

                     stat = decodeConsUInt16 (pctxt, &pvalue->bitRate, 1U, 19200U);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeUIntValue (pctxt, pvalue->bitRate);

                     rtInvokeEndElement (pctxt, "bitRate", -1);
                     break;

                  case 5:
                     pvalue->m.mobileMultilinkFrameCapabilityPresent = 1;

                     rtInvokeStartElement (pctxt, "mobileMultilinkFrameCapability", -1);

                     stat = asn1PD_H245H223Capability_mobileMultilinkFrameCapability (pctxt, &pvalue->mobileMultilinkFrameCapability);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "mobileMultilinkFrameCapability", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 6) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  V75Capability                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245V75Capability (OOCTXT* pctxt, H245V75Capability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode audioHeader */

   rtInvokeStartElement (pctxt, "audioHeader", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioHeader);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->audioHeader);

   rtInvokeEndElement (pctxt, "audioHeader", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  V76Capability                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245V76Capability (OOCTXT* pctxt, H245V76Capability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode suspendResumeCapabilitywAddress */

   rtInvokeStartElement (pctxt, "suspendResumeCapabilitywAddress", -1);

   stat = DECODEBIT (pctxt, &pvalue->suspendResumeCapabilitywAddress);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->suspendResumeCapabilitywAddress);

   rtInvokeEndElement (pctxt, "suspendResumeCapabilitywAddress", -1);

   /* decode suspendResumeCapabilitywoAddress */

   rtInvokeStartElement (pctxt, "suspendResumeCapabilitywoAddress", -1);

   stat = DECODEBIT (pctxt, &pvalue->suspendResumeCapabilitywoAddress);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->suspendResumeCapabilitywoAddress);

   rtInvokeEndElement (pctxt, "suspendResumeCapabilitywoAddress", -1);

   /* decode rejCapability */

   rtInvokeStartElement (pctxt, "rejCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->rejCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->rejCapability);

   rtInvokeEndElement (pctxt, "rejCapability", -1);

   /* decode sREJCapability */

   rtInvokeStartElement (pctxt, "sREJCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->sREJCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->sREJCapability);

   rtInvokeEndElement (pctxt, "sREJCapability", -1);

   /* decode mREJCapability */

   rtInvokeStartElement (pctxt, "mREJCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->mREJCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->mREJCapability);

   rtInvokeEndElement (pctxt, "mREJCapability", -1);

   /* decode crc8bitCapability */

   rtInvokeStartElement (pctxt, "crc8bitCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->crc8bitCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->crc8bitCapability);

   rtInvokeEndElement (pctxt, "crc8bitCapability", -1);

   /* decode crc16bitCapability */

   rtInvokeStartElement (pctxt, "crc16bitCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->crc16bitCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->crc16bitCapability);

   rtInvokeEndElement (pctxt, "crc16bitCapability", -1);

   /* decode crc32bitCapability */

   rtInvokeStartElement (pctxt, "crc32bitCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->crc32bitCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->crc32bitCapability);

   rtInvokeEndElement (pctxt, "crc32bitCapability", -1);

   /* decode uihCapability */

   rtInvokeStartElement (pctxt, "uihCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->uihCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->uihCapability);

   rtInvokeEndElement (pctxt, "uihCapability", -1);

   /* decode numOfDLCS */

   rtInvokeStartElement (pctxt, "numOfDLCS", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->numOfDLCS, 2U, 8191U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->numOfDLCS);

   rtInvokeEndElement (pctxt, "numOfDLCS", -1);

   /* decode twoOctetAddressFieldCapability */

   rtInvokeStartElement (pctxt, "twoOctetAddressFieldCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->twoOctetAddressFieldCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->twoOctetAddressFieldCapability);

   rtInvokeEndElement (pctxt, "twoOctetAddressFieldCapability", -1);

   /* decode loopBackTestCapability */

   rtInvokeStartElement (pctxt, "loopBackTestCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->loopBackTestCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->loopBackTestCapability);

   rtInvokeEndElement (pctxt, "loopBackTestCapability", -1);

   /* decode n401Capability */

   rtInvokeStartElement (pctxt, "n401Capability", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->n401Capability, 1U, 4095U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->n401Capability);

   rtInvokeEndElement (pctxt, "n401Capability", -1);

   /* decode maxWindowSizeCapability */

   rtInvokeStartElement (pctxt, "maxWindowSizeCapability", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->maxWindowSizeCapability, 1U, 127U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maxWindowSizeCapability);

   rtInvokeEndElement (pctxt, "maxWindowSizeCapability", -1);

   /* decode v75Capability */

   rtInvokeStartElement (pctxt, "v75Capability", -1);

   stat = asn1PD_H245V75Capability (pctxt, &pvalue->v75Capability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "v75Capability", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  V42bis                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245V42bis (OOCTXT* pctxt, H245V42bis* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode numberOfCodewords */

   rtInvokeStartElement (pctxt, "numberOfCodewords", -1);

   stat = decodeConsUnsigned (pctxt, &pvalue->numberOfCodewords, 1U, 65536U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->numberOfCodewords);

   rtInvokeEndElement (pctxt, "numberOfCodewords", -1);

   /* decode maximumStringLength */

   rtInvokeStartElement (pctxt, "maximumStringLength", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maximumStringLength, 1U, 256U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maximumStringLength);

   rtInvokeEndElement (pctxt, "maximumStringLength", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CompressionType                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CompressionType (OOCTXT* pctxt, H245CompressionType* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* v42bis */
         case 0:
            rtInvokeStartElement (pctxt, "v42bis", -1);

            pvalue->u.v42bis = ALLOC_ASN1ELEM (pctxt, H245V42bis);
            if (pvalue->u.v42bis == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245V42bis (pctxt, pvalue->u.v42bis);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "v42bis", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataProtocolCapability_v76wCompression                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245DataProtocolCapability_v76wCompression (OOCTXT* pctxt, H245DataProtocolCapability_v76wCompression* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* transmitCompression */
         case 0:
            rtInvokeStartElement (pctxt, "transmitCompression", -1);

            pvalue->u.transmitCompression = ALLOC_ASN1ELEM (pctxt, H245CompressionType);
            if (pvalue->u.transmitCompression == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245CompressionType (pctxt, pvalue->u.transmitCompression);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "transmitCompression", -1);

            break;

         /* receiveCompression */
         case 1:
            rtInvokeStartElement (pctxt, "receiveCompression", -1);

            pvalue->u.receiveCompression = ALLOC_ASN1ELEM (pctxt, H245CompressionType);
            if (pvalue->u.receiveCompression == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245CompressionType (pctxt, pvalue->u.receiveCompression);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "receiveCompression", -1);

            break;

         /* transmitAndReceiveCompression */
         case 2:
            rtInvokeStartElement (pctxt, "transmitAndReceiveCompression", -1);

            pvalue->u.transmitAndReceiveCompression = ALLOC_ASN1ELEM (pctxt, H245CompressionType);
            if (pvalue->u.transmitAndReceiveCompression == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245CompressionType (pctxt, pvalue->u.transmitAndReceiveCompression);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "transmitAndReceiveCompression", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataProtocolCapability                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245DataProtocolCapability (OOCTXT* pctxt, H245DataProtocolCapability* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 6);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* v14buffered */
         case 1:
            rtInvokeStartElement (pctxt, "v14buffered", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "v14buffered", -1);

            break;

         /* v42lapm */
         case 2:
            rtInvokeStartElement (pctxt, "v42lapm", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "v42lapm", -1);

            break;

         /* hdlcFrameTunnelling */
         case 3:
            rtInvokeStartElement (pctxt, "hdlcFrameTunnelling", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "hdlcFrameTunnelling", -1);

            break;

         /* h310SeparateVCStack */
         case 4:
            rtInvokeStartElement (pctxt, "h310SeparateVCStack", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "h310SeparateVCStack", -1);

            break;

         /* h310SingleVCStack */
         case 5:
            rtInvokeStartElement (pctxt, "h310SingleVCStack", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "h310SingleVCStack", -1);

            break;

         /* transparent */
         case 6:
            rtInvokeStartElement (pctxt, "transparent", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "transparent", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 8;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* segmentationAndReassembly */
         case 8:
            rtInvokeStartElement (pctxt, "segmentationAndReassembly", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "segmentationAndReassembly", -1);

            break;

         /* hdlcFrameTunnelingwSAR */
         case 9:
            rtInvokeStartElement (pctxt, "hdlcFrameTunnelingwSAR", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "hdlcFrameTunnelingwSAR", -1);

            break;

         /* v120 */
         case 10:
            rtInvokeStartElement (pctxt, "v120", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "v120", -1);

            break;

         /* separateLANStack */
         case 11:
            rtInvokeStartElement (pctxt, "separateLANStack", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "separateLANStack", -1);

            break;

         /* v76wCompression */
         case 12:
            rtInvokeStartElement (pctxt, "v76wCompression", -1);

            pvalue->u.v76wCompression = ALLOC_ASN1ELEM (pctxt, H245DataProtocolCapability_v76wCompression);
            if (pvalue->u.v76wCompression == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataProtocolCapability_v76wCompression (pctxt, pvalue->u.v76wCompression);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "v76wCompression", -1);

            break;

         /* tcp */
         case 13:
            rtInvokeStartElement (pctxt, "tcp", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "tcp", -1);

            break;

         /* udp */
         case 14:
            rtInvokeStartElement (pctxt, "udp", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "udp", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  T84Profile_t84Restricted                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245T84Profile_t84Restricted (OOCTXT* pctxt, H245T84Profile_t84Restricted* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode qcif */

   rtInvokeStartElement (pctxt, "qcif", -1);

   stat = DECODEBIT (pctxt, &pvalue->qcif);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->qcif);

   rtInvokeEndElement (pctxt, "qcif", -1);

   /* decode cif */

   rtInvokeStartElement (pctxt, "cif", -1);

   stat = DECODEBIT (pctxt, &pvalue->cif);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->cif);

   rtInvokeEndElement (pctxt, "cif", -1);

   /* decode ccir601Seq */

   rtInvokeStartElement (pctxt, "ccir601Seq", -1);

   stat = DECODEBIT (pctxt, &pvalue->ccir601Seq);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->ccir601Seq);

   rtInvokeEndElement (pctxt, "ccir601Seq", -1);

   /* decode ccir601Prog */

   rtInvokeStartElement (pctxt, "ccir601Prog", -1);

   stat = DECODEBIT (pctxt, &pvalue->ccir601Prog);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->ccir601Prog);

   rtInvokeEndElement (pctxt, "ccir601Prog", -1);

   /* decode hdtvSeq */

   rtInvokeStartElement (pctxt, "hdtvSeq", -1);

   stat = DECODEBIT (pctxt, &pvalue->hdtvSeq);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->hdtvSeq);

   rtInvokeEndElement (pctxt, "hdtvSeq", -1);

   /* decode hdtvProg */

   rtInvokeStartElement (pctxt, "hdtvProg", -1);

   stat = DECODEBIT (pctxt, &pvalue->hdtvProg);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->hdtvProg);

   rtInvokeEndElement (pctxt, "hdtvProg", -1);

   /* decode g3FacsMH200x100 */

   rtInvokeStartElement (pctxt, "g3FacsMH200x100", -1);

   stat = DECODEBIT (pctxt, &pvalue->g3FacsMH200x100);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->g3FacsMH200x100);

   rtInvokeEndElement (pctxt, "g3FacsMH200x100", -1);

   /* decode g3FacsMH200x200 */

   rtInvokeStartElement (pctxt, "g3FacsMH200x200", -1);

   stat = DECODEBIT (pctxt, &pvalue->g3FacsMH200x200);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->g3FacsMH200x200);

   rtInvokeEndElement (pctxt, "g3FacsMH200x200", -1);

   /* decode g4FacsMMR200x100 */

   rtInvokeStartElement (pctxt, "g4FacsMMR200x100", -1);

   stat = DECODEBIT (pctxt, &pvalue->g4FacsMMR200x100);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->g4FacsMMR200x100);

   rtInvokeEndElement (pctxt, "g4FacsMMR200x100", -1);

   /* decode g4FacsMMR200x200 */

   rtInvokeStartElement (pctxt, "g4FacsMMR200x200", -1);

   stat = DECODEBIT (pctxt, &pvalue->g4FacsMMR200x200);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->g4FacsMMR200x200);

   rtInvokeEndElement (pctxt, "g4FacsMMR200x200", -1);

   /* decode jbig200x200Seq */

   rtInvokeStartElement (pctxt, "jbig200x200Seq", -1);

   stat = DECODEBIT (pctxt, &pvalue->jbig200x200Seq);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->jbig200x200Seq);

   rtInvokeEndElement (pctxt, "jbig200x200Seq", -1);

   /* decode jbig200x200Prog */

   rtInvokeStartElement (pctxt, "jbig200x200Prog", -1);

   stat = DECODEBIT (pctxt, &pvalue->jbig200x200Prog);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->jbig200x200Prog);

   rtInvokeEndElement (pctxt, "jbig200x200Prog", -1);

   /* decode jbig300x300Seq */

   rtInvokeStartElement (pctxt, "jbig300x300Seq", -1);

   stat = DECODEBIT (pctxt, &pvalue->jbig300x300Seq);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->jbig300x300Seq);

   rtInvokeEndElement (pctxt, "jbig300x300Seq", -1);

   /* decode jbig300x300Prog */

   rtInvokeStartElement (pctxt, "jbig300x300Prog", -1);

   stat = DECODEBIT (pctxt, &pvalue->jbig300x300Prog);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->jbig300x300Prog);

   rtInvokeEndElement (pctxt, "jbig300x300Prog", -1);

   /* decode digPhotoLow */

   rtInvokeStartElement (pctxt, "digPhotoLow", -1);

   stat = DECODEBIT (pctxt, &pvalue->digPhotoLow);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->digPhotoLow);

   rtInvokeEndElement (pctxt, "digPhotoLow", -1);

   /* decode digPhotoMedSeq */

   rtInvokeStartElement (pctxt, "digPhotoMedSeq", -1);

   stat = DECODEBIT (pctxt, &pvalue->digPhotoMedSeq);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->digPhotoMedSeq);

   rtInvokeEndElement (pctxt, "digPhotoMedSeq", -1);

   /* decode digPhotoMedProg */

   rtInvokeStartElement (pctxt, "digPhotoMedProg", -1);

   stat = DECODEBIT (pctxt, &pvalue->digPhotoMedProg);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->digPhotoMedProg);

   rtInvokeEndElement (pctxt, "digPhotoMedProg", -1);

   /* decode digPhotoHighSeq */

   rtInvokeStartElement (pctxt, "digPhotoHighSeq", -1);

   stat = DECODEBIT (pctxt, &pvalue->digPhotoHighSeq);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->digPhotoHighSeq);

   rtInvokeEndElement (pctxt, "digPhotoHighSeq", -1);

   /* decode digPhotoHighProg */

   rtInvokeStartElement (pctxt, "digPhotoHighProg", -1);

   stat = DECODEBIT (pctxt, &pvalue->digPhotoHighProg);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->digPhotoHighProg);

   rtInvokeEndElement (pctxt, "digPhotoHighProg", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  T84Profile                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245T84Profile (OOCTXT* pctxt, H245T84Profile* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* t84Unrestricted */
      case 0:
         rtInvokeStartElement (pctxt, "t84Unrestricted", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "t84Unrestricted", -1);

         break;

      /* t84Restricted */
      case 1:
         rtInvokeStartElement (pctxt, "t84Restricted", -1);

         pvalue->u.t84Restricted = ALLOC_ASN1ELEM (pctxt, H245T84Profile_t84Restricted);
         if (pvalue->u.t84Restricted == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H245T84Profile_t84Restricted (pctxt, pvalue->u.t84Restricted);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

         rtInvokeEndElement (pctxt, "t84Restricted", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataApplicationCapability_application_t84                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245DataApplicationCapability_application_t84 (OOCTXT* pctxt, H245DataApplicationCapability_application_t84* pvalue)
{
   int stat = ASN_OK;

   /* decode t84Protocol */

   rtInvokeStartElement (pctxt, "t84Protocol", -1);

   stat = asn1PD_H245DataProtocolCapability (pctxt, &pvalue->t84Protocol);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "t84Protocol", -1);

   /* decode t84Profile */

   rtInvokeStartElement (pctxt, "t84Profile", -1);

   stat = asn1PD_H245T84Profile (pctxt, &pvalue->t84Profile);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "t84Profile", -1);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataApplicationCapability_application_nlpid               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245DataApplicationCapability_application_nlpid (OOCTXT* pctxt, H245DataApplicationCapability_application_nlpid* pvalue)
{
   int stat = ASN_OK;

   /* decode nlpidProtocol */

   rtInvokeStartElement (pctxt, "nlpidProtocol", -1);

   stat = asn1PD_H245DataProtocolCapability (pctxt, &pvalue->nlpidProtocol);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "nlpidProtocol", -1);

   /* decode nlpidData */

   rtInvokeStartElement (pctxt, "nlpidData", -1);

   stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->nlpidData);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->nlpidData.numocts, pvalue->nlpidData.data);

   rtInvokeEndElement (pctxt, "nlpidData", -1);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  T38FaxRateManagement                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245T38FaxRateManagement (OOCTXT* pctxt, H245T38FaxRateManagement* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* localTCF */
         case 0:
            rtInvokeStartElement (pctxt, "localTCF", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "localTCF", -1);

            break;

         /* transferredTCF */
         case 1:
            rtInvokeStartElement (pctxt, "transferredTCF", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "transferredTCF", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  T38FaxUdpOptions_t38FaxUdpEC                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245T38FaxUdpOptions_t38FaxUdpEC (OOCTXT* pctxt, H245T38FaxUdpOptions_t38FaxUdpEC* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* t38UDPFEC */
         case 0:
            rtInvokeStartElement (pctxt, "t38UDPFEC", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "t38UDPFEC", -1);

            break;

         /* t38UDPRedundancy */
         case 1:
            rtInvokeStartElement (pctxt, "t38UDPRedundancy", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "t38UDPRedundancy", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  T38FaxUdpOptions                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245T38FaxUdpOptions (OOCTXT* pctxt, H245T38FaxUdpOptions* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.t38FaxMaxBufferPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.t38FaxMaxDatagramPresent = optbit;

   /* decode t38FaxMaxBuffer */

   if (pvalue->m.t38FaxMaxBufferPresent) {
      rtInvokeStartElement (pctxt, "t38FaxMaxBuffer", -1);

      stat = decodeUnconsInteger (pctxt, &pvalue->t38FaxMaxBuffer);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeIntValue (pctxt, pvalue->t38FaxMaxBuffer);

      rtInvokeEndElement (pctxt, "t38FaxMaxBuffer", -1);
   }

   /* decode t38FaxMaxDatagram */

   if (pvalue->m.t38FaxMaxDatagramPresent) {
      rtInvokeStartElement (pctxt, "t38FaxMaxDatagram", -1);

      stat = decodeUnconsInteger (pctxt, &pvalue->t38FaxMaxDatagram);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeIntValue (pctxt, pvalue->t38FaxMaxDatagram);

      rtInvokeEndElement (pctxt, "t38FaxMaxDatagram", -1);
   }

   /* decode t38FaxUdpEC */

   rtInvokeStartElement (pctxt, "t38FaxUdpEC", -1);

   stat = asn1PD_H245T38FaxUdpOptions_t38FaxUdpEC (pctxt, &pvalue->t38FaxUdpEC);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "t38FaxUdpEC", -1);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  T38FaxTcpOptions                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245T38FaxTcpOptions (OOCTXT* pctxt, H245T38FaxTcpOptions* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode t38TCPBidirectionalMode */

   rtInvokeStartElement (pctxt, "t38TCPBidirectionalMode", -1);

   stat = DECODEBIT (pctxt, &pvalue->t38TCPBidirectionalMode);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->t38TCPBidirectionalMode);

   rtInvokeEndElement (pctxt, "t38TCPBidirectionalMode", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  T38FaxProfile                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245T38FaxProfile (OOCTXT* pctxt, H245T38FaxProfile* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   /* decode fillBitRemoval */

   rtInvokeStartElement (pctxt, "fillBitRemoval", -1);

   stat = DECODEBIT (pctxt, &pvalue->fillBitRemoval);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->fillBitRemoval);

   rtInvokeEndElement (pctxt, "fillBitRemoval", -1);

   /* decode transcodingJBIG */

   rtInvokeStartElement (pctxt, "transcodingJBIG", -1);

   stat = DECODEBIT (pctxt, &pvalue->transcodingJBIG);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->transcodingJBIG);

   rtInvokeEndElement (pctxt, "transcodingJBIG", -1);

   /* decode transcodingMMR */

   rtInvokeStartElement (pctxt, "transcodingMMR", -1);

   stat = DECODEBIT (pctxt, &pvalue->transcodingMMR);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->transcodingMMR);

   rtInvokeEndElement (pctxt, "transcodingMMR", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 4 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.versionPresent = 1;

                     rtInvokeStartElement (pctxt, "version", -1);

                     stat = decodeConsUInt8 (pctxt, &pvalue->version, 0U, 255U);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeUIntValue (pctxt, pvalue->version);

                     rtInvokeEndElement (pctxt, "version", -1);
                     break;

                  case 1:
                     pvalue->m.t38FaxRateManagementPresent = 1;

                     rtInvokeStartElement (pctxt, "t38FaxRateManagement", -1);

                     stat = asn1PD_H245T38FaxRateManagement (pctxt, &pvalue->t38FaxRateManagement);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "t38FaxRateManagement", -1);
                     break;

                  case 2:
                     pvalue->m.t38FaxUdpOptionsPresent = 1;

                     rtInvokeStartElement (pctxt, "t38FaxUdpOptions", -1);

                     stat = asn1PD_H245T38FaxUdpOptions (pctxt, &pvalue->t38FaxUdpOptions);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "t38FaxUdpOptions", -1);
                     break;

                  case 3:
                     pvalue->m.t38FaxTcpOptionsPresent = 1;

                     rtInvokeStartElement (pctxt, "t38FaxTcpOptions", -1);

                     stat = asn1PD_H245T38FaxTcpOptions (pctxt, &pvalue->t38FaxTcpOptions);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "t38FaxTcpOptions", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 4) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataApplicationCapability_application_t38fax              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245DataApplicationCapability_application_t38fax (OOCTXT* pctxt, H245DataApplicationCapability_application_t38fax* pvalue)
{
   int stat = ASN_OK;

   /* decode t38FaxProtocol */

   rtInvokeStartElement (pctxt, "t38FaxProtocol", -1);

   stat = asn1PD_H245DataProtocolCapability (pctxt, &pvalue->t38FaxProtocol);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "t38FaxProtocol", -1);

   /* decode t38FaxProfile */

   rtInvokeStartElement (pctxt, "t38FaxProfile", -1);

   stat = asn1PD_H245T38FaxProfile (pctxt, &pvalue->t38FaxProfile);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "t38FaxProfile", -1);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CapabilityIdentifier                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CapabilityIdentifier (OOCTXT* pctxt, H245CapabilityIdentifier* pvalue)
{
   static Asn1SizeCnst domainBased_lsize1 = { 0, 1, 64, 0 };
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* standard */
         case 0:
            rtInvokeStartElement (pctxt, "standard", -1);

            pvalue->u.standard = ALLOC_ASN1ELEM (pctxt, ASN1OBJID);
            if (pvalue->u.standard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = decodeObjectIdentifier (pctxt, pvalue->u.standard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeOidValue (pctxt, pvalue->u.standard->numids, pvalue->u.standard->subid);

            rtInvokeEndElement (pctxt, "standard", -1);

            break;

         /* h221NonStandard */
         case 1:
            rtInvokeStartElement (pctxt, "h221NonStandard", -1);

            pvalue->u.h221NonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.h221NonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.h221NonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h221NonStandard", -1);

            break;

         /* uuid */
         case 2:
            rtInvokeStartElement (pctxt, "uuid", -1);

            pvalue->u.uuid = ALLOC_ASN1ELEM (pctxt, H245CapabilityIdentifier_uuid);
            if (pvalue->u.uuid == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245CapabilityIdentifier_uuid (pctxt, pvalue->u.uuid);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "uuid", -1);

            break;

         /* domainBased */
         case 3:
            rtInvokeStartElement (pctxt, "domainBased", -1);

            stat = addSizeConstraint (pctxt, &domainBased_lsize1);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            stat = decodeConstrainedStringEx (pctxt, &pvalue->u.domainBased, 0, 8, 7, 7);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeCharStrValue (pctxt, pvalue->u.domainBased);

            rtInvokeEndElement (pctxt, "domainBased", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ParameterIdentifier                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ParameterIdentifier (OOCTXT* pctxt, H245ParameterIdentifier* pvalue)
{
   static Asn1SizeCnst domainBased_lsize1 = { 0, 1, 64, 0 };
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* standard */
         case 0:
            rtInvokeStartElement (pctxt, "standard", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->u.standard, 0U, 127U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.standard);

            rtInvokeEndElement (pctxt, "standard", -1);

            break;

         /* h221NonStandard */
         case 1:
            rtInvokeStartElement (pctxt, "h221NonStandard", -1);

            pvalue->u.h221NonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.h221NonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.h221NonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h221NonStandard", -1);

            break;

         /* uuid */
         case 2:
            rtInvokeStartElement (pctxt, "uuid", -1);

            pvalue->u.uuid = ALLOC_ASN1ELEM (pctxt, H245ParameterIdentifier_uuid);
            if (pvalue->u.uuid == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245ParameterIdentifier_uuid (pctxt, pvalue->u.uuid);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "uuid", -1);

            break;

         /* domainBased */
         case 3:
            rtInvokeStartElement (pctxt, "domainBased", -1);

            stat = addSizeConstraint (pctxt, &domainBased_lsize1);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            stat = decodeConstrainedStringEx (pctxt, &pvalue->u.domainBased, 0, 8, 7, 7);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeCharStrValue (pctxt, pvalue->u.domainBased);

            rtInvokeEndElement (pctxt, "domainBased", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ParameterValue                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ParameterValue (OOCTXT* pctxt, H245ParameterValue* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 7);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* logical */
         case 0:
            rtInvokeStartElement (pctxt, "logical", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "logical", -1);

            break;

         /* booleanArray */
         case 1:
            rtInvokeStartElement (pctxt, "booleanArray", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->u.booleanArray, 0U, 255U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.booleanArray);

            rtInvokeEndElement (pctxt, "booleanArray", -1);

            break;

         /* unsignedMin */
         case 2:
            rtInvokeStartElement (pctxt, "unsignedMin", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.unsignedMin, 0U, 65535U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.unsignedMin);

            rtInvokeEndElement (pctxt, "unsignedMin", -1);

            break;

         /* unsignedMax */
         case 3:
            rtInvokeStartElement (pctxt, "unsignedMax", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.unsignedMax, 0U, 65535U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.unsignedMax);

            rtInvokeEndElement (pctxt, "unsignedMax", -1);

            break;

         /* unsigned32Min */
         case 4:
            rtInvokeStartElement (pctxt, "unsigned32Min", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->u.unsigned32Min, 0U, ASN1UINT_MAX);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.unsigned32Min);

            rtInvokeEndElement (pctxt, "unsigned32Min", -1);

            break;

         /* unsigned32Max */
         case 5:
            rtInvokeStartElement (pctxt, "unsigned32Max", -1);

            stat = decodeConsUnsigned (pctxt, &pvalue->u.unsigned32Max, 0U, ASN1UINT_MAX);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.unsigned32Max);

            rtInvokeEndElement (pctxt, "unsigned32Max", -1);

            break;

         /* octetString */
         case 6:
            rtInvokeStartElement (pctxt, "octetString", -1);

            pvalue->u.octetString = ALLOC_ASN1ELEM (pctxt, ASN1DynOctStr);
            if (pvalue->u.octetString == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)pvalue->u.octetString);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeOctStrValue (pctxt, pvalue->u.octetString->numocts, pvalue->u.octetString->data);

            rtInvokeEndElement (pctxt, "octetString", -1);

            break;

         /* genericParameter */
         case 7:
            rtInvokeStartElement (pctxt, "genericParameter", -1);

            pvalue->u.genericParameter = ALLOC_ASN1ELEM (pctxt, H245_SeqOfH245GenericParameter);
            if (pvalue->u.genericParameter == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245_SeqOfH245GenericParameter (pctxt, (H245_SeqOfH245GenericParameter*)pvalue->u.genericParameter);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "genericParameter", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 9;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH245ParameterIdentifier                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245_SeqOfH245ParameterIdentifier (OOCTXT* pctxt, H245_SeqOfH245ParameterIdentifier* pvalue)
{
   int stat = ASN_OK;
   H245ParameterIdentifier* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         rtInvokeStartElement (pctxt, "elem", xx1);

         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245ParameterIdentifier);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H245ParameterIdentifier (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         rtInvokeEndElement (pctxt, "elem", xx1);

         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GenericParameter                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245GenericParameter (OOCTXT* pctxt, H245GenericParameter* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.supersedesPresent = optbit;

   /* decode parameterIdentifier */

   rtInvokeStartElement (pctxt, "parameterIdentifier", -1);

   stat = asn1PD_H245ParameterIdentifier (pctxt, &pvalue->parameterIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "parameterIdentifier", -1);

   /* decode parameterValue */

   rtInvokeStartElement (pctxt, "parameterValue", -1);

   stat = asn1PD_H245ParameterValue (pctxt, &pvalue->parameterValue);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "parameterValue", -1);

   /* decode supersedes */

   if (pvalue->m.supersedesPresent) {
      rtInvokeStartElement (pctxt, "supersedes", -1);

      stat = asn1PD_H245_SeqOfH245ParameterIdentifier (pctxt, &pvalue->supersedes);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "supersedes", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH245GenericParameter                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245_SeqOfH245GenericParameter (OOCTXT* pctxt, H245_SeqOfH245GenericParameter* pvalue)
{
   int stat = ASN_OK;
   H245GenericParameter* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         rtInvokeStartElement (pctxt, "elem", xx1);

         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245GenericParameter);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H245GenericParameter (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         rtInvokeEndElement (pctxt, "elem", xx1);

         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GenericCapability                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245GenericCapability (OOCTXT* pctxt, H245GenericCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.maxBitRatePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.collapsingPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonCollapsingPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonCollapsingRawPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transportPresent = optbit;

   /* decode capabilityIdentifier */

   rtInvokeStartElement (pctxt, "capabilityIdentifier", -1);

   stat = asn1PD_H245CapabilityIdentifier (pctxt, &pvalue->capabilityIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "capabilityIdentifier", -1);

   /* decode maxBitRate */

   if (pvalue->m.maxBitRatePresent) {
      rtInvokeStartElement (pctxt, "maxBitRate", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->maxBitRate, 0U, ASN1UINT_MAX);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->maxBitRate);

      rtInvokeEndElement (pctxt, "maxBitRate", -1);
   }

   /* decode collapsing */

   if (pvalue->m.collapsingPresent) {
      rtInvokeStartElement (pctxt, "collapsing", -1);

      stat = asn1PD_H245_SeqOfH245GenericParameter (pctxt, &pvalue->collapsing);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "collapsing", -1);
   }

   /* decode nonCollapsing */

   if (pvalue->m.nonCollapsingPresent) {
      rtInvokeStartElement (pctxt, "nonCollapsing", -1);

      stat = asn1PD_H245_SeqOfH245GenericParameter (pctxt, &pvalue->nonCollapsing);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "nonCollapsing", -1);
   }

   /* decode nonCollapsingRaw */

   if (pvalue->m.nonCollapsingRawPresent) {
      rtInvokeStartElement (pctxt, "nonCollapsingRaw", -1);

      stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->nonCollapsingRaw);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeOctStrValue (pctxt, pvalue->nonCollapsingRaw.numocts, pvalue->nonCollapsingRaw.data);

      rtInvokeEndElement (pctxt, "nonCollapsingRaw", -1);
   }

   /* decode transport */

   if (pvalue->m.transportPresent) {
      rtInvokeStartElement (pctxt, "transport", -1);

      stat = asn1PD_H245DataProtocolCapability (pctxt, &pvalue->transport);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "transport", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataApplicationCapability_application                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245DataApplicationCapability_application (OOCTXT* pctxt, H245DataApplicationCapability_application* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 9);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* t120 */
         case 1:
            rtInvokeStartElement (pctxt, "t120", -1);

            pvalue->u.t120 = ALLOC_ASN1ELEM (pctxt, H245DataProtocolCapability);
            if (pvalue->u.t120 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.t120);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "t120", -1);

            break;

         /* dsm_cc */
         case 2:
            rtInvokeStartElement (pctxt, "dsm_cc", -1);

            pvalue->u.dsm_cc = ALLOC_ASN1ELEM (pctxt, H245DataProtocolCapability);
            if (pvalue->u.dsm_cc == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.dsm_cc);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "dsm_cc", -1);

            break;

         /* userData */
         case 3:
            rtInvokeStartElement (pctxt, "userData", -1);

            pvalue->u.userData = ALLOC_ASN1ELEM (pctxt, H245DataProtocolCapability);
            if (pvalue->u.userData == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.userData);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "userData", -1);

            break;

         /* t84 */
         case 4:
            rtInvokeStartElement (pctxt, "t84", -1);

            pvalue->u.t84 = ALLOC_ASN1ELEM (pctxt, H245DataApplicationCapability_application_t84);
            if (pvalue->u.t84 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataApplicationCapability_application_t84 (pctxt, pvalue->u.t84);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "t84", -1);

            break;

         /* t434 */
         case 5:
            rtInvokeStartElement (pctxt, "t434", -1);

            pvalue->u.t434 = ALLOC_ASN1ELEM (pctxt, H245DataProtocolCapability);
            if (pvalue->u.t434 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.t434);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "t434", -1);

            break;

         /* h224 */
         case 6:
            rtInvokeStartElement (pctxt, "h224", -1);

            pvalue->u.h224 = ALLOC_ASN1ELEM (pctxt, H245DataProtocolCapability);
            if (pvalue->u.h224 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.h224);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h224", -1);

            break;

         /* nlpid */
         case 7:
            rtInvokeStartElement (pctxt, "nlpid", -1);

            pvalue->u.nlpid = ALLOC_ASN1ELEM (pctxt, H245DataApplicationCapability_application_nlpid);
            if (pvalue->u.nlpid == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataApplicationCapability_application_nlpid (pctxt, pvalue->u.nlpid);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nlpid", -1);

            break;

         /* dsvdControl */
         case 8:
            rtInvokeStartElement (pctxt, "dsvdControl", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "dsvdControl", -1);

            break;

         /* h222DataPartitioning */
         case 9:
            rtInvokeStartElement (pctxt, "h222DataPartitioning", -1);

            pvalue->u.h222DataPartitioning = ALLOC_ASN1ELEM (pctxt, H245DataProtocolCapability);
            if (pvalue->u.h222DataPartitioning == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.h222DataPartitioning);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h222DataPartitioning", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 11;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* t30fax */
         case 11:
            rtInvokeStartElement (pctxt, "t30fax", -1);

            pvalue->u.t30fax = ALLOC_ASN1ELEM (pctxt, H245DataProtocolCapability);
            if (pvalue->u.t30fax == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.t30fax);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "t30fax", -1);

            break;

         /* t140 */
         case 12:
            rtInvokeStartElement (pctxt, "t140", -1);

            pvalue->u.t140 = ALLOC_ASN1ELEM (pctxt, H245DataProtocolCapability);
            if (pvalue->u.t140 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.t140);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "t140", -1);

            break;

         /* t38fax */
         case 13:
            rtInvokeStartElement (pctxt, "t38fax", -1);

            pvalue->u.t38fax = ALLOC_ASN1ELEM (pctxt, H245DataApplicationCapability_application_t38fax);
            if (pvalue->u.t38fax == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataApplicationCapability_application_t38fax (pctxt, pvalue->u.t38fax);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "t38fax", -1);

            break;

         /* genericDataCapability */
         case 14:
            rtInvokeStartElement (pctxt, "genericDataCapability", -1);

            pvalue->u.genericDataCapability = ALLOC_ASN1ELEM (pctxt, H245GenericCapability);
            if (pvalue->u.genericDataCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245GenericCapability (pctxt, pvalue->u.genericDataCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "genericDataCapability", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataApplicationCapability                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245DataApplicationCapability (OOCTXT* pctxt, H245DataApplicationCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode application */

   rtInvokeStartElement (pctxt, "application", -1);

   stat = asn1PD_H245DataApplicationCapability_application (pctxt, &pvalue->application);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "application", -1);

   /* decode maxBitRate */

   rtInvokeStartElement (pctxt, "maxBitRate", -1);

   stat = decodeConsUnsigned (pctxt, &pvalue->maxBitRate, 0U, ASN1UINT_MAX);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maxBitRate);

   rtInvokeEndElement (pctxt, "maxBitRate", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH245DataApplicationCapability                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245_SeqOfH245DataApplicationCapability (OOCTXT* pctxt, H245_SeqOfH245DataApplicationCapability* pvalue)
{
   int stat = ASN_OK;
   H245DataApplicationCapability* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         rtInvokeStartElement (pctxt, "elem", xx1);

         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245DataApplicationCapability);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H245DataApplicationCapability (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         rtInvokeEndElement (pctxt, "elem", xx1);

         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MediaDistributionCapability                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MediaDistributionCapability (OOCTXT* pctxt, H245MediaDistributionCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.centralizedDataPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.distributedDataPresent = optbit;

   /* decode centralizedControl */

   rtInvokeStartElement (pctxt, "centralizedControl", -1);

   stat = DECODEBIT (pctxt, &pvalue->centralizedControl);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->centralizedControl);

   rtInvokeEndElement (pctxt, "centralizedControl", -1);

   /* decode distributedControl */

   rtInvokeStartElement (pctxt, "distributedControl", -1);

   stat = DECODEBIT (pctxt, &pvalue->distributedControl);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->distributedControl);

   rtInvokeEndElement (pctxt, "distributedControl", -1);

   /* decode centralizedAudio */

   rtInvokeStartElement (pctxt, "centralizedAudio", -1);

   stat = DECODEBIT (pctxt, &pvalue->centralizedAudio);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->centralizedAudio);

   rtInvokeEndElement (pctxt, "centralizedAudio", -1);

   /* decode distributedAudio */

   rtInvokeStartElement (pctxt, "distributedAudio", -1);

   stat = DECODEBIT (pctxt, &pvalue->distributedAudio);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->distributedAudio);

   rtInvokeEndElement (pctxt, "distributedAudio", -1);

   /* decode centralizedVideo */

   rtInvokeStartElement (pctxt, "centralizedVideo", -1);

   stat = DECODEBIT (pctxt, &pvalue->centralizedVideo);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->centralizedVideo);

   rtInvokeEndElement (pctxt, "centralizedVideo", -1);

   /* decode distributedVideo */

   rtInvokeStartElement (pctxt, "distributedVideo", -1);

   stat = DECODEBIT (pctxt, &pvalue->distributedVideo);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->distributedVideo);

   rtInvokeEndElement (pctxt, "distributedVideo", -1);

   /* decode centralizedData */

   if (pvalue->m.centralizedDataPresent) {
      rtInvokeStartElement (pctxt, "centralizedData", -1);

      stat = asn1PD_H245_SeqOfH245DataApplicationCapability (pctxt, &pvalue->centralizedData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "centralizedData", -1);
   }

   /* decode distributedData */

   if (pvalue->m.distributedDataPresent) {
      rtInvokeStartElement (pctxt, "distributedData", -1);

      stat = asn1PD_H245_SeqOfH245DataApplicationCapability (pctxt, &pvalue->distributedData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "distributedData", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH245MediaDistributionCapability                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245_SeqOfH245MediaDistributionCapability (OOCTXT* pctxt, H245_SeqOfH245MediaDistributionCapability* pvalue)
{
   int stat = ASN_OK;
   H245MediaDistributionCapability* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         rtInvokeStartElement (pctxt, "elem", xx1);

         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245MediaDistributionCapability);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H245MediaDistributionCapability (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         rtInvokeEndElement (pctxt, "elem", xx1);

         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultipointCapability                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultipointCapability (OOCTXT* pctxt, H245MultipointCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode multicastCapability */

   rtInvokeStartElement (pctxt, "multicastCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->multicastCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->multicastCapability);

   rtInvokeEndElement (pctxt, "multicastCapability", -1);

   /* decode multiUniCastConference */

   rtInvokeStartElement (pctxt, "multiUniCastConference", -1);

   stat = DECODEBIT (pctxt, &pvalue->multiUniCastConference);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->multiUniCastConference);

   rtInvokeEndElement (pctxt, "multiUniCastConference", -1);

   /* decode mediaDistributionCapability */

   rtInvokeStartElement (pctxt, "mediaDistributionCapability", -1);

   stat = asn1PD_H245_SeqOfH245MediaDistributionCapability (pctxt, &pvalue->mediaDistributionCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "mediaDistributionCapability", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H2250Capability_mcCapability                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H2250Capability_mcCapability (OOCTXT* pctxt, H245H2250Capability_mcCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode centralizedConferenceMC */

   rtInvokeStartElement (pctxt, "centralizedConferenceMC", -1);

   stat = DECODEBIT (pctxt, &pvalue->centralizedConferenceMC);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->centralizedConferenceMC);

   rtInvokeEndElement (pctxt, "centralizedConferenceMC", -1);

   /* decode decentralizedConferenceMC */

   rtInvokeStartElement (pctxt, "decentralizedConferenceMC", -1);

   stat = DECODEBIT (pctxt, &pvalue->decentralizedConferenceMC);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->decentralizedConferenceMC);

   rtInvokeEndElement (pctxt, "decentralizedConferenceMC", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RTPPayloadType_payloadDescriptor                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RTPPayloadType_payloadDescriptor (OOCTXT* pctxt, H245RTPPayloadType_payloadDescriptor* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandardIdentifier */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandardIdentifier", -1);

            pvalue->u.nonStandardIdentifier = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandardIdentifier == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandardIdentifier);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandardIdentifier", -1);

            break;

         /* rfc_number */
         case 1:
            rtInvokeStartElement (pctxt, "rfc_number", -1);

            /* extension bit */

            stat = DECODEBIT (pctxt, &extbit);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (extbit == 0) {
               stat = decodeConsInteger (pctxt, &pvalue->u.rfc_number, 1, 32768);
               if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            }
            else {
               stat = decodeUnconsInteger (pctxt, &pvalue->u.rfc_number);
               if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            }
            rtInvokeIntValue (pctxt, pvalue->u.rfc_number);

            rtInvokeEndElement (pctxt, "rfc_number", -1);

            break;

         /* oid */
         case 2:
            rtInvokeStartElement (pctxt, "oid", -1);

            pvalue->u.oid = ALLOC_ASN1ELEM (pctxt, ASN1OBJID);
            if (pvalue->u.oid == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = decodeObjectIdentifier (pctxt, pvalue->u.oid);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeOidValue (pctxt, pvalue->u.oid->numids, pvalue->u.oid->subid);

            rtInvokeEndElement (pctxt, "oid", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RTPPayloadType                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RTPPayloadType (OOCTXT* pctxt, H245RTPPayloadType* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.payloadTypePresent = optbit;

   /* decode payloadDescriptor */

   rtInvokeStartElement (pctxt, "payloadDescriptor", -1);

   stat = asn1PD_H245RTPPayloadType_payloadDescriptor (pctxt, &pvalue->payloadDescriptor);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "payloadDescriptor", -1);

   /* decode payloadType */

   if (pvalue->m.payloadTypePresent) {
      rtInvokeStartElement (pctxt, "payloadType", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->payloadType, 0U, 127U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->payloadType);

      rtInvokeEndElement (pctxt, "payloadType", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MediaPacketizationCapability_rtpPayloadType               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MediaPacketizationCapability_rtpPayloadType (OOCTXT* pctxt, H245MediaPacketizationCapability_rtpPayloadType* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   H245RTPPayloadType* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245RTPPayloadType);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245RTPPayloadType (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MediaPacketizationCapability                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MediaPacketizationCapability (OOCTXT* pctxt, H245MediaPacketizationCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   /* decode h261aVideoPacketization */

   rtInvokeStartElement (pctxt, "h261aVideoPacketization", -1);

   stat = DECODEBIT (pctxt, &pvalue->h261aVideoPacketization);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->h261aVideoPacketization);

   rtInvokeEndElement (pctxt, "h261aVideoPacketization", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 1 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.rtpPayloadTypePresent = 1;

                     rtInvokeStartElement (pctxt, "rtpPayloadType", -1);

                     stat = asn1PD_H245MediaPacketizationCapability_rtpPayloadType (pctxt, &pvalue->rtpPayloadType);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "rtpPayloadType", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 1) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QOSMode                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245QOSMode (OOCTXT* pctxt, H245QOSMode* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* guaranteedQOS */
         case 0:
            rtInvokeStartElement (pctxt, "guaranteedQOS", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "guaranteedQOS", -1);

            break;

         /* controlledLoad */
         case 1:
            rtInvokeStartElement (pctxt, "controlledLoad", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "controlledLoad", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RSVPParameters                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RSVPParameters (OOCTXT* pctxt, H245RSVPParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.qosModePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tokenRatePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.bucketSizePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.peakRatePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.minPolicedPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.maxPktSizePresent = optbit;

   /* decode qosMode */

   if (pvalue->m.qosModePresent) {
      rtInvokeStartElement (pctxt, "qosMode", -1);

      stat = asn1PD_H245QOSMode (pctxt, &pvalue->qosMode);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "qosMode", -1);
   }

   /* decode tokenRate */

   if (pvalue->m.tokenRatePresent) {
      rtInvokeStartElement (pctxt, "tokenRate", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->tokenRate, 1U, ASN1UINT_MAX);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->tokenRate);

      rtInvokeEndElement (pctxt, "tokenRate", -1);
   }

   /* decode bucketSize */

   if (pvalue->m.bucketSizePresent) {
      rtInvokeStartElement (pctxt, "bucketSize", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->bucketSize, 1U, ASN1UINT_MAX);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->bucketSize);

      rtInvokeEndElement (pctxt, "bucketSize", -1);
   }

   /* decode peakRate */

   if (pvalue->m.peakRatePresent) {
      rtInvokeStartElement (pctxt, "peakRate", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->peakRate, 1U, ASN1UINT_MAX);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->peakRate);

      rtInvokeEndElement (pctxt, "peakRate", -1);
   }

   /* decode minPoliced */

   if (pvalue->m.minPolicedPresent) {
      rtInvokeStartElement (pctxt, "minPoliced", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->minPoliced, 1U, ASN1UINT_MAX);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->minPoliced);

      rtInvokeEndElement (pctxt, "minPoliced", -1);
   }

   /* decode maxPktSize */

   if (pvalue->m.maxPktSizePresent) {
      rtInvokeStartElement (pctxt, "maxPktSize", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->maxPktSize, 1U, ASN1UINT_MAX);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->maxPktSize);

      rtInvokeEndElement (pctxt, "maxPktSize", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ATMParameters                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ATMParameters (OOCTXT* pctxt, H245ATMParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode maxNTUSize */

   rtInvokeStartElement (pctxt, "maxNTUSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maxNTUSize, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maxNTUSize);

   rtInvokeEndElement (pctxt, "maxNTUSize", -1);

   /* decode atmUBR */

   rtInvokeStartElement (pctxt, "atmUBR", -1);

   stat = DECODEBIT (pctxt, &pvalue->atmUBR);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->atmUBR);

   rtInvokeEndElement (pctxt, "atmUBR", -1);

   /* decode atmrtVBR */

   rtInvokeStartElement (pctxt, "atmrtVBR", -1);

   stat = DECODEBIT (pctxt, &pvalue->atmrtVBR);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->atmrtVBR);

   rtInvokeEndElement (pctxt, "atmrtVBR", -1);

   /* decode atmnrtVBR */

   rtInvokeStartElement (pctxt, "atmnrtVBR", -1);

   stat = DECODEBIT (pctxt, &pvalue->atmnrtVBR);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->atmnrtVBR);

   rtInvokeEndElement (pctxt, "atmnrtVBR", -1);

   /* decode atmABR */

   rtInvokeStartElement (pctxt, "atmABR", -1);

   stat = DECODEBIT (pctxt, &pvalue->atmABR);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->atmABR);

   rtInvokeEndElement (pctxt, "atmABR", -1);

   /* decode atmCBR */

   rtInvokeStartElement (pctxt, "atmCBR", -1);

   stat = DECODEBIT (pctxt, &pvalue->atmCBR);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->atmCBR);

   rtInvokeEndElement (pctxt, "atmCBR", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QOSCapability                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245QOSCapability (OOCTXT* pctxt, H245QOSCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardDataPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rsvpParametersPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.atmParametersPresent = optbit;

   /* decode nonStandardData */

   if (pvalue->m.nonStandardDataPresent) {
      rtInvokeStartElement (pctxt, "nonStandardData", -1);

      stat = asn1PD_H245NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "nonStandardData", -1);
   }

   /* decode rsvpParameters */

   if (pvalue->m.rsvpParametersPresent) {
      rtInvokeStartElement (pctxt, "rsvpParameters", -1);

      stat = asn1PD_H245RSVPParameters (pctxt, &pvalue->rsvpParameters);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "rsvpParameters", -1);
   }

   /* decode atmParameters */

   if (pvalue->m.atmParametersPresent) {
      rtInvokeStartElement (pctxt, "atmParameters", -1);

      stat = asn1PD_H245ATMParameters (pctxt, &pvalue->atmParameters);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "atmParameters", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportCapability_qOSCapabilities                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245TransportCapability_qOSCapabilities (OOCTXT* pctxt, H245TransportCapability_qOSCapabilities* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   H245QOSCapability* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245QOSCapability);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245QOSCapability (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MediaTransportType_atm_AAL5_compressed                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MediaTransportType_atm_AAL5_compressed (OOCTXT* pctxt, H245MediaTransportType_atm_AAL5_compressed* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode variable_delta */

   rtInvokeStartElement (pctxt, "variable_delta", -1);

   stat = DECODEBIT (pctxt, &pvalue->variable_delta);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->variable_delta);

   rtInvokeEndElement (pctxt, "variable_delta", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MediaTransportType                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MediaTransportType (OOCTXT* pctxt, H245MediaTransportType* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* ip_UDP */
         case 0:
            rtInvokeStartElement (pctxt, "ip_UDP", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "ip_UDP", -1);

            break;

         /* ip_TCP */
         case 1:
            rtInvokeStartElement (pctxt, "ip_TCP", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "ip_TCP", -1);

            break;

         /* atm_AAL5_UNIDIR */
         case 2:
            rtInvokeStartElement (pctxt, "atm_AAL5_UNIDIR", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "atm_AAL5_UNIDIR", -1);

            break;

         /* atm_AAL5_BIDIR */
         case 3:
            rtInvokeStartElement (pctxt, "atm_AAL5_BIDIR", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "atm_AAL5_BIDIR", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* atm_AAL5_compressed */
         case 5:
            rtInvokeStartElement (pctxt, "atm_AAL5_compressed", -1);

            pvalue->u.atm_AAL5_compressed = ALLOC_ASN1ELEM (pctxt, H245MediaTransportType_atm_AAL5_compressed);
            if (pvalue->u.atm_AAL5_compressed == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MediaTransportType_atm_AAL5_compressed (pctxt, pvalue->u.atm_AAL5_compressed);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "atm_AAL5_compressed", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MediaChannelCapability                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MediaChannelCapability (OOCTXT* pctxt, H245MediaChannelCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mediaTransportPresent = optbit;

   /* decode mediaTransport */

   if (pvalue->m.mediaTransportPresent) {
      rtInvokeStartElement (pctxt, "mediaTransport", -1);

      stat = asn1PD_H245MediaTransportType (pctxt, &pvalue->mediaTransport);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "mediaTransport", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportCapability_mediaChannelCapabilities              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245TransportCapability_mediaChannelCapabilities (OOCTXT* pctxt, H245TransportCapability_mediaChannelCapabilities* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   H245MediaChannelCapability* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245MediaChannelCapability);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245MediaChannelCapability (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportCapability                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245TransportCapability (OOCTXT* pctxt, H245TransportCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.qOSCapabilitiesPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mediaChannelCapabilitiesPresent = optbit;

   /* decode nonStandard */

   if (pvalue->m.nonStandardPresent) {
      rtInvokeStartElement (pctxt, "nonStandard", -1);

      stat = asn1PD_H245NonStandardParameter (pctxt, &pvalue->nonStandard);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "nonStandard", -1);
   }

   /* decode qOSCapabilities */

   if (pvalue->m.qOSCapabilitiesPresent) {
      rtInvokeStartElement (pctxt, "qOSCapabilities", -1);

      stat = asn1PD_H245TransportCapability_qOSCapabilities (pctxt, &pvalue->qOSCapabilities);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "qOSCapabilities", -1);
   }

   /* decode mediaChannelCapabilities */

   if (pvalue->m.mediaChannelCapabilitiesPresent) {
      rtInvokeStartElement (pctxt, "mediaChannelCapabilities", -1);

      stat = asn1PD_H245TransportCapability_mediaChannelCapabilities (pctxt, &pvalue->mediaChannelCapabilities);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "mediaChannelCapabilities", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RTPH263VideoRedundancyFrameMapping_frameSequence          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RTPH263VideoRedundancyFrameMapping_frameSequence (OOCTXT* pctxt, H245RTPH263VideoRedundancyFrameMapping_frameSequence* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      stat = decodeConsUInt8 (pctxt, &pvalue->elem[xx1], 0U, 255U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->elem[xx1]);
      rtInvokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RTPH263VideoRedundancyFrameMapping                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RTPH263VideoRedundancyFrameMapping (OOCTXT* pctxt, H245RTPH263VideoRedundancyFrameMapping* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode threadNumber */

   rtInvokeStartElement (pctxt, "threadNumber", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->threadNumber, 0U, 15U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->threadNumber);

   rtInvokeEndElement (pctxt, "threadNumber", -1);

   /* decode frameSequence */

   rtInvokeStartElement (pctxt, "frameSequence", -1);

   stat = asn1PD_H245RTPH263VideoRedundancyFrameMapping_frameSequence (pctxt, &pvalue->frameSequence);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "frameSequence", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RTPH263VideoRedundancyEncoding_frameToThreadMapping_cust  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom (OOCTXT* pctxt, H245RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   H245RTPH263VideoRedundancyFrameMapping* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245RTPH263VideoRedundancyFrameMapping);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245RTPH263VideoRedundancyFrameMapping (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RTPH263VideoRedundancyEncoding_frameToThreadMapping       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RTPH263VideoRedundancyEncoding_frameToThreadMapping (OOCTXT* pctxt, H245RTPH263VideoRedundancyEncoding_frameToThreadMapping* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* roundrobin */
         case 0:
            rtInvokeStartElement (pctxt, "roundrobin", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "roundrobin", -1);

            break;

         /* custom */
         case 1:
            rtInvokeStartElement (pctxt, "custom", -1);

            pvalue->u.custom = ALLOC_ASN1ELEM (pctxt, H245RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom);
            if (pvalue->u.custom == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom (pctxt, pvalue->u.custom);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "custom", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RTPH263VideoRedundancyEncoding_containedThreads           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RTPH263VideoRedundancyEncoding_containedThreads (OOCTXT* pctxt, H245RTPH263VideoRedundancyEncoding_containedThreads* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      stat = decodeConsUInt8 (pctxt, &pvalue->elem[xx1], 0U, 15U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->elem[xx1]);
      rtInvokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RTPH263VideoRedundancyEncoding                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RTPH263VideoRedundancyEncoding (OOCTXT* pctxt, H245RTPH263VideoRedundancyEncoding* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.containedThreadsPresent = optbit;

   /* decode numberOfThreads */

   rtInvokeStartElement (pctxt, "numberOfThreads", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->numberOfThreads, 1U, 16U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->numberOfThreads);

   rtInvokeEndElement (pctxt, "numberOfThreads", -1);

   /* decode framesBetweenSyncPoints */

   rtInvokeStartElement (pctxt, "framesBetweenSyncPoints", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->framesBetweenSyncPoints, 1U, 256U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->framesBetweenSyncPoints);

   rtInvokeEndElement (pctxt, "framesBetweenSyncPoints", -1);

   /* decode frameToThreadMapping */

   rtInvokeStartElement (pctxt, "frameToThreadMapping", -1);

   stat = asn1PD_H245RTPH263VideoRedundancyEncoding_frameToThreadMapping (pctxt, &pvalue->frameToThreadMapping);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "frameToThreadMapping", -1);

   /* decode containedThreads */

   if (pvalue->m.containedThreadsPresent) {
      rtInvokeStartElement (pctxt, "containedThreads", -1);

      stat = asn1PD_H245RTPH263VideoRedundancyEncoding_containedThreads (pctxt, &pvalue->containedThreads);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "containedThreads", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RedundancyEncodingMethod                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RedundancyEncodingMethod (OOCTXT* pctxt, H245RedundancyEncodingMethod* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* rtpAudioRedundancyEncoding */
         case 1:
            rtInvokeStartElement (pctxt, "rtpAudioRedundancyEncoding", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "rtpAudioRedundancyEncoding", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* rtpH263VideoRedundancyEncoding */
         case 3:
            rtInvokeStartElement (pctxt, "rtpH263VideoRedundancyEncoding", -1);

            pvalue->u.rtpH263VideoRedundancyEncoding = ALLOC_ASN1ELEM (pctxt, H245RTPH263VideoRedundancyEncoding);
            if (pvalue->u.rtpH263VideoRedundancyEncoding == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RTPH263VideoRedundancyEncoding (pctxt, pvalue->u.rtpH263VideoRedundancyEncoding);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "rtpH263VideoRedundancyEncoding", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RedundancyEncodingCapability_secondaryEncoding            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RedundancyEncodingCapability_secondaryEncoding (OOCTXT* pctxt, H245RedundancyEncodingCapability_secondaryEncoding* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      stat = asn1PD_H245CapabilityTableEntryNumber (pctxt, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RedundancyEncodingCapability                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RedundancyEncodingCapability (OOCTXT* pctxt, H245RedundancyEncodingCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.secondaryEncodingPresent = optbit;

   /* decode redundancyEncodingMethod */

   rtInvokeStartElement (pctxt, "redundancyEncodingMethod", -1);

   stat = asn1PD_H245RedundancyEncodingMethod (pctxt, &pvalue->redundancyEncodingMethod);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "redundancyEncodingMethod", -1);

   /* decode primaryEncoding */

   rtInvokeStartElement (pctxt, "primaryEncoding", -1);

   stat = asn1PD_H245CapabilityTableEntryNumber (pctxt, &pvalue->primaryEncoding);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "primaryEncoding", -1);

   /* decode secondaryEncoding */

   if (pvalue->m.secondaryEncodingPresent) {
      rtInvokeStartElement (pctxt, "secondaryEncoding", -1);

      stat = asn1PD_H245RedundancyEncodingCapability_secondaryEncoding (pctxt, &pvalue->secondaryEncoding);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "secondaryEncoding", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H2250Capability_redundancyEncodingCapability              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H2250Capability_redundancyEncodingCapability (OOCTXT* pctxt, H245H2250Capability_redundancyEncodingCapability* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   H245RedundancyEncodingCapability* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245RedundancyEncodingCapability);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245RedundancyEncodingCapability (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H2250Capability                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H2250Capability (OOCTXT* pctxt, H245H2250Capability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   /* decode maximumAudioDelayJitter */

   rtInvokeStartElement (pctxt, "maximumAudioDelayJitter", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maximumAudioDelayJitter, 0U, 1023U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maximumAudioDelayJitter);

   rtInvokeEndElement (pctxt, "maximumAudioDelayJitter", -1);

   /* decode receiveMultipointCapability */

   rtInvokeStartElement (pctxt, "receiveMultipointCapability", -1);

   stat = asn1PD_H245MultipointCapability (pctxt, &pvalue->receiveMultipointCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "receiveMultipointCapability", -1);

   /* decode transmitMultipointCapability */

   rtInvokeStartElement (pctxt, "transmitMultipointCapability", -1);

   stat = asn1PD_H245MultipointCapability (pctxt, &pvalue->transmitMultipointCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "transmitMultipointCapability", -1);

   /* decode receiveAndTransmitMultipointCapability */

   rtInvokeStartElement (pctxt, "receiveAndTransmitMultipointCapability", -1);

   stat = asn1PD_H245MultipointCapability (pctxt, &pvalue->receiveAndTransmitMultipointCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "receiveAndTransmitMultipointCapability", -1);

   /* decode mcCapability */

   rtInvokeStartElement (pctxt, "mcCapability", -1);

   stat = asn1PD_H245H2250Capability_mcCapability (pctxt, &pvalue->mcCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "mcCapability", -1);

   /* decode rtcpVideoControlCapability */

   rtInvokeStartElement (pctxt, "rtcpVideoControlCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->rtcpVideoControlCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->rtcpVideoControlCapability);

   rtInvokeEndElement (pctxt, "rtcpVideoControlCapability", -1);

   /* decode mediaPacketizationCapability */

   rtInvokeStartElement (pctxt, "mediaPacketizationCapability", -1);

   stat = asn1PD_H245MediaPacketizationCapability (pctxt, &pvalue->mediaPacketizationCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "mediaPacketizationCapability", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 4 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.transportCapabilityPresent = 1;

                     rtInvokeStartElement (pctxt, "transportCapability", -1);

                     stat = asn1PD_H245TransportCapability (pctxt, &pvalue->transportCapability);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "transportCapability", -1);
                     break;

                  case 1:
                     pvalue->m.redundancyEncodingCapabilityPresent = 1;

                     rtInvokeStartElement (pctxt, "redundancyEncodingCapability", -1);

                     stat = asn1PD_H245H2250Capability_redundancyEncodingCapability (pctxt, &pvalue->redundancyEncodingCapability);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "redundancyEncodingCapability", -1);
                     break;

                  case 2:
                     pvalue->m.logicalChannelSwitchingCapabilityPresent = 1;

                     rtInvokeStartElement (pctxt, "logicalChannelSwitchingCapability", -1);

                     stat = DECODEBIT (pctxt, &pvalue->logicalChannelSwitchingCapability);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeBoolValue (pctxt, pvalue->logicalChannelSwitchingCapability);

                     rtInvokeEndElement (pctxt, "logicalChannelSwitchingCapability", -1);
                     break;

                  case 3:
                     pvalue->m.t120DynamicPortCapabilityPresent = 1;

                     rtInvokeStartElement (pctxt, "t120DynamicPortCapability", -1);

                     stat = DECODEBIT (pctxt, &pvalue->t120DynamicPortCapability);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeBoolValue (pctxt, pvalue->t120DynamicPortCapability);

                     rtInvokeEndElement (pctxt, "t120DynamicPortCapability", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 4) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexCapability                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplexCapability (OOCTXT* pctxt, H245MultiplexCapability* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* h222Capability */
         case 1:
            rtInvokeStartElement (pctxt, "h222Capability", -1);

            pvalue->u.h222Capability = ALLOC_ASN1ELEM (pctxt, H245H222Capability);
            if (pvalue->u.h222Capability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H222Capability (pctxt, pvalue->u.h222Capability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h222Capability", -1);

            break;

         /* h223Capability */
         case 2:
            rtInvokeStartElement (pctxt, "h223Capability", -1);

            pvalue->u.h223Capability = ALLOC_ASN1ELEM (pctxt, H245H223Capability);
            if (pvalue->u.h223Capability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H223Capability (pctxt, pvalue->u.h223Capability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h223Capability", -1);

            break;

         /* v76Capability */
         case 3:
            rtInvokeStartElement (pctxt, "v76Capability", -1);

            pvalue->u.v76Capability = ALLOC_ASN1ELEM (pctxt, H245V76Capability);
            if (pvalue->u.v76Capability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245V76Capability (pctxt, pvalue->u.v76Capability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "v76Capability", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* h2250Capability */
         case 5:
            rtInvokeStartElement (pctxt, "h2250Capability", -1);

            pvalue->u.h2250Capability = ALLOC_ASN1ELEM (pctxt, H245H2250Capability);
            if (pvalue->u.h2250Capability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H2250Capability (pctxt, pvalue->u.h2250Capability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h2250Capability", -1);

            break;

         /* genericMultiplexCapability */
         case 6:
            rtInvokeStartElement (pctxt, "genericMultiplexCapability", -1);

            pvalue->u.genericMultiplexCapability = ALLOC_ASN1ELEM (pctxt, H245GenericCapability);
            if (pvalue->u.genericMultiplexCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245GenericCapability (pctxt, pvalue->u.genericMultiplexCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "genericMultiplexCapability", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H261VideoCapability                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H261VideoCapability (OOCTXT* pctxt, H245H261VideoCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.qcifMPIPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cifMPIPresent = optbit;

   /* decode qcifMPI */

   if (pvalue->m.qcifMPIPresent) {
      rtInvokeStartElement (pctxt, "qcifMPI", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->qcifMPI, 1U, 4U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->qcifMPI);

      rtInvokeEndElement (pctxt, "qcifMPI", -1);
   }

   /* decode cifMPI */

   if (pvalue->m.cifMPIPresent) {
      rtInvokeStartElement (pctxt, "cifMPI", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->cifMPI, 1U, 4U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->cifMPI);

      rtInvokeEndElement (pctxt, "cifMPI", -1);
   }

   /* decode temporalSpatialTradeOffCapability */

   rtInvokeStartElement (pctxt, "temporalSpatialTradeOffCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->temporalSpatialTradeOffCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->temporalSpatialTradeOffCapability);

   rtInvokeEndElement (pctxt, "temporalSpatialTradeOffCapability", -1);

   /* decode maxBitRate */

   rtInvokeStartElement (pctxt, "maxBitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maxBitRate, 1U, 19200U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maxBitRate);

   rtInvokeEndElement (pctxt, "maxBitRate", -1);

   /* decode stillImageTransmission */

   rtInvokeStartElement (pctxt, "stillImageTransmission", -1);

   stat = DECODEBIT (pctxt, &pvalue->stillImageTransmission);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->stillImageTransmission);

   rtInvokeEndElement (pctxt, "stillImageTransmission", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 1 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.videoBadMBsCapPresent = 1;

                     rtInvokeStartElement (pctxt, "videoBadMBsCap", -1);

                     stat = DECODEBIT (pctxt, &pvalue->videoBadMBsCap);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeBoolValue (pctxt, pvalue->videoBadMBsCap);

                     rtInvokeEndElement (pctxt, "videoBadMBsCap", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 1) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H262VideoCapability                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H262VideoCapability (OOCTXT* pctxt, H245H262VideoCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.videoBitRatePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.vbvBufferSizePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.samplesPerLinePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.linesPerFramePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.framesPerSecondPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.luminanceSampleRatePresent = optbit;

   /* decode profileAndLevel_SPatML */

   rtInvokeStartElement (pctxt, "profileAndLevel_SPatML", -1);

   stat = DECODEBIT (pctxt, &pvalue->profileAndLevel_SPatML);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->profileAndLevel_SPatML);

   rtInvokeEndElement (pctxt, "profileAndLevel_SPatML", -1);

   /* decode profileAndLevel_MPatLL */

   rtInvokeStartElement (pctxt, "profileAndLevel_MPatLL", -1);

   stat = DECODEBIT (pctxt, &pvalue->profileAndLevel_MPatLL);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->profileAndLevel_MPatLL);

   rtInvokeEndElement (pctxt, "profileAndLevel_MPatLL", -1);

   /* decode profileAndLevel_MPatML */

   rtInvokeStartElement (pctxt, "profileAndLevel_MPatML", -1);

   stat = DECODEBIT (pctxt, &pvalue->profileAndLevel_MPatML);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->profileAndLevel_MPatML);

   rtInvokeEndElement (pctxt, "profileAndLevel_MPatML", -1);

   /* decode profileAndLevel_MPatH_14 */

   rtInvokeStartElement (pctxt, "profileAndLevel_MPatH_14", -1);

   stat = DECODEBIT (pctxt, &pvalue->profileAndLevel_MPatH_14);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->profileAndLevel_MPatH_14);

   rtInvokeEndElement (pctxt, "profileAndLevel_MPatH_14", -1);

   /* decode profileAndLevel_MPatHL */

   rtInvokeStartElement (pctxt, "profileAndLevel_MPatHL", -1);

   stat = DECODEBIT (pctxt, &pvalue->profileAndLevel_MPatHL);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->profileAndLevel_MPatHL);

   rtInvokeEndElement (pctxt, "profileAndLevel_MPatHL", -1);

   /* decode profileAndLevel_SNRatLL */

   rtInvokeStartElement (pctxt, "profileAndLevel_SNRatLL", -1);

   stat = DECODEBIT (pctxt, &pvalue->profileAndLevel_SNRatLL);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->profileAndLevel_SNRatLL);

   rtInvokeEndElement (pctxt, "profileAndLevel_SNRatLL", -1);

   /* decode profileAndLevel_SNRatML */

   rtInvokeStartElement (pctxt, "profileAndLevel_SNRatML", -1);

   stat = DECODEBIT (pctxt, &pvalue->profileAndLevel_SNRatML);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->profileAndLevel_SNRatML);

   rtInvokeEndElement (pctxt, "profileAndLevel_SNRatML", -1);

   /* decode profileAndLevel_SpatialatH_14 */

   rtInvokeStartElement (pctxt, "profileAndLevel_SpatialatH_14", -1);

   stat = DECODEBIT (pctxt, &pvalue->profileAndLevel_SpatialatH_14);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->profileAndLevel_SpatialatH_14);

   rtInvokeEndElement (pctxt, "profileAndLevel_SpatialatH_14", -1);

   /* decode profileAndLevel_HPatML */

   rtInvokeStartElement (pctxt, "profileAndLevel_HPatML", -1);

   stat = DECODEBIT (pctxt, &pvalue->profileAndLevel_HPatML);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->profileAndLevel_HPatML);

   rtInvokeEndElement (pctxt, "profileAndLevel_HPatML", -1);

   /* decode profileAndLevel_HPatH_14 */

   rtInvokeStartElement (pctxt, "profileAndLevel_HPatH_14", -1);

   stat = DECODEBIT (pctxt, &pvalue->profileAndLevel_HPatH_14);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->profileAndLevel_HPatH_14);

   rtInvokeEndElement (pctxt, "profileAndLevel_HPatH_14", -1);

   /* decode profileAndLevel_HPatHL */

   rtInvokeStartElement (pctxt, "profileAndLevel_HPatHL", -1);

   stat = DECODEBIT (pctxt, &pvalue->profileAndLevel_HPatHL);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->profileAndLevel_HPatHL);

   rtInvokeEndElement (pctxt, "profileAndLevel_HPatHL", -1);

   /* decode videoBitRate */

   if (pvalue->m.videoBitRatePresent) {
      rtInvokeStartElement (pctxt, "videoBitRate", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->videoBitRate, 0U, 1073741823U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->videoBitRate);

      rtInvokeEndElement (pctxt, "videoBitRate", -1);
   }

   /* decode vbvBufferSize */

   if (pvalue->m.vbvBufferSizePresent) {
      rtInvokeStartElement (pctxt, "vbvBufferSize", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->vbvBufferSize, 0U, 262143U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->vbvBufferSize);

      rtInvokeEndElement (pctxt, "vbvBufferSize", -1);
   }

   /* decode samplesPerLine */

   if (pvalue->m.samplesPerLinePresent) {
      rtInvokeStartElement (pctxt, "samplesPerLine", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->samplesPerLine, 0U, 16383U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->samplesPerLine);

      rtInvokeEndElement (pctxt, "samplesPerLine", -1);
   }

   /* decode linesPerFrame */

   if (pvalue->m.linesPerFramePresent) {
      rtInvokeStartElement (pctxt, "linesPerFrame", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->linesPerFrame, 0U, 16383U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->linesPerFrame);

      rtInvokeEndElement (pctxt, "linesPerFrame", -1);
   }

   /* decode framesPerSecond */

   if (pvalue->m.framesPerSecondPresent) {
      rtInvokeStartElement (pctxt, "framesPerSecond", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->framesPerSecond, 0U, 15U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->framesPerSecond);

      rtInvokeEndElement (pctxt, "framesPerSecond", -1);
   }

   /* decode luminanceSampleRate */

   if (pvalue->m.luminanceSampleRatePresent) {
      rtInvokeStartElement (pctxt, "luminanceSampleRate", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->luminanceSampleRate, 0U, ASN1UINT_MAX);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->luminanceSampleRate);

      rtInvokeEndElement (pctxt, "luminanceSampleRate", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 1 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.videoBadMBsCapPresent = 1;

                     rtInvokeStartElement (pctxt, "videoBadMBsCap", -1);

                     stat = DECODEBIT (pctxt, &pvalue->videoBadMBsCap);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeBoolValue (pctxt, pvalue->videoBadMBsCap);

                     rtInvokeEndElement (pctxt, "videoBadMBsCap", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 1) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransparencyParameters                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245TransparencyParameters (OOCTXT* pctxt, H245TransparencyParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode presentationOrder */

   rtInvokeStartElement (pctxt, "presentationOrder", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->presentationOrder, 1U, 256U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->presentationOrder);

   rtInvokeEndElement (pctxt, "presentationOrder", -1);

   /* decode offset_x */

   rtInvokeStartElement (pctxt, "offset_x", -1);

   stat = decodeConsInteger (pctxt, &pvalue->offset_x, -262144, 262143);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeIntValue (pctxt, pvalue->offset_x);

   rtInvokeEndElement (pctxt, "offset_x", -1);

   /* decode offset_y */

   rtInvokeStartElement (pctxt, "offset_y", -1);

   stat = decodeConsInteger (pctxt, &pvalue->offset_y, -262144, 262143);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeIntValue (pctxt, pvalue->offset_y);

   rtInvokeEndElement (pctxt, "offset_y", -1);

   /* decode scale_x */

   rtInvokeStartElement (pctxt, "scale_x", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->scale_x, 1U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->scale_x);

   rtInvokeEndElement (pctxt, "scale_x", -1);

   /* decode scale_y */

   rtInvokeStartElement (pctxt, "scale_y", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->scale_y, 1U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->scale_y);

   rtInvokeEndElement (pctxt, "scale_y", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RefPictureSelection_additionalPictureMemory               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RefPictureSelection_additionalPictureMemory (OOCTXT* pctxt, H245RefPictureSelection_additionalPictureMemory* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sqcifAdditionalPictureMemoryPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.qcifAdditionalPictureMemoryPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cifAdditionalPictureMemoryPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cif4AdditionalPictureMemoryPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cif16AdditionalPictureMemoryPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.bigCpfAdditionalPictureMemoryPresent = optbit;

   /* decode sqcifAdditionalPictureMemory */

   if (pvalue->m.sqcifAdditionalPictureMemoryPresent) {
      rtInvokeStartElement (pctxt, "sqcifAdditionalPictureMemory", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->sqcifAdditionalPictureMemory, 1U, 256U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->sqcifAdditionalPictureMemory);

      rtInvokeEndElement (pctxt, "sqcifAdditionalPictureMemory", -1);
   }

   /* decode qcifAdditionalPictureMemory */

   if (pvalue->m.qcifAdditionalPictureMemoryPresent) {
      rtInvokeStartElement (pctxt, "qcifAdditionalPictureMemory", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->qcifAdditionalPictureMemory, 1U, 256U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->qcifAdditionalPictureMemory);

      rtInvokeEndElement (pctxt, "qcifAdditionalPictureMemory", -1);
   }

   /* decode cifAdditionalPictureMemory */

   if (pvalue->m.cifAdditionalPictureMemoryPresent) {
      rtInvokeStartElement (pctxt, "cifAdditionalPictureMemory", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->cifAdditionalPictureMemory, 1U, 256U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->cifAdditionalPictureMemory);

      rtInvokeEndElement (pctxt, "cifAdditionalPictureMemory", -1);
   }

   /* decode cif4AdditionalPictureMemory */

   if (pvalue->m.cif4AdditionalPictureMemoryPresent) {
      rtInvokeStartElement (pctxt, "cif4AdditionalPictureMemory", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->cif4AdditionalPictureMemory, 1U, 256U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->cif4AdditionalPictureMemory);

      rtInvokeEndElement (pctxt, "cif4AdditionalPictureMemory", -1);
   }

   /* decode cif16AdditionalPictureMemory */

   if (pvalue->m.cif16AdditionalPictureMemoryPresent) {
      rtInvokeStartElement (pctxt, "cif16AdditionalPictureMemory", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->cif16AdditionalPictureMemory, 1U, 256U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->cif16AdditionalPictureMemory);

      rtInvokeEndElement (pctxt, "cif16AdditionalPictureMemory", -1);
   }

   /* decode bigCpfAdditionalPictureMemory */

   if (pvalue->m.bigCpfAdditionalPictureMemoryPresent) {
      rtInvokeStartElement (pctxt, "bigCpfAdditionalPictureMemory", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->bigCpfAdditionalPictureMemory, 1U, 256U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->bigCpfAdditionalPictureMemory);

      rtInvokeEndElement (pctxt, "bigCpfAdditionalPictureMemory", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RefPictureSelection_videoBackChannelSend                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RefPictureSelection_videoBackChannelSend (OOCTXT* pctxt, H245RefPictureSelection_videoBackChannelSend* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 4);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* none */
         case 0:
            rtInvokeStartElement (pctxt, "none", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "none", -1);

            break;

         /* ackMessageOnly */
         case 1:
            rtInvokeStartElement (pctxt, "ackMessageOnly", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "ackMessageOnly", -1);

            break;

         /* nackMessageOnly */
         case 2:
            rtInvokeStartElement (pctxt, "nackMessageOnly", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "nackMessageOnly", -1);

            break;

         /* ackOrNackMessageOnly */
         case 3:
            rtInvokeStartElement (pctxt, "ackOrNackMessageOnly", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "ackOrNackMessageOnly", -1);

            break;

         /* ackAndNackMessage */
         case 4:
            rtInvokeStartElement (pctxt, "ackAndNackMessage", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "ackAndNackMessage", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 6;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RefPictureSelection_enhancedReferencePicSelect_subPictur  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters (OOCTXT* pctxt, H245RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode mpuHorizMBs */

   rtInvokeStartElement (pctxt, "mpuHorizMBs", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->mpuHorizMBs, 1U, 128U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->mpuHorizMBs);

   rtInvokeEndElement (pctxt, "mpuHorizMBs", -1);

   /* decode mpuVertMBs */

   rtInvokeStartElement (pctxt, "mpuVertMBs", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->mpuVertMBs, 1U, 72U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->mpuVertMBs);

   rtInvokeEndElement (pctxt, "mpuVertMBs", -1);

   /* decode mpuTotalNumber */

   rtInvokeStartElement (pctxt, "mpuTotalNumber", -1);

   stat = decodeConsUnsigned (pctxt, &pvalue->mpuTotalNumber, 1U, 65536U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->mpuTotalNumber);

   rtInvokeEndElement (pctxt, "mpuTotalNumber", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RefPictureSelection_enhancedReferencePicSelect            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RefPictureSelection_enhancedReferencePicSelect (OOCTXT* pctxt, H245RefPictureSelection_enhancedReferencePicSelect* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.subPictureRemovalParametersPresent = optbit;

   /* decode subPictureRemovalParameters */

   if (pvalue->m.subPictureRemovalParametersPresent) {
      rtInvokeStartElement (pctxt, "subPictureRemovalParameters", -1);

      stat = asn1PD_H245RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters (pctxt, &pvalue->subPictureRemovalParameters);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "subPictureRemovalParameters", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RefPictureSelection                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RefPictureSelection (OOCTXT* pctxt, H245RefPictureSelection* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.additionalPictureMemoryPresent = optbit;

   /* decode additionalPictureMemory */

   if (pvalue->m.additionalPictureMemoryPresent) {
      rtInvokeStartElement (pctxt, "additionalPictureMemory", -1);

      stat = asn1PD_H245RefPictureSelection_additionalPictureMemory (pctxt, &pvalue->additionalPictureMemory);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "additionalPictureMemory", -1);
   }

   /* decode videoMux */

   rtInvokeStartElement (pctxt, "videoMux", -1);

   stat = DECODEBIT (pctxt, &pvalue->videoMux);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->videoMux);

   rtInvokeEndElement (pctxt, "videoMux", -1);

   /* decode videoBackChannelSend */

   rtInvokeStartElement (pctxt, "videoBackChannelSend", -1);

   stat = asn1PD_H245RefPictureSelection_videoBackChannelSend (pctxt, &pvalue->videoBackChannelSend);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "videoBackChannelSend", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 1 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.enhancedReferencePicSelectPresent = 1;

                     rtInvokeStartElement (pctxt, "enhancedReferencePicSelect", -1);

                     stat = asn1PD_H245RefPictureSelection_enhancedReferencePicSelect (pctxt, &pvalue->enhancedReferencePicSelect);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "enhancedReferencePicSelect", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 1) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CustomPictureClockFrequency                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CustomPictureClockFrequency (OOCTXT* pctxt, H245CustomPictureClockFrequency* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sqcifMPIPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.qcifMPIPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cifMPIPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cif4MPIPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cif16MPIPresent = optbit;

   /* decode clockConversionCode */

   rtInvokeStartElement (pctxt, "clockConversionCode", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->clockConversionCode, 1000U, 1001U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->clockConversionCode);

   rtInvokeEndElement (pctxt, "clockConversionCode", -1);

   /* decode clockDivisor */

   rtInvokeStartElement (pctxt, "clockDivisor", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->clockDivisor, 1U, 127U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->clockDivisor);

   rtInvokeEndElement (pctxt, "clockDivisor", -1);

   /* decode sqcifMPI */

   if (pvalue->m.sqcifMPIPresent) {
      rtInvokeStartElement (pctxt, "sqcifMPI", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->sqcifMPI, 1U, 2048U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->sqcifMPI);

      rtInvokeEndElement (pctxt, "sqcifMPI", -1);
   }

   /* decode qcifMPI */

   if (pvalue->m.qcifMPIPresent) {
      rtInvokeStartElement (pctxt, "qcifMPI", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->qcifMPI, 1U, 2048U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->qcifMPI);

      rtInvokeEndElement (pctxt, "qcifMPI", -1);
   }

   /* decode cifMPI */

   if (pvalue->m.cifMPIPresent) {
      rtInvokeStartElement (pctxt, "cifMPI", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->cifMPI, 1U, 2048U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->cifMPI);

      rtInvokeEndElement (pctxt, "cifMPI", -1);
   }

   /* decode cif4MPI */

   if (pvalue->m.cif4MPIPresent) {
      rtInvokeStartElement (pctxt, "cif4MPI", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->cif4MPI, 1U, 2048U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->cif4MPI);

      rtInvokeEndElement (pctxt, "cif4MPI", -1);
   }

   /* decode cif16MPI */

   if (pvalue->m.cif16MPIPresent) {
      rtInvokeStartElement (pctxt, "cif16MPI", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->cif16MPI, 1U, 2048U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->cif16MPI);

      rtInvokeEndElement (pctxt, "cif16MPI", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H263Options_customPictureClockFrequency                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H263Options_customPictureClockFrequency (OOCTXT* pctxt, H245H263Options_customPictureClockFrequency* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 16, 0 };
   int stat = ASN_OK;
   H245CustomPictureClockFrequency* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245CustomPictureClockFrequency);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245CustomPictureClockFrequency (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CustomPictureFormat_mPI_customPCF_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CustomPictureFormat_mPI_customPCF_element (OOCTXT* pctxt, H245CustomPictureFormat_mPI_customPCF_element* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode clockConversionCode */

   rtInvokeStartElement (pctxt, "clockConversionCode", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->clockConversionCode, 1000U, 1001U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->clockConversionCode);

   rtInvokeEndElement (pctxt, "clockConversionCode", -1);

   /* decode clockDivisor */

   rtInvokeStartElement (pctxt, "clockDivisor", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->clockDivisor, 1U, 127U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->clockDivisor);

   rtInvokeEndElement (pctxt, "clockDivisor", -1);

   /* decode customMPI */

   rtInvokeStartElement (pctxt, "customMPI", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->customMPI, 1U, 2048U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->customMPI);

   rtInvokeEndElement (pctxt, "customMPI", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CustomPictureFormat_mPI_customPCF                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CustomPictureFormat_mPI_customPCF (OOCTXT* pctxt, H245CustomPictureFormat_mPI_customPCF* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 16, 0 };
   int stat = ASN_OK;
   H245CustomPictureFormat_mPI_customPCF_element* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245CustomPictureFormat_mPI_customPCF_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245CustomPictureFormat_mPI_customPCF_element (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CustomPictureFormat_mPI                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CustomPictureFormat_mPI (OOCTXT* pctxt, H245CustomPictureFormat_mPI* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.standardMPIPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.customPCFPresent = optbit;

   /* decode standardMPI */

   if (pvalue->m.standardMPIPresent) {
      rtInvokeStartElement (pctxt, "standardMPI", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->standardMPI, 1U, 31U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->standardMPI);

      rtInvokeEndElement (pctxt, "standardMPI", -1);
   }

   /* decode customPCF */

   if (pvalue->m.customPCFPresent) {
      rtInvokeStartElement (pctxt, "customPCF", -1);

      stat = asn1PD_H245CustomPictureFormat_mPI_customPCF (pctxt, &pvalue->customPCF);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "customPCF", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CustomPictureFormat_pixelAspectInformation_pixelAspectCo  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CustomPictureFormat_pixelAspectInformation_pixelAspectCode (OOCTXT* pctxt, H245CustomPictureFormat_pixelAspectInformation_pixelAspectCode* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 14, 0 };
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      stat = decodeConsUInt8 (pctxt, &pvalue->elem[xx1], 1U, 14U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->elem[xx1]);
      rtInvokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CustomPictureFormat_pixelAspectInformation_extendedPAR_e  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CustomPictureFormat_pixelAspectInformation_extendedPAR_element (OOCTXT* pctxt, H245CustomPictureFormat_pixelAspectInformation_extendedPAR_element* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode width */

   rtInvokeStartElement (pctxt, "width", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->width, 1U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->width);

   rtInvokeEndElement (pctxt, "width", -1);

   /* decode height */

   rtInvokeStartElement (pctxt, "height", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->height, 1U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->height);

   rtInvokeEndElement (pctxt, "height", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CustomPictureFormat_pixelAspectInformation_extendedPAR    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CustomPictureFormat_pixelAspectInformation_extendedPAR (OOCTXT* pctxt, H245CustomPictureFormat_pixelAspectInformation_extendedPAR* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   H245CustomPictureFormat_pixelAspectInformation_extendedPAR_element* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245CustomPictureFormat_pixelAspectInformation_extendedPAR_element);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245CustomPictureFormat_pixelAspectInformation_extendedPAR_element (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CustomPictureFormat_pixelAspectInformation                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CustomPictureFormat_pixelAspectInformation (OOCTXT* pctxt, H245CustomPictureFormat_pixelAspectInformation* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* anyPixelAspectRatio */
         case 0:
            rtInvokeStartElement (pctxt, "anyPixelAspectRatio", -1);

            stat = DECODEBIT (pctxt, &pvalue->u.anyPixelAspectRatio);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeBoolValue (pctxt, pvalue->u.anyPixelAspectRatio);

            rtInvokeEndElement (pctxt, "anyPixelAspectRatio", -1);

            break;

         /* pixelAspectCode */
         case 1:
            rtInvokeStartElement (pctxt, "pixelAspectCode", -1);

            pvalue->u.pixelAspectCode = ALLOC_ASN1ELEM (pctxt, H245CustomPictureFormat_pixelAspectInformation_pixelAspectCode);
            if (pvalue->u.pixelAspectCode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245CustomPictureFormat_pixelAspectInformation_pixelAspectCode (pctxt, pvalue->u.pixelAspectCode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "pixelAspectCode", -1);

            break;

         /* extendedPAR */
         case 2:
            rtInvokeStartElement (pctxt, "extendedPAR", -1);

            pvalue->u.extendedPAR = ALLOC_ASN1ELEM (pctxt, H245CustomPictureFormat_pixelAspectInformation_extendedPAR);
            if (pvalue->u.extendedPAR == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245CustomPictureFormat_pixelAspectInformation_extendedPAR (pctxt, pvalue->u.extendedPAR);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "extendedPAR", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CustomPictureFormat                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CustomPictureFormat (OOCTXT* pctxt, H245CustomPictureFormat* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode maxCustomPictureWidth */

   rtInvokeStartElement (pctxt, "maxCustomPictureWidth", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maxCustomPictureWidth, 1U, 2048U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maxCustomPictureWidth);

   rtInvokeEndElement (pctxt, "maxCustomPictureWidth", -1);

   /* decode maxCustomPictureHeight */

   rtInvokeStartElement (pctxt, "maxCustomPictureHeight", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maxCustomPictureHeight, 1U, 2048U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maxCustomPictureHeight);

   rtInvokeEndElement (pctxt, "maxCustomPictureHeight", -1);

   /* decode minCustomPictureWidth */

   rtInvokeStartElement (pctxt, "minCustomPictureWidth", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->minCustomPictureWidth, 1U, 2048U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->minCustomPictureWidth);

   rtInvokeEndElement (pctxt, "minCustomPictureWidth", -1);

   /* decode minCustomPictureHeight */

   rtInvokeStartElement (pctxt, "minCustomPictureHeight", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->minCustomPictureHeight, 1U, 2048U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->minCustomPictureHeight);

   rtInvokeEndElement (pctxt, "minCustomPictureHeight", -1);

   /* decode mPI */

   rtInvokeStartElement (pctxt, "mPI", -1);

   stat = asn1PD_H245CustomPictureFormat_mPI (pctxt, &pvalue->mPI);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "mPI", -1);

   /* decode pixelAspectInformation */

   rtInvokeStartElement (pctxt, "pixelAspectInformation", -1);

   stat = asn1PD_H245CustomPictureFormat_pixelAspectInformation (pctxt, &pvalue->pixelAspectInformation);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "pixelAspectInformation", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H263Options_customPictureFormat                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H263Options_customPictureFormat (OOCTXT* pctxt, H245H263Options_customPictureFormat* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 16, 0 };
   int stat = ASN_OK;
   H245CustomPictureFormat* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245CustomPictureFormat);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245CustomPictureFormat (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H263Version3Options                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H263Version3Options (OOCTXT* pctxt, H245H263Version3Options* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode dataPartitionedSlices */

   rtInvokeStartElement (pctxt, "dataPartitionedSlices", -1);

   stat = DECODEBIT (pctxt, &pvalue->dataPartitionedSlices);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->dataPartitionedSlices);

   rtInvokeEndElement (pctxt, "dataPartitionedSlices", -1);

   /* decode fixedPointIDCT0 */

   rtInvokeStartElement (pctxt, "fixedPointIDCT0", -1);

   stat = DECODEBIT (pctxt, &pvalue->fixedPointIDCT0);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->fixedPointIDCT0);

   rtInvokeEndElement (pctxt, "fixedPointIDCT0", -1);

   /* decode interlacedFields */

   rtInvokeStartElement (pctxt, "interlacedFields", -1);

   stat = DECODEBIT (pctxt, &pvalue->interlacedFields);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->interlacedFields);

   rtInvokeEndElement (pctxt, "interlacedFields", -1);

   /* decode currentPictureHeaderRepetition */

   rtInvokeStartElement (pctxt, "currentPictureHeaderRepetition", -1);

   stat = DECODEBIT (pctxt, &pvalue->currentPictureHeaderRepetition);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->currentPictureHeaderRepetition);

   rtInvokeEndElement (pctxt, "currentPictureHeaderRepetition", -1);

   /* decode previousPictureHeaderRepetition */

   rtInvokeStartElement (pctxt, "previousPictureHeaderRepetition", -1);

   stat = DECODEBIT (pctxt, &pvalue->previousPictureHeaderRepetition);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->previousPictureHeaderRepetition);

   rtInvokeEndElement (pctxt, "previousPictureHeaderRepetition", -1);

   /* decode nextPictureHeaderRepetition */

   rtInvokeStartElement (pctxt, "nextPictureHeaderRepetition", -1);

   stat = DECODEBIT (pctxt, &pvalue->nextPictureHeaderRepetition);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->nextPictureHeaderRepetition);

   rtInvokeEndElement (pctxt, "nextPictureHeaderRepetition", -1);

   /* decode pictureNumber */

   rtInvokeStartElement (pctxt, "pictureNumber", -1);

   stat = DECODEBIT (pctxt, &pvalue->pictureNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->pictureNumber);

   rtInvokeEndElement (pctxt, "pictureNumber", -1);

   /* decode spareReferencePictures */

   rtInvokeStartElement (pctxt, "spareReferencePictures", -1);

   stat = DECODEBIT (pctxt, &pvalue->spareReferencePictures);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->spareReferencePictures);

   rtInvokeEndElement (pctxt, "spareReferencePictures", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H263ModeComboFlags                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H263ModeComboFlags (OOCTXT* pctxt, H245H263ModeComboFlags* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   /* decode unrestrictedVector */

   rtInvokeStartElement (pctxt, "unrestrictedVector", -1);

   stat = DECODEBIT (pctxt, &pvalue->unrestrictedVector);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->unrestrictedVector);

   rtInvokeEndElement (pctxt, "unrestrictedVector", -1);

   /* decode arithmeticCoding */

   rtInvokeStartElement (pctxt, "arithmeticCoding", -1);

   stat = DECODEBIT (pctxt, &pvalue->arithmeticCoding);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->arithmeticCoding);

   rtInvokeEndElement (pctxt, "arithmeticCoding", -1);

   /* decode advancedPrediction */

   rtInvokeStartElement (pctxt, "advancedPrediction", -1);

   stat = DECODEBIT (pctxt, &pvalue->advancedPrediction);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->advancedPrediction);

   rtInvokeEndElement (pctxt, "advancedPrediction", -1);

   /* decode pbFrames */

   rtInvokeStartElement (pctxt, "pbFrames", -1);

   stat = DECODEBIT (pctxt, &pvalue->pbFrames);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->pbFrames);

   rtInvokeEndElement (pctxt, "pbFrames", -1);

   /* decode advancedIntraCodingMode */

   rtInvokeStartElement (pctxt, "advancedIntraCodingMode", -1);

   stat = DECODEBIT (pctxt, &pvalue->advancedIntraCodingMode);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->advancedIntraCodingMode);

   rtInvokeEndElement (pctxt, "advancedIntraCodingMode", -1);

   /* decode deblockingFilterMode */

   rtInvokeStartElement (pctxt, "deblockingFilterMode", -1);

   stat = DECODEBIT (pctxt, &pvalue->deblockingFilterMode);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->deblockingFilterMode);

   rtInvokeEndElement (pctxt, "deblockingFilterMode", -1);

   /* decode unlimitedMotionVectors */

   rtInvokeStartElement (pctxt, "unlimitedMotionVectors", -1);

   stat = DECODEBIT (pctxt, &pvalue->unlimitedMotionVectors);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->unlimitedMotionVectors);

   rtInvokeEndElement (pctxt, "unlimitedMotionVectors", -1);

   /* decode slicesInOrder_NonRect */

   rtInvokeStartElement (pctxt, "slicesInOrder_NonRect", -1);

   stat = DECODEBIT (pctxt, &pvalue->slicesInOrder_NonRect);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->slicesInOrder_NonRect);

   rtInvokeEndElement (pctxt, "slicesInOrder_NonRect", -1);

   /* decode slicesInOrder_Rect */

   rtInvokeStartElement (pctxt, "slicesInOrder_Rect", -1);

   stat = DECODEBIT (pctxt, &pvalue->slicesInOrder_Rect);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->slicesInOrder_Rect);

   rtInvokeEndElement (pctxt, "slicesInOrder_Rect", -1);

   /* decode slicesNoOrder_NonRect */

   rtInvokeStartElement (pctxt, "slicesNoOrder_NonRect", -1);

   stat = DECODEBIT (pctxt, &pvalue->slicesNoOrder_NonRect);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->slicesNoOrder_NonRect);

   rtInvokeEndElement (pctxt, "slicesNoOrder_NonRect", -1);

   /* decode slicesNoOrder_Rect */

   rtInvokeStartElement (pctxt, "slicesNoOrder_Rect", -1);

   stat = DECODEBIT (pctxt, &pvalue->slicesNoOrder_Rect);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->slicesNoOrder_Rect);

   rtInvokeEndElement (pctxt, "slicesNoOrder_Rect", -1);

   /* decode improvedPBFramesMode */

   rtInvokeStartElement (pctxt, "improvedPBFramesMode", -1);

   stat = DECODEBIT (pctxt, &pvalue->improvedPBFramesMode);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->improvedPBFramesMode);

   rtInvokeEndElement (pctxt, "improvedPBFramesMode", -1);

   /* decode referencePicSelect */

   rtInvokeStartElement (pctxt, "referencePicSelect", -1);

   stat = DECODEBIT (pctxt, &pvalue->referencePicSelect);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->referencePicSelect);

   rtInvokeEndElement (pctxt, "referencePicSelect", -1);

   /* decode dynamicPictureResizingByFour */

   rtInvokeStartElement (pctxt, "dynamicPictureResizingByFour", -1);

   stat = DECODEBIT (pctxt, &pvalue->dynamicPictureResizingByFour);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->dynamicPictureResizingByFour);

   rtInvokeEndElement (pctxt, "dynamicPictureResizingByFour", -1);

   /* decode dynamicPictureResizingSixteenthPel */

   rtInvokeStartElement (pctxt, "dynamicPictureResizingSixteenthPel", -1);

   stat = DECODEBIT (pctxt, &pvalue->dynamicPictureResizingSixteenthPel);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->dynamicPictureResizingSixteenthPel);

   rtInvokeEndElement (pctxt, "dynamicPictureResizingSixteenthPel", -1);

   /* decode dynamicWarpingHalfPel */

   rtInvokeStartElement (pctxt, "dynamicWarpingHalfPel", -1);

   stat = DECODEBIT (pctxt, &pvalue->dynamicWarpingHalfPel);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->dynamicWarpingHalfPel);

   rtInvokeEndElement (pctxt, "dynamicWarpingHalfPel", -1);

   /* decode dynamicWarpingSixteenthPel */

   rtInvokeStartElement (pctxt, "dynamicWarpingSixteenthPel", -1);

   stat = DECODEBIT (pctxt, &pvalue->dynamicWarpingSixteenthPel);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->dynamicWarpingSixteenthPel);

   rtInvokeEndElement (pctxt, "dynamicWarpingSixteenthPel", -1);

   /* decode reducedResolutionUpdate */

   rtInvokeStartElement (pctxt, "reducedResolutionUpdate", -1);

   stat = DECODEBIT (pctxt, &pvalue->reducedResolutionUpdate);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->reducedResolutionUpdate);

   rtInvokeEndElement (pctxt, "reducedResolutionUpdate", -1);

   /* decode independentSegmentDecoding */

   rtInvokeStartElement (pctxt, "independentSegmentDecoding", -1);

   stat = DECODEBIT (pctxt, &pvalue->independentSegmentDecoding);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->independentSegmentDecoding);

   rtInvokeEndElement (pctxt, "independentSegmentDecoding", -1);

   /* decode alternateInterVLCMode */

   rtInvokeStartElement (pctxt, "alternateInterVLCMode", -1);

   stat = DECODEBIT (pctxt, &pvalue->alternateInterVLCMode);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->alternateInterVLCMode);

   rtInvokeEndElement (pctxt, "alternateInterVLCMode", -1);

   /* decode modifiedQuantizationMode */

   rtInvokeStartElement (pctxt, "modifiedQuantizationMode", -1);

   stat = DECODEBIT (pctxt, &pvalue->modifiedQuantizationMode);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->modifiedQuantizationMode);

   rtInvokeEndElement (pctxt, "modifiedQuantizationMode", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 2 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.enhancedReferencePicSelectPresent = 1;

                     rtInvokeStartElement (pctxt, "enhancedReferencePicSelect", -1);

                     stat = DECODEBIT (pctxt, &pvalue->enhancedReferencePicSelect);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeBoolValue (pctxt, pvalue->enhancedReferencePicSelect);

                     rtInvokeEndElement (pctxt, "enhancedReferencePicSelect", -1);
                     break;

                  case 1:
                     pvalue->m.h263Version3OptionsPresent = 1;

                     rtInvokeStartElement (pctxt, "h263Version3Options", -1);

                     stat = asn1PD_H245H263Version3Options (pctxt, &pvalue->h263Version3Options);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "h263Version3Options", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 2) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H263VideoModeCombos_h263VideoCoupledModes                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H263VideoModeCombos_h263VideoCoupledModes (OOCTXT* pctxt, H245H263VideoModeCombos_h263VideoCoupledModes* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 16, 0 };
   int stat = ASN_OK;
   H245H263ModeComboFlags* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245H263ModeComboFlags);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245H263ModeComboFlags (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H263VideoModeCombos                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H263VideoModeCombos (OOCTXT* pctxt, H245H263VideoModeCombos* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode h263VideoUncoupledModes */

   rtInvokeStartElement (pctxt, "h263VideoUncoupledModes", -1);

   stat = asn1PD_H245H263ModeComboFlags (pctxt, &pvalue->h263VideoUncoupledModes);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "h263VideoUncoupledModes", -1);

   /* decode h263VideoCoupledModes */

   rtInvokeStartElement (pctxt, "h263VideoCoupledModes", -1);

   stat = asn1PD_H245H263VideoModeCombos_h263VideoCoupledModes (pctxt, &pvalue->h263VideoCoupledModes);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "h263VideoCoupledModes", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H263Options_modeCombos                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H263Options_modeCombos (OOCTXT* pctxt, H245H263Options_modeCombos* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 16, 0 };
   int stat = ASN_OK;
   H245H263VideoModeCombos* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245H263VideoModeCombos);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245H263VideoModeCombos (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H263Options                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H263Options (OOCTXT* pctxt, H245H263Options* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.transparencyParametersPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.refPictureSelectionPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.customPictureClockFrequencyPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.customPictureFormatPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.modeCombosPresent = optbit;

   /* decode advancedIntraCodingMode */

   rtInvokeStartElement (pctxt, "advancedIntraCodingMode", -1);

   stat = DECODEBIT (pctxt, &pvalue->advancedIntraCodingMode);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->advancedIntraCodingMode);

   rtInvokeEndElement (pctxt, "advancedIntraCodingMode", -1);

   /* decode deblockingFilterMode */

   rtInvokeStartElement (pctxt, "deblockingFilterMode", -1);

   stat = DECODEBIT (pctxt, &pvalue->deblockingFilterMode);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->deblockingFilterMode);

   rtInvokeEndElement (pctxt, "deblockingFilterMode", -1);

   /* decode improvedPBFramesMode */

   rtInvokeStartElement (pctxt, "improvedPBFramesMode", -1);

   stat = DECODEBIT (pctxt, &pvalue->improvedPBFramesMode);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->improvedPBFramesMode);

   rtInvokeEndElement (pctxt, "improvedPBFramesMode", -1);

   /* decode unlimitedMotionVectors */

   rtInvokeStartElement (pctxt, "unlimitedMotionVectors", -1);

   stat = DECODEBIT (pctxt, &pvalue->unlimitedMotionVectors);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->unlimitedMotionVectors);

   rtInvokeEndElement (pctxt, "unlimitedMotionVectors", -1);

   /* decode fullPictureFreeze */

   rtInvokeStartElement (pctxt, "fullPictureFreeze", -1);

   stat = DECODEBIT (pctxt, &pvalue->fullPictureFreeze);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->fullPictureFreeze);

   rtInvokeEndElement (pctxt, "fullPictureFreeze", -1);

   /* decode partialPictureFreezeAndRelease */

   rtInvokeStartElement (pctxt, "partialPictureFreezeAndRelease", -1);

   stat = DECODEBIT (pctxt, &pvalue->partialPictureFreezeAndRelease);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->partialPictureFreezeAndRelease);

   rtInvokeEndElement (pctxt, "partialPictureFreezeAndRelease", -1);

   /* decode resizingPartPicFreezeAndRelease */

   rtInvokeStartElement (pctxt, "resizingPartPicFreezeAndRelease", -1);

   stat = DECODEBIT (pctxt, &pvalue->resizingPartPicFreezeAndRelease);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->resizingPartPicFreezeAndRelease);

   rtInvokeEndElement (pctxt, "resizingPartPicFreezeAndRelease", -1);

   /* decode fullPictureSnapshot */

   rtInvokeStartElement (pctxt, "fullPictureSnapshot", -1);

   stat = DECODEBIT (pctxt, &pvalue->fullPictureSnapshot);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->fullPictureSnapshot);

   rtInvokeEndElement (pctxt, "fullPictureSnapshot", -1);

   /* decode partialPictureSnapshot */

   rtInvokeStartElement (pctxt, "partialPictureSnapshot", -1);

   stat = DECODEBIT (pctxt, &pvalue->partialPictureSnapshot);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->partialPictureSnapshot);

   rtInvokeEndElement (pctxt, "partialPictureSnapshot", -1);

   /* decode videoSegmentTagging */

   rtInvokeStartElement (pctxt, "videoSegmentTagging", -1);

   stat = DECODEBIT (pctxt, &pvalue->videoSegmentTagging);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->videoSegmentTagging);

   rtInvokeEndElement (pctxt, "videoSegmentTagging", -1);

   /* decode progressiveRefinement */

   rtInvokeStartElement (pctxt, "progressiveRefinement", -1);

   stat = DECODEBIT (pctxt, &pvalue->progressiveRefinement);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->progressiveRefinement);

   rtInvokeEndElement (pctxt, "progressiveRefinement", -1);

   /* decode dynamicPictureResizingByFour */

   rtInvokeStartElement (pctxt, "dynamicPictureResizingByFour", -1);

   stat = DECODEBIT (pctxt, &pvalue->dynamicPictureResizingByFour);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->dynamicPictureResizingByFour);

   rtInvokeEndElement (pctxt, "dynamicPictureResizingByFour", -1);

   /* decode dynamicPictureResizingSixteenthPel */

   rtInvokeStartElement (pctxt, "dynamicPictureResizingSixteenthPel", -1);

   stat = DECODEBIT (pctxt, &pvalue->dynamicPictureResizingSixteenthPel);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->dynamicPictureResizingSixteenthPel);

   rtInvokeEndElement (pctxt, "dynamicPictureResizingSixteenthPel", -1);

   /* decode dynamicWarpingHalfPel */

   rtInvokeStartElement (pctxt, "dynamicWarpingHalfPel", -1);

   stat = DECODEBIT (pctxt, &pvalue->dynamicWarpingHalfPel);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->dynamicWarpingHalfPel);

   rtInvokeEndElement (pctxt, "dynamicWarpingHalfPel", -1);

   /* decode dynamicWarpingSixteenthPel */

   rtInvokeStartElement (pctxt, "dynamicWarpingSixteenthPel", -1);

   stat = DECODEBIT (pctxt, &pvalue->dynamicWarpingSixteenthPel);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->dynamicWarpingSixteenthPel);

   rtInvokeEndElement (pctxt, "dynamicWarpingSixteenthPel", -1);

   /* decode independentSegmentDecoding */

   rtInvokeStartElement (pctxt, "independentSegmentDecoding", -1);

   stat = DECODEBIT (pctxt, &pvalue->independentSegmentDecoding);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->independentSegmentDecoding);

   rtInvokeEndElement (pctxt, "independentSegmentDecoding", -1);

   /* decode slicesInOrder_NonRect */

   rtInvokeStartElement (pctxt, "slicesInOrder_NonRect", -1);

   stat = DECODEBIT (pctxt, &pvalue->slicesInOrder_NonRect);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->slicesInOrder_NonRect);

   rtInvokeEndElement (pctxt, "slicesInOrder_NonRect", -1);

   /* decode slicesInOrder_Rect */

   rtInvokeStartElement (pctxt, "slicesInOrder_Rect", -1);

   stat = DECODEBIT (pctxt, &pvalue->slicesInOrder_Rect);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->slicesInOrder_Rect);

   rtInvokeEndElement (pctxt, "slicesInOrder_Rect", -1);

   /* decode slicesNoOrder_NonRect */

   rtInvokeStartElement (pctxt, "slicesNoOrder_NonRect", -1);

   stat = DECODEBIT (pctxt, &pvalue->slicesNoOrder_NonRect);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->slicesNoOrder_NonRect);

   rtInvokeEndElement (pctxt, "slicesNoOrder_NonRect", -1);

   /* decode slicesNoOrder_Rect */

   rtInvokeStartElement (pctxt, "slicesNoOrder_Rect", -1);

   stat = DECODEBIT (pctxt, &pvalue->slicesNoOrder_Rect);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->slicesNoOrder_Rect);

   rtInvokeEndElement (pctxt, "slicesNoOrder_Rect", -1);

   /* decode alternateInterVLCMode */

   rtInvokeStartElement (pctxt, "alternateInterVLCMode", -1);

   stat = DECODEBIT (pctxt, &pvalue->alternateInterVLCMode);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->alternateInterVLCMode);

   rtInvokeEndElement (pctxt, "alternateInterVLCMode", -1);

   /* decode modifiedQuantizationMode */

   rtInvokeStartElement (pctxt, "modifiedQuantizationMode", -1);

   stat = DECODEBIT (pctxt, &pvalue->modifiedQuantizationMode);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->modifiedQuantizationMode);

   rtInvokeEndElement (pctxt, "modifiedQuantizationMode", -1);

   /* decode reducedResolutionUpdate */

   rtInvokeStartElement (pctxt, "reducedResolutionUpdate", -1);

   stat = DECODEBIT (pctxt, &pvalue->reducedResolutionUpdate);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->reducedResolutionUpdate);

   rtInvokeEndElement (pctxt, "reducedResolutionUpdate", -1);

   /* decode transparencyParameters */

   if (pvalue->m.transparencyParametersPresent) {
      rtInvokeStartElement (pctxt, "transparencyParameters", -1);

      stat = asn1PD_H245TransparencyParameters (pctxt, &pvalue->transparencyParameters);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "transparencyParameters", -1);
   }

   /* decode separateVideoBackChannel */

   rtInvokeStartElement (pctxt, "separateVideoBackChannel", -1);

   stat = DECODEBIT (pctxt, &pvalue->separateVideoBackChannel);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->separateVideoBackChannel);

   rtInvokeEndElement (pctxt, "separateVideoBackChannel", -1);

   /* decode refPictureSelection */

   if (pvalue->m.refPictureSelectionPresent) {
      rtInvokeStartElement (pctxt, "refPictureSelection", -1);

      stat = asn1PD_H245RefPictureSelection (pctxt, &pvalue->refPictureSelection);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "refPictureSelection", -1);
   }

   /* decode customPictureClockFrequency */

   if (pvalue->m.customPictureClockFrequencyPresent) {
      rtInvokeStartElement (pctxt, "customPictureClockFrequency", -1);

      stat = asn1PD_H245H263Options_customPictureClockFrequency (pctxt, &pvalue->customPictureClockFrequency);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "customPictureClockFrequency", -1);
   }

   /* decode customPictureFormat */

   if (pvalue->m.customPictureFormatPresent) {
      rtInvokeStartElement (pctxt, "customPictureFormat", -1);

      stat = asn1PD_H245H263Options_customPictureFormat (pctxt, &pvalue->customPictureFormat);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "customPictureFormat", -1);
   }

   /* decode modeCombos */

   if (pvalue->m.modeCombosPresent) {
      rtInvokeStartElement (pctxt, "modeCombos", -1);

      stat = asn1PD_H245H263Options_modeCombos (pctxt, &pvalue->modeCombos);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "modeCombos", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 2 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.videoBadMBsCapPresent = 1;

                     rtInvokeStartElement (pctxt, "videoBadMBsCap", -1);

                     stat = DECODEBIT (pctxt, &pvalue->videoBadMBsCap);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeBoolValue (pctxt, pvalue->videoBadMBsCap);

                     rtInvokeEndElement (pctxt, "videoBadMBsCap", -1);
                     break;

                  case 1:
                     pvalue->m.h263Version3OptionsPresent = 1;

                     rtInvokeStartElement (pctxt, "h263Version3Options", -1);

                     stat = asn1PD_H245H263Version3Options (pctxt, &pvalue->h263Version3Options);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "h263Version3Options", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 2) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EnhancementOptions                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245EnhancementOptions (OOCTXT* pctxt, H245EnhancementOptions* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sqcifMPIPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.qcifMPIPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cifMPIPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cif4MPIPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cif16MPIPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.slowSqcifMPIPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.slowQcifMPIPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.slowCifMPIPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.slowCif4MPIPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.slowCif16MPIPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.h263OptionsPresent = optbit;

   /* decode sqcifMPI */

   if (pvalue->m.sqcifMPIPresent) {
      rtInvokeStartElement (pctxt, "sqcifMPI", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->sqcifMPI, 1U, 32U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->sqcifMPI);

      rtInvokeEndElement (pctxt, "sqcifMPI", -1);
   }

   /* decode qcifMPI */

   if (pvalue->m.qcifMPIPresent) {
      rtInvokeStartElement (pctxt, "qcifMPI", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->qcifMPI, 1U, 32U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->qcifMPI);

      rtInvokeEndElement (pctxt, "qcifMPI", -1);
   }

   /* decode cifMPI */

   if (pvalue->m.cifMPIPresent) {
      rtInvokeStartElement (pctxt, "cifMPI", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->cifMPI, 1U, 32U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->cifMPI);

      rtInvokeEndElement (pctxt, "cifMPI", -1);
   }

   /* decode cif4MPI */

   if (pvalue->m.cif4MPIPresent) {
      rtInvokeStartElement (pctxt, "cif4MPI", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->cif4MPI, 1U, 32U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->cif4MPI);

      rtInvokeEndElement (pctxt, "cif4MPI", -1);
   }

   /* decode cif16MPI */

   if (pvalue->m.cif16MPIPresent) {
      rtInvokeStartElement (pctxt, "cif16MPI", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->cif16MPI, 1U, 32U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->cif16MPI);

      rtInvokeEndElement (pctxt, "cif16MPI", -1);
   }

   /* decode maxBitRate */

   rtInvokeStartElement (pctxt, "maxBitRate", -1);

   stat = decodeConsUnsigned (pctxt, &pvalue->maxBitRate, 1U, 192400U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maxBitRate);

   rtInvokeEndElement (pctxt, "maxBitRate", -1);

   /* decode unrestrictedVector */

   rtInvokeStartElement (pctxt, "unrestrictedVector", -1);

   stat = DECODEBIT (pctxt, &pvalue->unrestrictedVector);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->unrestrictedVector);

   rtInvokeEndElement (pctxt, "unrestrictedVector", -1);

   /* decode arithmeticCoding */

   rtInvokeStartElement (pctxt, "arithmeticCoding", -1);

   stat = DECODEBIT (pctxt, &pvalue->arithmeticCoding);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->arithmeticCoding);

   rtInvokeEndElement (pctxt, "arithmeticCoding", -1);

   /* decode temporalSpatialTradeOffCapability */

   rtInvokeStartElement (pctxt, "temporalSpatialTradeOffCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->temporalSpatialTradeOffCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->temporalSpatialTradeOffCapability);

   rtInvokeEndElement (pctxt, "temporalSpatialTradeOffCapability", -1);

   /* decode slowSqcifMPI */

   if (pvalue->m.slowSqcifMPIPresent) {
      rtInvokeStartElement (pctxt, "slowSqcifMPI", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->slowSqcifMPI, 1U, 3600U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->slowSqcifMPI);

      rtInvokeEndElement (pctxt, "slowSqcifMPI", -1);
   }

   /* decode slowQcifMPI */

   if (pvalue->m.slowQcifMPIPresent) {
      rtInvokeStartElement (pctxt, "slowQcifMPI", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->slowQcifMPI, 1U, 3600U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->slowQcifMPI);

      rtInvokeEndElement (pctxt, "slowQcifMPI", -1);
   }

   /* decode slowCifMPI */

   if (pvalue->m.slowCifMPIPresent) {
      rtInvokeStartElement (pctxt, "slowCifMPI", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->slowCifMPI, 1U, 3600U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->slowCifMPI);

      rtInvokeEndElement (pctxt, "slowCifMPI", -1);
   }

   /* decode slowCif4MPI */

   if (pvalue->m.slowCif4MPIPresent) {
      rtInvokeStartElement (pctxt, "slowCif4MPI", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->slowCif4MPI, 1U, 3600U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->slowCif4MPI);

      rtInvokeEndElement (pctxt, "slowCif4MPI", -1);
   }

   /* decode slowCif16MPI */

   if (pvalue->m.slowCif16MPIPresent) {
      rtInvokeStartElement (pctxt, "slowCif16MPI", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->slowCif16MPI, 1U, 3600U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->slowCif16MPI);

      rtInvokeEndElement (pctxt, "slowCif16MPI", -1);
   }

   /* decode errorCompensation */

   rtInvokeStartElement (pctxt, "errorCompensation", -1);

   stat = DECODEBIT (pctxt, &pvalue->errorCompensation);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->errorCompensation);

   rtInvokeEndElement (pctxt, "errorCompensation", -1);

   /* decode h263Options */

   if (pvalue->m.h263OptionsPresent) {
      rtInvokeStartElement (pctxt, "h263Options", -1);

      stat = asn1PD_H245H263Options (pctxt, &pvalue->h263Options);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "h263Options", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EnhancementLayerInfo_snrEnhancement                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245EnhancementLayerInfo_snrEnhancement (OOCTXT* pctxt, H245EnhancementLayerInfo_snrEnhancement* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 14, 0 };
   int stat = ASN_OK;
   H245EnhancementOptions* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245EnhancementOptions);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245EnhancementOptions (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EnhancementLayerInfo_spatialEnhancement                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245EnhancementLayerInfo_spatialEnhancement (OOCTXT* pctxt, H245EnhancementLayerInfo_spatialEnhancement* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 14, 0 };
   int stat = ASN_OK;
   H245EnhancementOptions* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245EnhancementOptions);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245EnhancementOptions (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BEnhancementParameters                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245BEnhancementParameters (OOCTXT* pctxt, H245BEnhancementParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode enhancementOptions */

   rtInvokeStartElement (pctxt, "enhancementOptions", -1);

   stat = asn1PD_H245EnhancementOptions (pctxt, &pvalue->enhancementOptions);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "enhancementOptions", -1);

   /* decode numberOfBPictures */

   rtInvokeStartElement (pctxt, "numberOfBPictures", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->numberOfBPictures, 1U, 64U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->numberOfBPictures);

   rtInvokeEndElement (pctxt, "numberOfBPictures", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EnhancementLayerInfo_bPictureEnhancement                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245EnhancementLayerInfo_bPictureEnhancement (OOCTXT* pctxt, H245EnhancementLayerInfo_bPictureEnhancement* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 14, 0 };
   int stat = ASN_OK;
   H245BEnhancementParameters* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245BEnhancementParameters);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245BEnhancementParameters (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EnhancementLayerInfo                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245EnhancementLayerInfo (OOCTXT* pctxt, H245EnhancementLayerInfo* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.snrEnhancementPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.spatialEnhancementPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.bPictureEnhancementPresent = optbit;

   /* decode baseBitRateConstrained */

   rtInvokeStartElement (pctxt, "baseBitRateConstrained", -1);

   stat = DECODEBIT (pctxt, &pvalue->baseBitRateConstrained);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->baseBitRateConstrained);

   rtInvokeEndElement (pctxt, "baseBitRateConstrained", -1);

   /* decode snrEnhancement */

   if (pvalue->m.snrEnhancementPresent) {
      rtInvokeStartElement (pctxt, "snrEnhancement", -1);

      stat = asn1PD_H245EnhancementLayerInfo_snrEnhancement (pctxt, &pvalue->snrEnhancement);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "snrEnhancement", -1);
   }

   /* decode spatialEnhancement */

   if (pvalue->m.spatialEnhancementPresent) {
      rtInvokeStartElement (pctxt, "spatialEnhancement", -1);

      stat = asn1PD_H245EnhancementLayerInfo_spatialEnhancement (pctxt, &pvalue->spatialEnhancement);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "spatialEnhancement", -1);
   }

   /* decode bPictureEnhancement */

   if (pvalue->m.bPictureEnhancementPresent) {
      rtInvokeStartElement (pctxt, "bPictureEnhancement", -1);

      stat = asn1PD_H245EnhancementLayerInfo_bPictureEnhancement (pctxt, &pvalue->bPictureEnhancement);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "bPictureEnhancement", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H263VideoCapability                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H263VideoCapability (OOCTXT* pctxt, H245H263VideoCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sqcifMPIPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.qcifMPIPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cifMPIPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cif4MPIPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cif16MPIPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hrd_BPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.bppMaxKbPresent = optbit;

   /* decode sqcifMPI */

   if (pvalue->m.sqcifMPIPresent) {
      rtInvokeStartElement (pctxt, "sqcifMPI", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->sqcifMPI, 1U, 32U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->sqcifMPI);

      rtInvokeEndElement (pctxt, "sqcifMPI", -1);
   }

   /* decode qcifMPI */

   if (pvalue->m.qcifMPIPresent) {
      rtInvokeStartElement (pctxt, "qcifMPI", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->qcifMPI, 1U, 32U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->qcifMPI);

      rtInvokeEndElement (pctxt, "qcifMPI", -1);
   }

   /* decode cifMPI */

   if (pvalue->m.cifMPIPresent) {
      rtInvokeStartElement (pctxt, "cifMPI", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->cifMPI, 1U, 32U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->cifMPI);

      rtInvokeEndElement (pctxt, "cifMPI", -1);
   }

   /* decode cif4MPI */

   if (pvalue->m.cif4MPIPresent) {
      rtInvokeStartElement (pctxt, "cif4MPI", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->cif4MPI, 1U, 32U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->cif4MPI);

      rtInvokeEndElement (pctxt, "cif4MPI", -1);
   }

   /* decode cif16MPI */

   if (pvalue->m.cif16MPIPresent) {
      rtInvokeStartElement (pctxt, "cif16MPI", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->cif16MPI, 1U, 32U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->cif16MPI);

      rtInvokeEndElement (pctxt, "cif16MPI", -1);
   }

   /* decode maxBitRate */

   rtInvokeStartElement (pctxt, "maxBitRate", -1);

   stat = decodeConsUnsigned (pctxt, &pvalue->maxBitRate, 1U, 192400U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maxBitRate);

   rtInvokeEndElement (pctxt, "maxBitRate", -1);

   /* decode unrestrictedVector */

   rtInvokeStartElement (pctxt, "unrestrictedVector", -1);

   stat = DECODEBIT (pctxt, &pvalue->unrestrictedVector);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->unrestrictedVector);

   rtInvokeEndElement (pctxt, "unrestrictedVector", -1);

   /* decode arithmeticCoding */

   rtInvokeStartElement (pctxt, "arithmeticCoding", -1);

   stat = DECODEBIT (pctxt, &pvalue->arithmeticCoding);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->arithmeticCoding);

   rtInvokeEndElement (pctxt, "arithmeticCoding", -1);

   /* decode advancedPrediction */

   rtInvokeStartElement (pctxt, "advancedPrediction", -1);

   stat = DECODEBIT (pctxt, &pvalue->advancedPrediction);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->advancedPrediction);

   rtInvokeEndElement (pctxt, "advancedPrediction", -1);

   /* decode pbFrames */

   rtInvokeStartElement (pctxt, "pbFrames", -1);

   stat = DECODEBIT (pctxt, &pvalue->pbFrames);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->pbFrames);

   rtInvokeEndElement (pctxt, "pbFrames", -1);

   /* decode temporalSpatialTradeOffCapability */

   rtInvokeStartElement (pctxt, "temporalSpatialTradeOffCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->temporalSpatialTradeOffCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->temporalSpatialTradeOffCapability);

   rtInvokeEndElement (pctxt, "temporalSpatialTradeOffCapability", -1);

   /* decode hrd_B */

   if (pvalue->m.hrd_BPresent) {
      rtInvokeStartElement (pctxt, "hrd_B", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->hrd_B, 0U, 524287U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->hrd_B);

      rtInvokeEndElement (pctxt, "hrd_B", -1);
   }

   /* decode bppMaxKb */

   if (pvalue->m.bppMaxKbPresent) {
      rtInvokeStartElement (pctxt, "bppMaxKb", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->bppMaxKb, 0U, 65535U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->bppMaxKb);

      rtInvokeEndElement (pctxt, "bppMaxKb", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 8 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.slowSqcifMPIPresent = 1;

                     rtInvokeStartElement (pctxt, "slowSqcifMPI", -1);

                     stat = decodeConsUInt16 (pctxt, &pvalue->slowSqcifMPI, 1U, 3600U);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeUIntValue (pctxt, pvalue->slowSqcifMPI);

                     rtInvokeEndElement (pctxt, "slowSqcifMPI", -1);
                     break;

                  case 1:
                     pvalue->m.slowQcifMPIPresent = 1;

                     rtInvokeStartElement (pctxt, "slowQcifMPI", -1);

                     stat = decodeConsUInt16 (pctxt, &pvalue->slowQcifMPI, 1U, 3600U);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeUIntValue (pctxt, pvalue->slowQcifMPI);

                     rtInvokeEndElement (pctxt, "slowQcifMPI", -1);
                     break;

                  case 2:
                     pvalue->m.slowCifMPIPresent = 1;

                     rtInvokeStartElement (pctxt, "slowCifMPI", -1);

                     stat = decodeConsUInt16 (pctxt, &pvalue->slowCifMPI, 1U, 3600U);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeUIntValue (pctxt, pvalue->slowCifMPI);

                     rtInvokeEndElement (pctxt, "slowCifMPI", -1);
                     break;

                  case 3:
                     pvalue->m.slowCif4MPIPresent = 1;

                     rtInvokeStartElement (pctxt, "slowCif4MPI", -1);

                     stat = decodeConsUInt16 (pctxt, &pvalue->slowCif4MPI, 1U, 3600U);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeUIntValue (pctxt, pvalue->slowCif4MPI);

                     rtInvokeEndElement (pctxt, "slowCif4MPI", -1);
                     break;

                  case 4:
                     pvalue->m.slowCif16MPIPresent = 1;

                     rtInvokeStartElement (pctxt, "slowCif16MPI", -1);

                     stat = decodeConsUInt16 (pctxt, &pvalue->slowCif16MPI, 1U, 3600U);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeUIntValue (pctxt, pvalue->slowCif16MPI);

                     rtInvokeEndElement (pctxt, "slowCif16MPI", -1);
                     break;

                  case 5:
                     pvalue->m.errorCompensationPresent = 1;

                     rtInvokeStartElement (pctxt, "errorCompensation", -1);

                     stat = DECODEBIT (pctxt, &pvalue->errorCompensation);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeBoolValue (pctxt, pvalue->errorCompensation);

                     rtInvokeEndElement (pctxt, "errorCompensation", -1);
                     break;

                  case 6:
                     pvalue->m.enhancementLayerInfoPresent = 1;

                     rtInvokeStartElement (pctxt, "enhancementLayerInfo", -1);

                     stat = asn1PD_H245EnhancementLayerInfo (pctxt, &pvalue->enhancementLayerInfo);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "enhancementLayerInfo", -1);
                     break;

                  case 7:
                     pvalue->m.h263OptionsPresent = 1;

                     rtInvokeStartElement (pctxt, "h263Options", -1);

                     stat = asn1PD_H245H263Options (pctxt, &pvalue->h263Options);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "h263Options", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 8) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IS11172VideoCapability                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245IS11172VideoCapability (OOCTXT* pctxt, H245IS11172VideoCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.videoBitRatePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.vbvBufferSizePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.samplesPerLinePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.linesPerFramePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.pictureRatePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.luminanceSampleRatePresent = optbit;

   /* decode constrainedBitstream */

   rtInvokeStartElement (pctxt, "constrainedBitstream", -1);

   stat = DECODEBIT (pctxt, &pvalue->constrainedBitstream);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->constrainedBitstream);

   rtInvokeEndElement (pctxt, "constrainedBitstream", -1);

   /* decode videoBitRate */

   if (pvalue->m.videoBitRatePresent) {
      rtInvokeStartElement (pctxt, "videoBitRate", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->videoBitRate, 0U, 1073741823U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->videoBitRate);

      rtInvokeEndElement (pctxt, "videoBitRate", -1);
   }

   /* decode vbvBufferSize */

   if (pvalue->m.vbvBufferSizePresent) {
      rtInvokeStartElement (pctxt, "vbvBufferSize", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->vbvBufferSize, 0U, 262143U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->vbvBufferSize);

      rtInvokeEndElement (pctxt, "vbvBufferSize", -1);
   }

   /* decode samplesPerLine */

   if (pvalue->m.samplesPerLinePresent) {
      rtInvokeStartElement (pctxt, "samplesPerLine", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->samplesPerLine, 0U, 16383U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->samplesPerLine);

      rtInvokeEndElement (pctxt, "samplesPerLine", -1);
   }

   /* decode linesPerFrame */

   if (pvalue->m.linesPerFramePresent) {
      rtInvokeStartElement (pctxt, "linesPerFrame", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->linesPerFrame, 0U, 16383U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->linesPerFrame);

      rtInvokeEndElement (pctxt, "linesPerFrame", -1);
   }

   /* decode pictureRate */

   if (pvalue->m.pictureRatePresent) {
      rtInvokeStartElement (pctxt, "pictureRate", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->pictureRate, 0U, 15U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->pictureRate);

      rtInvokeEndElement (pctxt, "pictureRate", -1);
   }

   /* decode luminanceSampleRate */

   if (pvalue->m.luminanceSampleRatePresent) {
      rtInvokeStartElement (pctxt, "luminanceSampleRate", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->luminanceSampleRate, 0U, ASN1UINT_MAX);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->luminanceSampleRate);

      rtInvokeEndElement (pctxt, "luminanceSampleRate", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 1 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.videoBadMBsCapPresent = 1;

                     rtInvokeStartElement (pctxt, "videoBadMBsCap", -1);

                     stat = DECODEBIT (pctxt, &pvalue->videoBadMBsCap);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeBoolValue (pctxt, pvalue->videoBadMBsCap);

                     rtInvokeEndElement (pctxt, "videoBadMBsCap", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 1) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VideoCapability                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245VideoCapability (OOCTXT* pctxt, H245VideoCapability* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 4);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* h261VideoCapability */
         case 1:
            rtInvokeStartElement (pctxt, "h261VideoCapability", -1);

            pvalue->u.h261VideoCapability = ALLOC_ASN1ELEM (pctxt, H245H261VideoCapability);
            if (pvalue->u.h261VideoCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H261VideoCapability (pctxt, pvalue->u.h261VideoCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h261VideoCapability", -1);

            break;

         /* h262VideoCapability */
         case 2:
            rtInvokeStartElement (pctxt, "h262VideoCapability", -1);

            pvalue->u.h262VideoCapability = ALLOC_ASN1ELEM (pctxt, H245H262VideoCapability);
            if (pvalue->u.h262VideoCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H262VideoCapability (pctxt, pvalue->u.h262VideoCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h262VideoCapability", -1);

            break;

         /* h263VideoCapability */
         case 3:
            rtInvokeStartElement (pctxt, "h263VideoCapability", -1);

            pvalue->u.h263VideoCapability = ALLOC_ASN1ELEM (pctxt, H245H263VideoCapability);
            if (pvalue->u.h263VideoCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H263VideoCapability (pctxt, pvalue->u.h263VideoCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h263VideoCapability", -1);

            break;

         /* is11172VideoCapability */
         case 4:
            rtInvokeStartElement (pctxt, "is11172VideoCapability", -1);

            pvalue->u.is11172VideoCapability = ALLOC_ASN1ELEM (pctxt, H245IS11172VideoCapability);
            if (pvalue->u.is11172VideoCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245IS11172VideoCapability (pctxt, pvalue->u.is11172VideoCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "is11172VideoCapability", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 6;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* genericVideoCapability */
         case 6:
            rtInvokeStartElement (pctxt, "genericVideoCapability", -1);

            pvalue->u.genericVideoCapability = ALLOC_ASN1ELEM (pctxt, H245GenericCapability);
            if (pvalue->u.genericVideoCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245GenericCapability (pctxt, pvalue->u.genericVideoCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "genericVideoCapability", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AudioCapability_g7231                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245AudioCapability_g7231 (OOCTXT* pctxt, H245AudioCapability_g7231* pvalue)
{
   int stat = ASN_OK;

   /* decode maxAl_sduAudioFrames */

   rtInvokeStartElement (pctxt, "maxAl_sduAudioFrames", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maxAl_sduAudioFrames, 1U, 256U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maxAl_sduAudioFrames);

   rtInvokeEndElement (pctxt, "maxAl_sduAudioFrames", -1);

   /* decode silenceSuppression */

   rtInvokeStartElement (pctxt, "silenceSuppression", -1);

   stat = DECODEBIT (pctxt, &pvalue->silenceSuppression);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->silenceSuppression);

   rtInvokeEndElement (pctxt, "silenceSuppression", -1);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IS11172AudioCapability                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245IS11172AudioCapability (OOCTXT* pctxt, H245IS11172AudioCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode audioLayer1 */

   rtInvokeStartElement (pctxt, "audioLayer1", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioLayer1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->audioLayer1);

   rtInvokeEndElement (pctxt, "audioLayer1", -1);

   /* decode audioLayer2 */

   rtInvokeStartElement (pctxt, "audioLayer2", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioLayer2);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->audioLayer2);

   rtInvokeEndElement (pctxt, "audioLayer2", -1);

   /* decode audioLayer3 */

   rtInvokeStartElement (pctxt, "audioLayer3", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioLayer3);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->audioLayer3);

   rtInvokeEndElement (pctxt, "audioLayer3", -1);

   /* decode audioSampling32k */

   rtInvokeStartElement (pctxt, "audioSampling32k", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioSampling32k);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->audioSampling32k);

   rtInvokeEndElement (pctxt, "audioSampling32k", -1);

   /* decode audioSampling44k1 */

   rtInvokeStartElement (pctxt, "audioSampling44k1", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioSampling44k1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->audioSampling44k1);

   rtInvokeEndElement (pctxt, "audioSampling44k1", -1);

   /* decode audioSampling48k */

   rtInvokeStartElement (pctxt, "audioSampling48k", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioSampling48k);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->audioSampling48k);

   rtInvokeEndElement (pctxt, "audioSampling48k", -1);

   /* decode singleChannel */

   rtInvokeStartElement (pctxt, "singleChannel", -1);

   stat = DECODEBIT (pctxt, &pvalue->singleChannel);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->singleChannel);

   rtInvokeEndElement (pctxt, "singleChannel", -1);

   /* decode twoChannels */

   rtInvokeStartElement (pctxt, "twoChannels", -1);

   stat = DECODEBIT (pctxt, &pvalue->twoChannels);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->twoChannels);

   rtInvokeEndElement (pctxt, "twoChannels", -1);

   /* decode bitRate */

   rtInvokeStartElement (pctxt, "bitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->bitRate, 1U, 448U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->bitRate);

   rtInvokeEndElement (pctxt, "bitRate", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IS13818AudioCapability                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245IS13818AudioCapability (OOCTXT* pctxt, H245IS13818AudioCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode audioLayer1 */

   rtInvokeStartElement (pctxt, "audioLayer1", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioLayer1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->audioLayer1);

   rtInvokeEndElement (pctxt, "audioLayer1", -1);

   /* decode audioLayer2 */

   rtInvokeStartElement (pctxt, "audioLayer2", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioLayer2);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->audioLayer2);

   rtInvokeEndElement (pctxt, "audioLayer2", -1);

   /* decode audioLayer3 */

   rtInvokeStartElement (pctxt, "audioLayer3", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioLayer3);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->audioLayer3);

   rtInvokeEndElement (pctxt, "audioLayer3", -1);

   /* decode audioSampling16k */

   rtInvokeStartElement (pctxt, "audioSampling16k", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioSampling16k);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->audioSampling16k);

   rtInvokeEndElement (pctxt, "audioSampling16k", -1);

   /* decode audioSampling22k05 */

   rtInvokeStartElement (pctxt, "audioSampling22k05", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioSampling22k05);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->audioSampling22k05);

   rtInvokeEndElement (pctxt, "audioSampling22k05", -1);

   /* decode audioSampling24k */

   rtInvokeStartElement (pctxt, "audioSampling24k", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioSampling24k);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->audioSampling24k);

   rtInvokeEndElement (pctxt, "audioSampling24k", -1);

   /* decode audioSampling32k */

   rtInvokeStartElement (pctxt, "audioSampling32k", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioSampling32k);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->audioSampling32k);

   rtInvokeEndElement (pctxt, "audioSampling32k", -1);

   /* decode audioSampling44k1 */

   rtInvokeStartElement (pctxt, "audioSampling44k1", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioSampling44k1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->audioSampling44k1);

   rtInvokeEndElement (pctxt, "audioSampling44k1", -1);

   /* decode audioSampling48k */

   rtInvokeStartElement (pctxt, "audioSampling48k", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioSampling48k);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->audioSampling48k);

   rtInvokeEndElement (pctxt, "audioSampling48k", -1);

   /* decode singleChannel */

   rtInvokeStartElement (pctxt, "singleChannel", -1);

   stat = DECODEBIT (pctxt, &pvalue->singleChannel);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->singleChannel);

   rtInvokeEndElement (pctxt, "singleChannel", -1);

   /* decode twoChannels */

   rtInvokeStartElement (pctxt, "twoChannels", -1);

   stat = DECODEBIT (pctxt, &pvalue->twoChannels);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->twoChannels);

   rtInvokeEndElement (pctxt, "twoChannels", -1);

   /* decode threeChannels2_1 */

   rtInvokeStartElement (pctxt, "threeChannels2_1", -1);

   stat = DECODEBIT (pctxt, &pvalue->threeChannels2_1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->threeChannels2_1);

   rtInvokeEndElement (pctxt, "threeChannels2_1", -1);

   /* decode threeChannels3_0 */

   rtInvokeStartElement (pctxt, "threeChannels3_0", -1);

   stat = DECODEBIT (pctxt, &pvalue->threeChannels3_0);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->threeChannels3_0);

   rtInvokeEndElement (pctxt, "threeChannels3_0", -1);

   /* decode fourChannels2_0_2_0 */

   rtInvokeStartElement (pctxt, "fourChannels2_0_2_0", -1);

   stat = DECODEBIT (pctxt, &pvalue->fourChannels2_0_2_0);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->fourChannels2_0_2_0);

   rtInvokeEndElement (pctxt, "fourChannels2_0_2_0", -1);

   /* decode fourChannels2_2 */

   rtInvokeStartElement (pctxt, "fourChannels2_2", -1);

   stat = DECODEBIT (pctxt, &pvalue->fourChannels2_2);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->fourChannels2_2);

   rtInvokeEndElement (pctxt, "fourChannels2_2", -1);

   /* decode fourChannels3_1 */

   rtInvokeStartElement (pctxt, "fourChannels3_1", -1);

   stat = DECODEBIT (pctxt, &pvalue->fourChannels3_1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->fourChannels3_1);

   rtInvokeEndElement (pctxt, "fourChannels3_1", -1);

   /* decode fiveChannels3_0_2_0 */

   rtInvokeStartElement (pctxt, "fiveChannels3_0_2_0", -1);

   stat = DECODEBIT (pctxt, &pvalue->fiveChannels3_0_2_0);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->fiveChannels3_0_2_0);

   rtInvokeEndElement (pctxt, "fiveChannels3_0_2_0", -1);

   /* decode fiveChannels3_2 */

   rtInvokeStartElement (pctxt, "fiveChannels3_2", -1);

   stat = DECODEBIT (pctxt, &pvalue->fiveChannels3_2);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->fiveChannels3_2);

   rtInvokeEndElement (pctxt, "fiveChannels3_2", -1);

   /* decode lowFrequencyEnhancement */

   rtInvokeStartElement (pctxt, "lowFrequencyEnhancement", -1);

   stat = DECODEBIT (pctxt, &pvalue->lowFrequencyEnhancement);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->lowFrequencyEnhancement);

   rtInvokeEndElement (pctxt, "lowFrequencyEnhancement", -1);

   /* decode multilingual */

   rtInvokeStartElement (pctxt, "multilingual", -1);

   stat = DECODEBIT (pctxt, &pvalue->multilingual);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->multilingual);

   rtInvokeEndElement (pctxt, "multilingual", -1);

   /* decode bitRate */

   rtInvokeStartElement (pctxt, "bitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->bitRate, 1U, 1130U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->bitRate);

   rtInvokeEndElement (pctxt, "bitRate", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  G7231AnnexCCapability_g723AnnexCAudioMode                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245G7231AnnexCCapability_g723AnnexCAudioMode (OOCTXT* pctxt, H245G7231AnnexCCapability_g723AnnexCAudioMode* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode highRateMode0 */

   rtInvokeStartElement (pctxt, "highRateMode0", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->highRateMode0, 27U, 78U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->highRateMode0);

   rtInvokeEndElement (pctxt, "highRateMode0", -1);

   /* decode highRateMode1 */

   rtInvokeStartElement (pctxt, "highRateMode1", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->highRateMode1, 27U, 78U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->highRateMode1);

   rtInvokeEndElement (pctxt, "highRateMode1", -1);

   /* decode lowRateMode0 */

   rtInvokeStartElement (pctxt, "lowRateMode0", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->lowRateMode0, 23U, 66U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->lowRateMode0);

   rtInvokeEndElement (pctxt, "lowRateMode0", -1);

   /* decode lowRateMode1 */

   rtInvokeStartElement (pctxt, "lowRateMode1", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->lowRateMode1, 23U, 66U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->lowRateMode1);

   rtInvokeEndElement (pctxt, "lowRateMode1", -1);

   /* decode sidMode0 */

   rtInvokeStartElement (pctxt, "sidMode0", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->sidMode0, 6U, 17U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->sidMode0);

   rtInvokeEndElement (pctxt, "sidMode0", -1);

   /* decode sidMode1 */

   rtInvokeStartElement (pctxt, "sidMode1", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->sidMode1, 6U, 17U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->sidMode1);

   rtInvokeEndElement (pctxt, "sidMode1", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  G7231AnnexCCapability                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245G7231AnnexCCapability (OOCTXT* pctxt, H245G7231AnnexCCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.g723AnnexCAudioModePresent = optbit;

   /* decode maxAl_sduAudioFrames */

   rtInvokeStartElement (pctxt, "maxAl_sduAudioFrames", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maxAl_sduAudioFrames, 1U, 256U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maxAl_sduAudioFrames);

   rtInvokeEndElement (pctxt, "maxAl_sduAudioFrames", -1);

   /* decode silenceSuppression */

   rtInvokeStartElement (pctxt, "silenceSuppression", -1);

   stat = DECODEBIT (pctxt, &pvalue->silenceSuppression);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->silenceSuppression);

   rtInvokeEndElement (pctxt, "silenceSuppression", -1);

   /* decode g723AnnexCAudioMode */

   if (pvalue->m.g723AnnexCAudioModePresent) {
      rtInvokeStartElement (pctxt, "g723AnnexCAudioMode", -1);

      stat = asn1PD_H245G7231AnnexCCapability_g723AnnexCAudioMode (pctxt, &pvalue->g723AnnexCAudioMode);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "g723AnnexCAudioMode", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GSMAudioCapability                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245GSMAudioCapability (OOCTXT* pctxt, H245GSMAudioCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode audioUnitSize */

   rtInvokeStartElement (pctxt, "audioUnitSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->audioUnitSize, 1U, 256U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->audioUnitSize);

   rtInvokeEndElement (pctxt, "audioUnitSize", -1);

   /* decode comfortNoise */

   rtInvokeStartElement (pctxt, "comfortNoise", -1);

   stat = DECODEBIT (pctxt, &pvalue->comfortNoise);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->comfortNoise);

   rtInvokeEndElement (pctxt, "comfortNoise", -1);

   /* decode scrambled */

   rtInvokeStartElement (pctxt, "scrambled", -1);

   stat = DECODEBIT (pctxt, &pvalue->scrambled);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->scrambled);

   rtInvokeEndElement (pctxt, "scrambled", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  G729Extensions                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245G729Extensions (OOCTXT* pctxt, H245G729Extensions* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.audioUnitPresent = optbit;

   /* decode audioUnit */

   if (pvalue->m.audioUnitPresent) {
      rtInvokeStartElement (pctxt, "audioUnit", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->audioUnit, 1U, 256U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->audioUnit);

      rtInvokeEndElement (pctxt, "audioUnit", -1);
   }

   /* decode annexA */

   rtInvokeStartElement (pctxt, "annexA", -1);

   stat = DECODEBIT (pctxt, &pvalue->annexA);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->annexA);

   rtInvokeEndElement (pctxt, "annexA", -1);

   /* decode annexB */

   rtInvokeStartElement (pctxt, "annexB", -1);

   stat = DECODEBIT (pctxt, &pvalue->annexB);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->annexB);

   rtInvokeEndElement (pctxt, "annexB", -1);

   /* decode annexD */

   rtInvokeStartElement (pctxt, "annexD", -1);

   stat = DECODEBIT (pctxt, &pvalue->annexD);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->annexD);

   rtInvokeEndElement (pctxt, "annexD", -1);

   /* decode annexE */

   rtInvokeStartElement (pctxt, "annexE", -1);

   stat = DECODEBIT (pctxt, &pvalue->annexE);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->annexE);

   rtInvokeEndElement (pctxt, "annexE", -1);

   /* decode annexF */

   rtInvokeStartElement (pctxt, "annexF", -1);

   stat = DECODEBIT (pctxt, &pvalue->annexF);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->annexF);

   rtInvokeEndElement (pctxt, "annexF", -1);

   /* decode annexG */

   rtInvokeStartElement (pctxt, "annexG", -1);

   stat = DECODEBIT (pctxt, &pvalue->annexG);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->annexG);

   rtInvokeEndElement (pctxt, "annexG", -1);

   /* decode annexH */

   rtInvokeStartElement (pctxt, "annexH", -1);

   stat = DECODEBIT (pctxt, &pvalue->annexH);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->annexH);

   rtInvokeEndElement (pctxt, "annexH", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VBDCapability                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245VBDCapability (OOCTXT* pctxt, H245VBDCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode type */

   rtInvokeStartElement (pctxt, "type", -1);

   pvalue->type = ALLOC_ASN1ELEM (pctxt, H245AudioCapability);
   if (pvalue->type == NULL)
      return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

   stat = asn1PD_H245AudioCapability (pctxt, (H245AudioCapability*)pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "type", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NoPTAudioTelephonyEventCapability                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NoPTAudioTelephonyEventCapability (OOCTXT* pctxt, H245NoPTAudioTelephonyEventCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode audioTelephoneEvent */

   rtInvokeStartElement (pctxt, "audioTelephoneEvent", -1);

   stat = decodeVarWidthCharString (pctxt, &pvalue->audioTelephoneEvent);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeCharStrValue (pctxt, pvalue->audioTelephoneEvent);

   rtInvokeEndElement (pctxt, "audioTelephoneEvent", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NoPTAudioToneCapability                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NoPTAudioToneCapability (OOCTXT* pctxt, H245NoPTAudioToneCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AudioCapability                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245AudioCapability (OOCTXT* pctxt, H245AudioCapability* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 13);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* g711Alaw64k */
         case 1:
            rtInvokeStartElement (pctxt, "g711Alaw64k", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g711Alaw64k, 1U, 256U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.g711Alaw64k);

            rtInvokeEndElement (pctxt, "g711Alaw64k", -1);

            break;

         /* g711Alaw56k */
         case 2:
            rtInvokeStartElement (pctxt, "g711Alaw56k", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g711Alaw56k, 1U, 256U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.g711Alaw56k);

            rtInvokeEndElement (pctxt, "g711Alaw56k", -1);

            break;

         /* g711Ulaw64k */
         case 3:
            rtInvokeStartElement (pctxt, "g711Ulaw64k", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g711Ulaw64k, 1U, 256U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.g711Ulaw64k);

            rtInvokeEndElement (pctxt, "g711Ulaw64k", -1);

            break;

         /* g711Ulaw56k */
         case 4:
            rtInvokeStartElement (pctxt, "g711Ulaw56k", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g711Ulaw56k, 1U, 256U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.g711Ulaw56k);

            rtInvokeEndElement (pctxt, "g711Ulaw56k", -1);

            break;

         /* g722_64k */
         case 5:
            rtInvokeStartElement (pctxt, "g722_64k", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g722_64k, 1U, 256U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.g722_64k);

            rtInvokeEndElement (pctxt, "g722_64k", -1);

            break;

         /* g722_56k */
         case 6:
            rtInvokeStartElement (pctxt, "g722_56k", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g722_56k, 1U, 256U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.g722_56k);

            rtInvokeEndElement (pctxt, "g722_56k", -1);

            break;

         /* g722_48k */
         case 7:
            rtInvokeStartElement (pctxt, "g722_48k", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g722_48k, 1U, 256U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.g722_48k);

            rtInvokeEndElement (pctxt, "g722_48k", -1);

            break;

         /* g7231 */
         case 8:
            rtInvokeStartElement (pctxt, "g7231", -1);

            pvalue->u.g7231 = ALLOC_ASN1ELEM (pctxt, H245AudioCapability_g7231);
            if (pvalue->u.g7231 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245AudioCapability_g7231 (pctxt, pvalue->u.g7231);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "g7231", -1);

            break;

         /* g728 */
         case 9:
            rtInvokeStartElement (pctxt, "g728", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g728, 1U, 256U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.g728);

            rtInvokeEndElement (pctxt, "g728", -1);

            break;

         /* g729 */
         case 10:
            rtInvokeStartElement (pctxt, "g729", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g729, 1U, 256U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.g729);

            rtInvokeEndElement (pctxt, "g729", -1);

            break;

         /* g729AnnexA */
         case 11:
            rtInvokeStartElement (pctxt, "g729AnnexA", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g729AnnexA, 1U, 256U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.g729AnnexA);

            rtInvokeEndElement (pctxt, "g729AnnexA", -1);

            break;

         /* is11172AudioCapability */
         case 12:
            rtInvokeStartElement (pctxt, "is11172AudioCapability", -1);

            pvalue->u.is11172AudioCapability = ALLOC_ASN1ELEM (pctxt, H245IS11172AudioCapability);
            if (pvalue->u.is11172AudioCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245IS11172AudioCapability (pctxt, pvalue->u.is11172AudioCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "is11172AudioCapability", -1);

            break;

         /* is13818AudioCapability */
         case 13:
            rtInvokeStartElement (pctxt, "is13818AudioCapability", -1);

            pvalue->u.is13818AudioCapability = ALLOC_ASN1ELEM (pctxt, H245IS13818AudioCapability);
            if (pvalue->u.is13818AudioCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245IS13818AudioCapability (pctxt, pvalue->u.is13818AudioCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "is13818AudioCapability", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 15;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* g729wAnnexB */
         case 15:
            rtInvokeStartElement (pctxt, "g729wAnnexB", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g729wAnnexB, 1U, 256U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.g729wAnnexB);

            rtInvokeEndElement (pctxt, "g729wAnnexB", -1);

            break;

         /* g729AnnexAwAnnexB */
         case 16:
            rtInvokeStartElement (pctxt, "g729AnnexAwAnnexB", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g729AnnexAwAnnexB, 1U, 256U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.g729AnnexAwAnnexB);

            rtInvokeEndElement (pctxt, "g729AnnexAwAnnexB", -1);

            break;

         /* g7231AnnexCCapability */
         case 17:
            rtInvokeStartElement (pctxt, "g7231AnnexCCapability", -1);

            pvalue->u.g7231AnnexCCapability = ALLOC_ASN1ELEM (pctxt, H245G7231AnnexCCapability);
            if (pvalue->u.g7231AnnexCCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245G7231AnnexCCapability (pctxt, pvalue->u.g7231AnnexCCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "g7231AnnexCCapability", -1);

            break;

         /* gsmFullRate */
         case 18:
            rtInvokeStartElement (pctxt, "gsmFullRate", -1);

            pvalue->u.gsmFullRate = ALLOC_ASN1ELEM (pctxt, H245GSMAudioCapability);
            if (pvalue->u.gsmFullRate == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245GSMAudioCapability (pctxt, pvalue->u.gsmFullRate);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "gsmFullRate", -1);

            break;

         /* gsmHalfRate */
         case 19:
            rtInvokeStartElement (pctxt, "gsmHalfRate", -1);

            pvalue->u.gsmHalfRate = ALLOC_ASN1ELEM (pctxt, H245GSMAudioCapability);
            if (pvalue->u.gsmHalfRate == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245GSMAudioCapability (pctxt, pvalue->u.gsmHalfRate);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "gsmHalfRate", -1);

            break;

         /* gsmEnhancedFullRate */
         case 20:
            rtInvokeStartElement (pctxt, "gsmEnhancedFullRate", -1);

            pvalue->u.gsmEnhancedFullRate = ALLOC_ASN1ELEM (pctxt, H245GSMAudioCapability);
            if (pvalue->u.gsmEnhancedFullRate == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245GSMAudioCapability (pctxt, pvalue->u.gsmEnhancedFullRate);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "gsmEnhancedFullRate", -1);

            break;

         /* genericAudioCapability */
         case 21:
            rtInvokeStartElement (pctxt, "genericAudioCapability", -1);

            pvalue->u.genericAudioCapability = ALLOC_ASN1ELEM (pctxt, H245GenericCapability);
            if (pvalue->u.genericAudioCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245GenericCapability (pctxt, pvalue->u.genericAudioCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "genericAudioCapability", -1);

            break;

         /* g729Extensions */
         case 22:
            rtInvokeStartElement (pctxt, "g729Extensions", -1);

            pvalue->u.g729Extensions = ALLOC_ASN1ELEM (pctxt, H245G729Extensions);
            if (pvalue->u.g729Extensions == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245G729Extensions (pctxt, pvalue->u.g729Extensions);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "g729Extensions", -1);

            break;

         /* vbd */
         case 23:
            rtInvokeStartElement (pctxt, "vbd", -1);

            pvalue->u.vbd = ALLOC_ASN1ELEM (pctxt, H245VBDCapability);
            if (pvalue->u.vbd == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245VBDCapability (pctxt, pvalue->u.vbd);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "vbd", -1);

            break;

         /* audioTelephonyEvent */
         case 24:
            rtInvokeStartElement (pctxt, "audioTelephonyEvent", -1);

            pvalue->u.audioTelephonyEvent = ALLOC_ASN1ELEM (pctxt, H245NoPTAudioTelephonyEventCapability);
            if (pvalue->u.audioTelephonyEvent == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NoPTAudioTelephonyEventCapability (pctxt, pvalue->u.audioTelephonyEvent);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "audioTelephonyEvent", -1);

            break;

         /* audioTone */
         case 25:
            rtInvokeStartElement (pctxt, "audioTone", -1);

            pvalue->u.audioTone = ALLOC_ASN1ELEM (pctxt, H245NoPTAudioToneCapability);
            if (pvalue->u.audioTone == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NoPTAudioToneCapability (pctxt, pvalue->u.audioTone);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "audioTone", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Capability_h233EncryptionReceiveCapability                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245Capability_h233EncryptionReceiveCapability (OOCTXT* pctxt, H245Capability_h233EncryptionReceiveCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode h233IVResponseTime */

   rtInvokeStartElement (pctxt, "h233IVResponseTime", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->h233IVResponseTime, 0U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->h233IVResponseTime);

   rtInvokeEndElement (pctxt, "h233IVResponseTime", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH245NonStandardParameter                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245_SeqOfH245NonStandardParameter (OOCTXT* pctxt, H245_SeqOfH245NonStandardParameter* pvalue)
{
   int stat = ASN_OK;
   H245NonStandardParameter* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         rtInvokeStartElement (pctxt, "elem", xx1);

         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245NonStandardParameter);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H245NonStandardParameter (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         rtInvokeEndElement (pctxt, "elem", xx1);

         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConferenceCapability                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ConferenceCapability (OOCTXT* pctxt, H245ConferenceCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardDataPresent = optbit;

   /* decode nonStandardData */

   if (pvalue->m.nonStandardDataPresent) {
      rtInvokeStartElement (pctxt, "nonStandardData", -1);

      stat = asn1PD_H245_SeqOfH245NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "nonStandardData", -1);
   }

   /* decode chairControlCapability */

   rtInvokeStartElement (pctxt, "chairControlCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->chairControlCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->chairControlCapability);

   rtInvokeEndElement (pctxt, "chairControlCapability", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 2 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.videoIndicateMixingCapabilityPresent = 1;

                     rtInvokeStartElement (pctxt, "videoIndicateMixingCapability", -1);

                     stat = DECODEBIT (pctxt, &pvalue->videoIndicateMixingCapability);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeBoolValue (pctxt, pvalue->videoIndicateMixingCapability);

                     rtInvokeEndElement (pctxt, "videoIndicateMixingCapability", -1);
                     break;

                  case 1:
                     pvalue->m.multipointVisualizationCapabilityPresent = 1;

                     rtInvokeStartElement (pctxt, "multipointVisualizationCapability", -1);

                     stat = DECODEBIT (pctxt, &pvalue->multipointVisualizationCapability);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeBoolValue (pctxt, pvalue->multipointVisualizationCapability);

                     rtInvokeEndElement (pctxt, "multipointVisualizationCapability", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 2) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MediaEncryptionAlgorithm                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MediaEncryptionAlgorithm (OOCTXT* pctxt, H245MediaEncryptionAlgorithm* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* algorithm */
         case 1:
            rtInvokeStartElement (pctxt, "algorithm", -1);

            pvalue->u.algorithm = ALLOC_ASN1ELEM (pctxt, ASN1OBJID);
            if (pvalue->u.algorithm == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = decodeObjectIdentifier (pctxt, pvalue->u.algorithm);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeOidValue (pctxt, pvalue->u.algorithm->numids, pvalue->u.algorithm->subid);

            rtInvokeEndElement (pctxt, "algorithm", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncryptionCapability                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245EncryptionCapability (OOCTXT* pctxt, H245EncryptionCapability* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   H245MediaEncryptionAlgorithm* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245MediaEncryptionAlgorithm);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245MediaEncryptionAlgorithm (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AuthenticationCapability                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245AuthenticationCapability (OOCTXT* pctxt, H245AuthenticationCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardPresent = optbit;

   /* decode nonStandard */

   if (pvalue->m.nonStandardPresent) {
      rtInvokeStartElement (pctxt, "nonStandard", -1);

      stat = asn1PD_H245NonStandardParameter (pctxt, &pvalue->nonStandard);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "nonStandard", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 1 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.antiSpamAlgorithmPresent = 1;

                     rtInvokeStartElement (pctxt, "antiSpamAlgorithm", -1);

                     stat = decodeObjectIdentifier (pctxt, &pvalue->antiSpamAlgorithm);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeOidValue (pctxt, pvalue->antiSpamAlgorithm.numids, pvalue->antiSpamAlgorithm.subid);

                     rtInvokeEndElement (pctxt, "antiSpamAlgorithm", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 1) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IntegrityCapability                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245IntegrityCapability (OOCTXT* pctxt, H245IntegrityCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardPresent = optbit;

   /* decode nonStandard */

   if (pvalue->m.nonStandardPresent) {
      rtInvokeStartElement (pctxt, "nonStandard", -1);

      stat = asn1PD_H245NonStandardParameter (pctxt, &pvalue->nonStandard);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "nonStandard", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncryptionAuthenticationAndIntegrity                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245EncryptionAuthenticationAndIntegrity (OOCTXT* pctxt, H245EncryptionAuthenticationAndIntegrity* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.encryptionCapabilityPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.authenticationCapabilityPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.integrityCapabilityPresent = optbit;

   /* decode encryptionCapability */

   if (pvalue->m.encryptionCapabilityPresent) {
      rtInvokeStartElement (pctxt, "encryptionCapability", -1);

      stat = asn1PD_H245EncryptionCapability (pctxt, &pvalue->encryptionCapability);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "encryptionCapability", -1);
   }

   /* decode authenticationCapability */

   if (pvalue->m.authenticationCapabilityPresent) {
      rtInvokeStartElement (pctxt, "authenticationCapability", -1);

      stat = asn1PD_H245AuthenticationCapability (pctxt, &pvalue->authenticationCapability);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "authenticationCapability", -1);
   }

   /* decode integrityCapability */

   if (pvalue->m.integrityCapabilityPresent) {
      rtInvokeStartElement (pctxt, "integrityCapability", -1);

      stat = asn1PD_H245IntegrityCapability (pctxt, &pvalue->integrityCapability);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "integrityCapability", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H235SecurityCapability                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H235SecurityCapability (OOCTXT* pctxt, H245H235SecurityCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode encryptionAuthenticationAndIntegrity */

   rtInvokeStartElement (pctxt, "encryptionAuthenticationAndIntegrity", -1);

   stat = asn1PD_H245EncryptionAuthenticationAndIntegrity (pctxt, &pvalue->encryptionAuthenticationAndIntegrity);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "encryptionAuthenticationAndIntegrity", -1);

   /* decode mediaCapability */

   rtInvokeStartElement (pctxt, "mediaCapability", -1);

   stat = asn1PD_H245CapabilityTableEntryNumber (pctxt, &pvalue->mediaCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "mediaCapability", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UserInputCapability_nonStandard                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245UserInputCapability_nonStandard (OOCTXT* pctxt, H245UserInputCapability_nonStandard* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 16, 0 };
   int stat = ASN_OK;
   H245NonStandardParameter* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245NonStandardParameter);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245NonStandardParameter (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UserInputCapability                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245UserInputCapability (OOCTXT* pctxt, H245UserInputCapability* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 5);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245UserInputCapability_nonStandard);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245UserInputCapability_nonStandard (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* basicString */
         case 1:
            rtInvokeStartElement (pctxt, "basicString", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "basicString", -1);

            break;

         /* iA5String */
         case 2:
            rtInvokeStartElement (pctxt, "iA5String", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "iA5String", -1);

            break;

         /* generalString */
         case 3:
            rtInvokeStartElement (pctxt, "generalString", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "generalString", -1);

            break;

         /* dtmf */
         case 4:
            rtInvokeStartElement (pctxt, "dtmf", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "dtmf", -1);

            break;

         /* hookflash */
         case 5:
            rtInvokeStartElement (pctxt, "hookflash", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "hookflash", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 7;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* extendedAlphanumeric */
         case 7:
            rtInvokeStartElement (pctxt, "extendedAlphanumeric", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "extendedAlphanumeric", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexFormat                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplexFormat (OOCTXT* pctxt, H245MultiplexFormat* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* h222Capability */
         case 1:
            rtInvokeStartElement (pctxt, "h222Capability", -1);

            pvalue->u.h222Capability = ALLOC_ASN1ELEM (pctxt, H245H222Capability);
            if (pvalue->u.h222Capability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H222Capability (pctxt, pvalue->u.h222Capability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h222Capability", -1);

            break;

         /* h223Capability */
         case 2:
            rtInvokeStartElement (pctxt, "h223Capability", -1);

            pvalue->u.h223Capability = ALLOC_ASN1ELEM (pctxt, H245H223Capability);
            if (pvalue->u.h223Capability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H223Capability (pctxt, pvalue->u.h223Capability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h223Capability", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AlternativeCapabilitySet                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245AlternativeCapabilitySet (OOCTXT* pctxt, H245AlternativeCapabilitySet* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      stat = asn1PD_H245CapabilityTableEntryNumber (pctxt, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexedStreamCapability_capabilityOnMuxStream         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplexedStreamCapability_capabilityOnMuxStream (OOCTXT* pctxt, H245MultiplexedStreamCapability_capabilityOnMuxStream* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   H245AlternativeCapabilitySet* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245AlternativeCapabilitySet);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245AlternativeCapabilitySet (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexedStreamCapability                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplexedStreamCapability (OOCTXT* pctxt, H245MultiplexedStreamCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.capabilityOnMuxStreamPresent = optbit;

   /* decode multiplexFormat */

   rtInvokeStartElement (pctxt, "multiplexFormat", -1);

   stat = asn1PD_H245MultiplexFormat (pctxt, &pvalue->multiplexFormat);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "multiplexFormat", -1);

   /* decode controlOnMuxStream */

   rtInvokeStartElement (pctxt, "controlOnMuxStream", -1);

   stat = DECODEBIT (pctxt, &pvalue->controlOnMuxStream);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->controlOnMuxStream);

   rtInvokeEndElement (pctxt, "controlOnMuxStream", -1);

   /* decode capabilityOnMuxStream */

   if (pvalue->m.capabilityOnMuxStreamPresent) {
      rtInvokeStartElement (pctxt, "capabilityOnMuxStream", -1);

      stat = asn1PD_H245MultiplexedStreamCapability_capabilityOnMuxStream (pctxt, &pvalue->capabilityOnMuxStream);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "capabilityOnMuxStream", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AudioTelephonyEventCapability                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245AudioTelephonyEventCapability (OOCTXT* pctxt, H245AudioTelephonyEventCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode dynamicRTPPayloadType */

   rtInvokeStartElement (pctxt, "dynamicRTPPayloadType", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->dynamicRTPPayloadType, 96U, 127U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->dynamicRTPPayloadType);

   rtInvokeEndElement (pctxt, "dynamicRTPPayloadType", -1);

   /* decode audioTelephoneEvent */

   rtInvokeStartElement (pctxt, "audioTelephoneEvent", -1);

   stat = decodeVarWidthCharString (pctxt, &pvalue->audioTelephoneEvent);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeCharStrValue (pctxt, pvalue->audioTelephoneEvent);

   rtInvokeEndElement (pctxt, "audioTelephoneEvent", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AudioToneCapability                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245AudioToneCapability (OOCTXT* pctxt, H245AudioToneCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode dynamicRTPPayloadType */

   rtInvokeStartElement (pctxt, "dynamicRTPPayloadType", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->dynamicRTPPayloadType, 96U, 127U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->dynamicRTPPayloadType);

   rtInvokeEndElement (pctxt, "dynamicRTPPayloadType", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FECCapability_rfc2733_separateStream                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245FECCapability_rfc2733_separateStream (OOCTXT* pctxt, H245FECCapability_rfc2733_separateStream* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode separatePort */

   rtInvokeStartElement (pctxt, "separatePort", -1);

   stat = DECODEBIT (pctxt, &pvalue->separatePort);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->separatePort);

   rtInvokeEndElement (pctxt, "separatePort", -1);

   /* decode samePort */

   rtInvokeStartElement (pctxt, "samePort", -1);

   stat = DECODEBIT (pctxt, &pvalue->samePort);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->samePort);

   rtInvokeEndElement (pctxt, "samePort", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FECCapability_rfc2733                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245FECCapability_rfc2733 (OOCTXT* pctxt, H245FECCapability_rfc2733* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode redundancyEncoding */

   rtInvokeStartElement (pctxt, "redundancyEncoding", -1);

   stat = DECODEBIT (pctxt, &pvalue->redundancyEncoding);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->redundancyEncoding);

   rtInvokeEndElement (pctxt, "redundancyEncoding", -1);

   /* decode separateStream */

   rtInvokeStartElement (pctxt, "separateStream", -1);

   stat = asn1PD_H245FECCapability_rfc2733_separateStream (pctxt, &pvalue->separateStream);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "separateStream", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FECCapability                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245FECCapability (OOCTXT* pctxt, H245FECCapability* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* rfc2733 */
         case 0:
            rtInvokeStartElement (pctxt, "rfc2733", -1);

            pvalue->u.rfc2733 = ALLOC_ASN1ELEM (pctxt, H245FECCapability_rfc2733);
            if (pvalue->u.rfc2733 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245FECCapability_rfc2733 (pctxt, pvalue->u.rfc2733);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "rfc2733", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplePayloadStreamCapability_capabilities              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplePayloadStreamCapability_capabilities (OOCTXT* pctxt, H245MultiplePayloadStreamCapability_capabilities* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   H245AlternativeCapabilitySet* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245AlternativeCapabilitySet);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245AlternativeCapabilitySet (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplePayloadStreamCapability                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplePayloadStreamCapability (OOCTXT* pctxt, H245MultiplePayloadStreamCapability* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode capabilities */

   rtInvokeStartElement (pctxt, "capabilities", -1);

   stat = asn1PD_H245MultiplePayloadStreamCapability_capabilities (pctxt, &pvalue->capabilities);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "capabilities", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Capability                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245Capability (OOCTXT* pctxt, H245Capability* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 11);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* receiveVideoCapability */
         case 1:
            rtInvokeStartElement (pctxt, "receiveVideoCapability", -1);

            pvalue->u.receiveVideoCapability = ALLOC_ASN1ELEM (pctxt, H245VideoCapability);
            if (pvalue->u.receiveVideoCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245VideoCapability (pctxt, pvalue->u.receiveVideoCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "receiveVideoCapability", -1);

            break;

         /* transmitVideoCapability */
         case 2:
            rtInvokeStartElement (pctxt, "transmitVideoCapability", -1);

            pvalue->u.transmitVideoCapability = ALLOC_ASN1ELEM (pctxt, H245VideoCapability);
            if (pvalue->u.transmitVideoCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245VideoCapability (pctxt, pvalue->u.transmitVideoCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "transmitVideoCapability", -1);

            break;

         /* receiveAndTransmitVideoCapability */
         case 3:
            rtInvokeStartElement (pctxt, "receiveAndTransmitVideoCapability", -1);

            pvalue->u.receiveAndTransmitVideoCapability = ALLOC_ASN1ELEM (pctxt, H245VideoCapability);
            if (pvalue->u.receiveAndTransmitVideoCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245VideoCapability (pctxt, pvalue->u.receiveAndTransmitVideoCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "receiveAndTransmitVideoCapability", -1);

            break;

         /* receiveAudioCapability */
         case 4:
            rtInvokeStartElement (pctxt, "receiveAudioCapability", -1);

            pvalue->u.receiveAudioCapability = ALLOC_ASN1ELEM (pctxt, H245AudioCapability);
            if (pvalue->u.receiveAudioCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245AudioCapability (pctxt, pvalue->u.receiveAudioCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "receiveAudioCapability", -1);

            break;

         /* transmitAudioCapability */
         case 5:
            rtInvokeStartElement (pctxt, "transmitAudioCapability", -1);

            pvalue->u.transmitAudioCapability = ALLOC_ASN1ELEM (pctxt, H245AudioCapability);
            if (pvalue->u.transmitAudioCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245AudioCapability (pctxt, pvalue->u.transmitAudioCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "transmitAudioCapability", -1);

            break;

         /* receiveAndTransmitAudioCapability */
         case 6:
            rtInvokeStartElement (pctxt, "receiveAndTransmitAudioCapability", -1);

            pvalue->u.receiveAndTransmitAudioCapability = ALLOC_ASN1ELEM (pctxt, H245AudioCapability);
            if (pvalue->u.receiveAndTransmitAudioCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245AudioCapability (pctxt, pvalue->u.receiveAndTransmitAudioCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "receiveAndTransmitAudioCapability", -1);

            break;

         /* receiveDataApplicationCapability */
         case 7:
            rtInvokeStartElement (pctxt, "receiveDataApplicationCapability", -1);

            pvalue->u.receiveDataApplicationCapability = ALLOC_ASN1ELEM (pctxt, H245DataApplicationCapability);
            if (pvalue->u.receiveDataApplicationCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataApplicationCapability (pctxt, pvalue->u.receiveDataApplicationCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "receiveDataApplicationCapability", -1);

            break;

         /* transmitDataApplicationCapability */
         case 8:
            rtInvokeStartElement (pctxt, "transmitDataApplicationCapability", -1);

            pvalue->u.transmitDataApplicationCapability = ALLOC_ASN1ELEM (pctxt, H245DataApplicationCapability);
            if (pvalue->u.transmitDataApplicationCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataApplicationCapability (pctxt, pvalue->u.transmitDataApplicationCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "transmitDataApplicationCapability", -1);

            break;

         /* receiveAndTransmitDataApplicationCapability */
         case 9:
            rtInvokeStartElement (pctxt, "receiveAndTransmitDataApplicationCapability", -1);

            pvalue->u.receiveAndTransmitDataApplicationCapability = ALLOC_ASN1ELEM (pctxt, H245DataApplicationCapability);
            if (pvalue->u.receiveAndTransmitDataApplicationCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataApplicationCapability (pctxt, pvalue->u.receiveAndTransmitDataApplicationCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "receiveAndTransmitDataApplicationCapability", -1);

            break;

         /* h233EncryptionTransmitCapability */
         case 10:
            rtInvokeStartElement (pctxt, "h233EncryptionTransmitCapability", -1);

            stat = DECODEBIT (pctxt, &pvalue->u.h233EncryptionTransmitCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeBoolValue (pctxt, pvalue->u.h233EncryptionTransmitCapability);

            rtInvokeEndElement (pctxt, "h233EncryptionTransmitCapability", -1);

            break;

         /* h233EncryptionReceiveCapability */
         case 11:
            rtInvokeStartElement (pctxt, "h233EncryptionReceiveCapability", -1);

            pvalue->u.h233EncryptionReceiveCapability = ALLOC_ASN1ELEM (pctxt, H245Capability_h233EncryptionReceiveCapability);
            if (pvalue->u.h233EncryptionReceiveCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245Capability_h233EncryptionReceiveCapability (pctxt, pvalue->u.h233EncryptionReceiveCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h233EncryptionReceiveCapability", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 13;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* conferenceCapability */
         case 13:
            rtInvokeStartElement (pctxt, "conferenceCapability", -1);

            pvalue->u.conferenceCapability = ALLOC_ASN1ELEM (pctxt, H245ConferenceCapability);
            if (pvalue->u.conferenceCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245ConferenceCapability (pctxt, pvalue->u.conferenceCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "conferenceCapability", -1);

            break;

         /* h235SecurityCapability */
         case 14:
            rtInvokeStartElement (pctxt, "h235SecurityCapability", -1);

            pvalue->u.h235SecurityCapability = ALLOC_ASN1ELEM (pctxt, H245H235SecurityCapability);
            if (pvalue->u.h235SecurityCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H235SecurityCapability (pctxt, pvalue->u.h235SecurityCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h235SecurityCapability", -1);

            break;

         /* maxPendingReplacementFor */
         case 15:
            rtInvokeStartElement (pctxt, "maxPendingReplacementFor", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->u.maxPendingReplacementFor, 0U, 255U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.maxPendingReplacementFor);

            rtInvokeEndElement (pctxt, "maxPendingReplacementFor", -1);

            break;

         /* receiveUserInputCapability */
         case 16:
            rtInvokeStartElement (pctxt, "receiveUserInputCapability", -1);

            pvalue->u.receiveUserInputCapability = ALLOC_ASN1ELEM (pctxt, H245UserInputCapability);
            if (pvalue->u.receiveUserInputCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245UserInputCapability (pctxt, pvalue->u.receiveUserInputCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "receiveUserInputCapability", -1);

            break;

         /* transmitUserInputCapability */
         case 17:
            rtInvokeStartElement (pctxt, "transmitUserInputCapability", -1);

            pvalue->u.transmitUserInputCapability = ALLOC_ASN1ELEM (pctxt, H245UserInputCapability);
            if (pvalue->u.transmitUserInputCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245UserInputCapability (pctxt, pvalue->u.transmitUserInputCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "transmitUserInputCapability", -1);

            break;

         /* receiveAndTransmitUserInputCapability */
         case 18:
            rtInvokeStartElement (pctxt, "receiveAndTransmitUserInputCapability", -1);

            pvalue->u.receiveAndTransmitUserInputCapability = ALLOC_ASN1ELEM (pctxt, H245UserInputCapability);
            if (pvalue->u.receiveAndTransmitUserInputCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245UserInputCapability (pctxt, pvalue->u.receiveAndTransmitUserInputCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "receiveAndTransmitUserInputCapability", -1);

            break;

         /* genericControlCapability */
         case 19:
            rtInvokeStartElement (pctxt, "genericControlCapability", -1);

            pvalue->u.genericControlCapability = ALLOC_ASN1ELEM (pctxt, H245GenericCapability);
            if (pvalue->u.genericControlCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245GenericCapability (pctxt, pvalue->u.genericControlCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "genericControlCapability", -1);

            break;

         /* receiveMultiplexedStreamCapability */
         case 20:
            rtInvokeStartElement (pctxt, "receiveMultiplexedStreamCapability", -1);

            pvalue->u.receiveMultiplexedStreamCapability = ALLOC_ASN1ELEM (pctxt, H245MultiplexedStreamCapability);
            if (pvalue->u.receiveMultiplexedStreamCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultiplexedStreamCapability (pctxt, pvalue->u.receiveMultiplexedStreamCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "receiveMultiplexedStreamCapability", -1);

            break;

         /* transmitMultiplexedStreamCapability */
         case 21:
            rtInvokeStartElement (pctxt, "transmitMultiplexedStreamCapability", -1);

            pvalue->u.transmitMultiplexedStreamCapability = ALLOC_ASN1ELEM (pctxt, H245MultiplexedStreamCapability);
            if (pvalue->u.transmitMultiplexedStreamCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultiplexedStreamCapability (pctxt, pvalue->u.transmitMultiplexedStreamCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "transmitMultiplexedStreamCapability", -1);

            break;

         /* receiveAndTransmitMultiplexedStreamCapability */
         case 22:
            rtInvokeStartElement (pctxt, "receiveAndTransmitMultiplexedStreamCapability", -1);

            pvalue->u.receiveAndTransmitMultiplexedStreamCapability = ALLOC_ASN1ELEM (pctxt, H245MultiplexedStreamCapability);
            if (pvalue->u.receiveAndTransmitMultiplexedStreamCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultiplexedStreamCapability (pctxt, pvalue->u.receiveAndTransmitMultiplexedStreamCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "receiveAndTransmitMultiplexedStreamCapability", -1);

            break;

         /* receiveRTPAudioTelephonyEventCapability */
         case 23:
            rtInvokeStartElement (pctxt, "receiveRTPAudioTelephonyEventCapability", -1);

            pvalue->u.receiveRTPAudioTelephonyEventCapability = ALLOC_ASN1ELEM (pctxt, H245AudioTelephonyEventCapability);
            if (pvalue->u.receiveRTPAudioTelephonyEventCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245AudioTelephonyEventCapability (pctxt, pvalue->u.receiveRTPAudioTelephonyEventCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "receiveRTPAudioTelephonyEventCapability", -1);

            break;

         /* receiveRTPAudioToneCapability */
         case 24:
            rtInvokeStartElement (pctxt, "receiveRTPAudioToneCapability", -1);

            pvalue->u.receiveRTPAudioToneCapability = ALLOC_ASN1ELEM (pctxt, H245AudioToneCapability);
            if (pvalue->u.receiveRTPAudioToneCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245AudioToneCapability (pctxt, pvalue->u.receiveRTPAudioToneCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "receiveRTPAudioToneCapability", -1);

            break;

         /* fecCapability */
         case 25:
            rtInvokeStartElement (pctxt, "fecCapability", -1);

            pvalue->u.fecCapability = ALLOC_ASN1ELEM (pctxt, H245FECCapability);
            if (pvalue->u.fecCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245FECCapability (pctxt, pvalue->u.fecCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "fecCapability", -1);

            break;

         /* multiplePayloadStreamCapability */
         case 26:
            rtInvokeStartElement (pctxt, "multiplePayloadStreamCapability", -1);

            pvalue->u.multiplePayloadStreamCapability = ALLOC_ASN1ELEM (pctxt, H245MultiplePayloadStreamCapability);
            if (pvalue->u.multiplePayloadStreamCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultiplePayloadStreamCapability (pctxt, pvalue->u.multiplePayloadStreamCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "multiplePayloadStreamCapability", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CapabilityTableEntry                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CapabilityTableEntry (OOCTXT* pctxt, H245CapabilityTableEntry* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.capabilityPresent = optbit;

   /* decode capabilityTableEntryNumber */

   rtInvokeStartElement (pctxt, "capabilityTableEntryNumber", -1);

   stat = asn1PD_H245CapabilityTableEntryNumber (pctxt, &pvalue->capabilityTableEntryNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "capabilityTableEntryNumber", -1);

   /* decode capability */

   if (pvalue->m.capabilityPresent) {
      rtInvokeStartElement (pctxt, "capability", -1);

      stat = asn1PD_H245Capability (pctxt, &pvalue->capability);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "capability", -1);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalCapabilitySet_capabilityTable                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245TerminalCapabilitySet_capabilityTable (OOCTXT* pctxt, H245TerminalCapabilitySet_capabilityTable* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   H245CapabilityTableEntry* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245CapabilityTableEntry);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245CapabilityTableEntry (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CapabilityDescriptor_simultaneousCapabilities             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CapabilityDescriptor_simultaneousCapabilities (OOCTXT* pctxt, H245CapabilityDescriptor_simultaneousCapabilities* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   H245AlternativeCapabilitySet* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245AlternativeCapabilitySet);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245AlternativeCapabilitySet (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CapabilityDescriptor                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CapabilityDescriptor (OOCTXT* pctxt, H245CapabilityDescriptor* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.simultaneousCapabilitiesPresent = optbit;

   /* decode capabilityDescriptorNumber */

   rtInvokeStartElement (pctxt, "capabilityDescriptorNumber", -1);

   stat = asn1PD_H245CapabilityDescriptorNumber (pctxt, &pvalue->capabilityDescriptorNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "capabilityDescriptorNumber", -1);

   /* decode simultaneousCapabilities */

   if (pvalue->m.simultaneousCapabilitiesPresent) {
      rtInvokeStartElement (pctxt, "simultaneousCapabilities", -1);

      stat = asn1PD_H245CapabilityDescriptor_simultaneousCapabilities (pctxt, &pvalue->simultaneousCapabilities);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "simultaneousCapabilities", -1);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalCapabilitySet_capabilityDescriptors               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245TerminalCapabilitySet_capabilityDescriptors (OOCTXT* pctxt, H245TerminalCapabilitySet_capabilityDescriptors* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   H245CapabilityDescriptor* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245CapabilityDescriptor);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245CapabilityDescriptor (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalCapabilitySet                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245TerminalCapabilitySet (OOCTXT* pctxt, H245TerminalCapabilitySet* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.multiplexCapabilityPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.capabilityTablePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.capabilityDescriptorsPresent = optbit;

   /* decode sequenceNumber */

   rtInvokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode protocolIdentifier */

   rtInvokeStartElement (pctxt, "protocolIdentifier", -1);

   stat = decodeObjectIdentifier (pctxt, &pvalue->protocolIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOidValue (pctxt, pvalue->protocolIdentifier.numids, pvalue->protocolIdentifier.subid);

   rtInvokeEndElement (pctxt, "protocolIdentifier", -1);

   /* decode multiplexCapability */

   if (pvalue->m.multiplexCapabilityPresent) {
      rtInvokeStartElement (pctxt, "multiplexCapability", -1);

      stat = asn1PD_H245MultiplexCapability (pctxt, &pvalue->multiplexCapability);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "multiplexCapability", -1);
   }

   /* decode capabilityTable */

   if (pvalue->m.capabilityTablePresent) {
      rtInvokeStartElement (pctxt, "capabilityTable", -1);

      stat = asn1PD_H245TerminalCapabilitySet_capabilityTable (pctxt, &pvalue->capabilityTable);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "capabilityTable", -1);
   }

   /* decode capabilityDescriptors */

   if (pvalue->m.capabilityDescriptorsPresent) {
      rtInvokeStartElement (pctxt, "capabilityDescriptors", -1);

      stat = asn1PD_H245TerminalCapabilitySet_capabilityDescriptors (pctxt, &pvalue->capabilityDescriptors);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "capabilityDescriptors", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncryptionMode                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245EncryptionMode (OOCTXT* pctxt, H245EncryptionMode* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* h233Encryption */
         case 1:
            rtInvokeStartElement (pctxt, "h233Encryption", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "h233Encryption", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RedundancyEncodingElement                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RedundancyEncodingElement (OOCTXT* pctxt, H245RedundancyEncodingElement* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.payloadTypePresent = optbit;

   /* decode dataType */

   rtInvokeStartElement (pctxt, "dataType", -1);

   pvalue->dataType = ALLOC_ASN1ELEM (pctxt, H245DataType);
   if (pvalue->dataType == NULL)
      return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

   stat = asn1PD_H245DataType (pctxt, (H245DataType*)pvalue->dataType);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "dataType", -1);

   /* decode payloadType */

   if (pvalue->m.payloadTypePresent) {
      rtInvokeStartElement (pctxt, "payloadType", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->payloadType, 0U, 127U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->payloadType);

      rtInvokeEndElement (pctxt, "payloadType", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH245RedundancyEncodingElement                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245_SeqOfH245RedundancyEncodingElement (OOCTXT* pctxt, H245_SeqOfH245RedundancyEncodingElement* pvalue)
{
   int stat = ASN_OK;
   H245RedundancyEncodingElement* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         rtInvokeStartElement (pctxt, "elem", xx1);

         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245RedundancyEncodingElement);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H245RedundancyEncodingElement (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         rtInvokeEndElement (pctxt, "elem", xx1);

         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RedundancyEncoding_rtpRedundancyEncoding                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RedundancyEncoding_rtpRedundancyEncoding (OOCTXT* pctxt, H245RedundancyEncoding_rtpRedundancyEncoding* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.primaryPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.secondaryPresent = optbit;

   /* decode primary */

   if (pvalue->m.primaryPresent) {
      rtInvokeStartElement (pctxt, "primary", -1);

      stat = asn1PD_H245RedundancyEncodingElement (pctxt, &pvalue->primary);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "primary", -1);
   }

   /* decode secondary */

   if (pvalue->m.secondaryPresent) {
      rtInvokeStartElement (pctxt, "secondary", -1);

      stat = asn1PD_H245_SeqOfH245RedundancyEncodingElement (pctxt, &pvalue->secondary);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "secondary", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RedundancyEncoding                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RedundancyEncoding (OOCTXT* pctxt, H245RedundancyEncoding* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.secondaryEncodingPresent = optbit;

   /* decode redundancyEncodingMethod */

   rtInvokeStartElement (pctxt, "redundancyEncodingMethod", -1);

   stat = asn1PD_H245RedundancyEncodingMethod (pctxt, &pvalue->redundancyEncodingMethod);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "redundancyEncodingMethod", -1);

   /* decode secondaryEncoding */

   if (pvalue->m.secondaryEncodingPresent) {
      rtInvokeStartElement (pctxt, "secondaryEncoding", -1);

      pvalue->secondaryEncoding = ALLOC_ASN1ELEM (pctxt, H245DataType);
      if (pvalue->secondaryEncoding == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245DataType (pctxt, (H245DataType*)pvalue->secondaryEncoding);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "secondaryEncoding", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 1 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.rtpRedundancyEncodingPresent = 1;

                     rtInvokeStartElement (pctxt, "rtpRedundancyEncoding", -1);

                     stat = asn1PD_H245RedundancyEncoding_rtpRedundancyEncoding (pctxt, &pvalue->rtpRedundancyEncoding);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "rtpRedundancyEncoding", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 1) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplePayloadStreamElement                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplePayloadStreamElement (OOCTXT* pctxt, H245MultiplePayloadStreamElement* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.payloadTypePresent = optbit;

   /* decode dataType */

   rtInvokeStartElement (pctxt, "dataType", -1);

   pvalue->dataType = ALLOC_ASN1ELEM (pctxt, H245DataType);
   if (pvalue->dataType == NULL)
      return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

   stat = asn1PD_H245DataType (pctxt, (H245DataType*)pvalue->dataType);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "dataType", -1);

   /* decode payloadType */

   if (pvalue->m.payloadTypePresent) {
      rtInvokeStartElement (pctxt, "payloadType", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->payloadType, 0U, 127U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->payloadType);

      rtInvokeEndElement (pctxt, "payloadType", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH245MultiplePayloadStreamElement                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245_SeqOfH245MultiplePayloadStreamElement (OOCTXT* pctxt, H245_SeqOfH245MultiplePayloadStreamElement* pvalue)
{
   int stat = ASN_OK;
   H245MultiplePayloadStreamElement* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         rtInvokeStartElement (pctxt, "elem", xx1);

         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245MultiplePayloadStreamElement);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H245MultiplePayloadStreamElement (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         rtInvokeEndElement (pctxt, "elem", xx1);

         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplePayloadStream                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplePayloadStream (OOCTXT* pctxt, H245MultiplePayloadStream* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode elements */

   rtInvokeStartElement (pctxt, "elements", -1);

   stat = asn1PD_H245_SeqOfH245MultiplePayloadStreamElement (pctxt, &pvalue->elements);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "elements", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FECData_rfc2733_mode_separateStream_differentPort         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245FECData_rfc2733_mode_separateStream_differentPort (OOCTXT* pctxt, H245FECData_rfc2733_mode_separateStream_differentPort* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protectedPayloadTypePresent = optbit;

   /* decode protectedSessionID */

   rtInvokeStartElement (pctxt, "protectedSessionID", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->protectedSessionID, 1U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->protectedSessionID);

   rtInvokeEndElement (pctxt, "protectedSessionID", -1);

   /* decode protectedPayloadType */

   if (pvalue->m.protectedPayloadTypePresent) {
      rtInvokeStartElement (pctxt, "protectedPayloadType", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->protectedPayloadType, 0U, 127U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->protectedPayloadType);

      rtInvokeEndElement (pctxt, "protectedPayloadType", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FECData_rfc2733_mode_separateStream_samePort              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245FECData_rfc2733_mode_separateStream_samePort (OOCTXT* pctxt, H245FECData_rfc2733_mode_separateStream_samePort* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode protectedPayloadType */

   rtInvokeStartElement (pctxt, "protectedPayloadType", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->protectedPayloadType, 0U, 127U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->protectedPayloadType);

   rtInvokeEndElement (pctxt, "protectedPayloadType", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FECData_rfc2733_mode_separateStream                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245FECData_rfc2733_mode_separateStream (OOCTXT* pctxt, H245FECData_rfc2733_mode_separateStream* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* differentPort */
         case 0:
            rtInvokeStartElement (pctxt, "differentPort", -1);

            pvalue->u.differentPort = ALLOC_ASN1ELEM (pctxt, H245FECData_rfc2733_mode_separateStream_differentPort);
            if (pvalue->u.differentPort == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245FECData_rfc2733_mode_separateStream_differentPort (pctxt, pvalue->u.differentPort);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "differentPort", -1);

            break;

         /* samePort */
         case 1:
            rtInvokeStartElement (pctxt, "samePort", -1);

            pvalue->u.samePort = ALLOC_ASN1ELEM (pctxt, H245FECData_rfc2733_mode_separateStream_samePort);
            if (pvalue->u.samePort == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245FECData_rfc2733_mode_separateStream_samePort (pctxt, pvalue->u.samePort);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "samePort", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FECData_rfc2733_mode                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245FECData_rfc2733_mode (OOCTXT* pctxt, H245FECData_rfc2733_mode* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* redundancyEncoding */
         case 0:
            rtInvokeStartElement (pctxt, "redundancyEncoding", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "redundancyEncoding", -1);

            break;

         /* separateStream */
         case 1:
            rtInvokeStartElement (pctxt, "separateStream", -1);

            pvalue->u.separateStream = ALLOC_ASN1ELEM (pctxt, H245FECData_rfc2733_mode_separateStream);
            if (pvalue->u.separateStream == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245FECData_rfc2733_mode_separateStream (pctxt, pvalue->u.separateStream);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "separateStream", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FECData_rfc2733                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245FECData_rfc2733 (OOCTXT* pctxt, H245FECData_rfc2733* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode mode */

   rtInvokeStartElement (pctxt, "mode", -1);

   stat = asn1PD_H245FECData_rfc2733_mode (pctxt, &pvalue->mode);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "mode", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FECData                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245FECData (OOCTXT* pctxt, H245FECData* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* rfc2733 */
      case 0:
         rtInvokeStartElement (pctxt, "rfc2733", -1);

         pvalue->u.rfc2733 = ALLOC_ASN1ELEM (pctxt, H245FECData_rfc2733);
         if (pvalue->u.rfc2733 == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H245FECData_rfc2733 (pctxt, pvalue->u.rfc2733);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

         rtInvokeEndElement (pctxt, "rfc2733", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H235Media_mediaType                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H235Media_mediaType (OOCTXT* pctxt, H245H235Media_mediaType* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* videoData */
         case 1:
            rtInvokeStartElement (pctxt, "videoData", -1);

            pvalue->u.videoData = ALLOC_ASN1ELEM (pctxt, H245VideoCapability);
            if (pvalue->u.videoData == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245VideoCapability (pctxt, pvalue->u.videoData);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "videoData", -1);

            break;

         /* audioData */
         case 2:
            rtInvokeStartElement (pctxt, "audioData", -1);

            pvalue->u.audioData = ALLOC_ASN1ELEM (pctxt, H245AudioCapability);
            if (pvalue->u.audioData == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245AudioCapability (pctxt, pvalue->u.audioData);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "audioData", -1);

            break;

         /* data */
         case 3:
            rtInvokeStartElement (pctxt, "data", -1);

            pvalue->u.data = ALLOC_ASN1ELEM (pctxt, H245DataApplicationCapability);
            if (pvalue->u.data == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataApplicationCapability (pctxt, pvalue->u.data);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "data", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* redundancyEncoding */
         case 5:
            rtInvokeStartElement (pctxt, "redundancyEncoding", -1);

            pvalue->u.redundancyEncoding = ALLOC_ASN1ELEM (pctxt, H245RedundancyEncoding);
            if (pvalue->u.redundancyEncoding == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RedundancyEncoding (pctxt, pvalue->u.redundancyEncoding);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "redundancyEncoding", -1);

            break;

         /* multiplePayloadStream */
         case 6:
            rtInvokeStartElement (pctxt, "multiplePayloadStream", -1);

            pvalue->u.multiplePayloadStream = ALLOC_ASN1ELEM (pctxt, H245MultiplePayloadStream);
            if (pvalue->u.multiplePayloadStream == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultiplePayloadStream (pctxt, pvalue->u.multiplePayloadStream);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "multiplePayloadStream", -1);

            break;

         /* fec */
         case 7:
            rtInvokeStartElement (pctxt, "fec", -1);

            pvalue->u.fec = ALLOC_ASN1ELEM (pctxt, H245FECData);
            if (pvalue->u.fec == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245FECData (pctxt, pvalue->u.fec);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "fec", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H235Media                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H235Media (OOCTXT* pctxt, H245H235Media* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode encryptionAuthenticationAndIntegrity */

   rtInvokeStartElement (pctxt, "encryptionAuthenticationAndIntegrity", -1);

   stat = asn1PD_H245EncryptionAuthenticationAndIntegrity (pctxt, &pvalue->encryptionAuthenticationAndIntegrity);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "encryptionAuthenticationAndIntegrity", -1);

   /* decode mediaType */

   rtInvokeStartElement (pctxt, "mediaType", -1);

   stat = asn1PD_H245H235Media_mediaType (pctxt, &pvalue->mediaType);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "mediaType", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexedStreamParameter                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplexedStreamParameter (OOCTXT* pctxt, H245MultiplexedStreamParameter* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode multiplexFormat */

   rtInvokeStartElement (pctxt, "multiplexFormat", -1);

   stat = asn1PD_H245MultiplexFormat (pctxt, &pvalue->multiplexFormat);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "multiplexFormat", -1);

   /* decode controlOnMuxStream */

   rtInvokeStartElement (pctxt, "controlOnMuxStream", -1);

   stat = DECODEBIT (pctxt, &pvalue->controlOnMuxStream);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->controlOnMuxStream);

   rtInvokeEndElement (pctxt, "controlOnMuxStream", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataType                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245DataType (OOCTXT* pctxt, H245DataType* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 5);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* nullData */
         case 1:
            rtInvokeStartElement (pctxt, "nullData", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "nullData", -1);

            break;

         /* videoData */
         case 2:
            rtInvokeStartElement (pctxt, "videoData", -1);

            pvalue->u.videoData = ALLOC_ASN1ELEM (pctxt, H245VideoCapability);
            if (pvalue->u.videoData == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245VideoCapability (pctxt, pvalue->u.videoData);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "videoData", -1);

            break;

         /* audioData */
         case 3:
            rtInvokeStartElement (pctxt, "audioData", -1);

            pvalue->u.audioData = ALLOC_ASN1ELEM (pctxt, H245AudioCapability);
            if (pvalue->u.audioData == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245AudioCapability (pctxt, pvalue->u.audioData);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "audioData", -1);

            break;

         /* data */
         case 4:
            rtInvokeStartElement (pctxt, "data", -1);

            pvalue->u.data = ALLOC_ASN1ELEM (pctxt, H245DataApplicationCapability);
            if (pvalue->u.data == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataApplicationCapability (pctxt, pvalue->u.data);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "data", -1);

            break;

         /* encryptionData */
         case 5:
            rtInvokeStartElement (pctxt, "encryptionData", -1);

            pvalue->u.encryptionData = ALLOC_ASN1ELEM (pctxt, H245EncryptionMode);
            if (pvalue->u.encryptionData == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245EncryptionMode (pctxt, pvalue->u.encryptionData);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "encryptionData", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 7;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* h235Control */
         case 7:
            rtInvokeStartElement (pctxt, "h235Control", -1);

            pvalue->u.h235Control = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.h235Control == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.h235Control);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h235Control", -1);

            break;

         /* h235Media */
         case 8:
            rtInvokeStartElement (pctxt, "h235Media", -1);

            pvalue->u.h235Media = ALLOC_ASN1ELEM (pctxt, H245H235Media);
            if (pvalue->u.h235Media == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H235Media (pctxt, pvalue->u.h235Media);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h235Media", -1);

            break;

         /* multiplexedStream */
         case 9:
            rtInvokeStartElement (pctxt, "multiplexedStream", -1);

            pvalue->u.multiplexedStream = ALLOC_ASN1ELEM (pctxt, H245MultiplexedStreamParameter);
            if (pvalue->u.multiplexedStream == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultiplexedStreamParameter (pctxt, pvalue->u.multiplexedStream);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "multiplexedStream", -1);

            break;

         /* redundancyEncoding */
         case 10:
            rtInvokeStartElement (pctxt, "redundancyEncoding", -1);

            pvalue->u.redundancyEncoding = ALLOC_ASN1ELEM (pctxt, H245RedundancyEncoding);
            if (pvalue->u.redundancyEncoding == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RedundancyEncoding (pctxt, pvalue->u.redundancyEncoding);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "redundancyEncoding", -1);

            break;

         /* multiplePayloadStream */
         case 11:
            rtInvokeStartElement (pctxt, "multiplePayloadStream", -1);

            pvalue->u.multiplePayloadStream = ALLOC_ASN1ELEM (pctxt, H245MultiplePayloadStream);
            if (pvalue->u.multiplePayloadStream == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultiplePayloadStream (pctxt, pvalue->u.multiplePayloadStream);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "multiplePayloadStream", -1);

            break;

         /* fec */
         case 12:
            rtInvokeStartElement (pctxt, "fec", -1);

            pvalue->u.fec = ALLOC_ASN1ELEM (pctxt, H245FECData);
            if (pvalue->u.fec == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245FECData (pctxt, pvalue->u.fec);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "fec", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H222LogicalChannelParameters                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H222LogicalChannelParameters (OOCTXT* pctxt, H245H222LogicalChannelParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.pcr_pidPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.programDescriptorsPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.streamDescriptorsPresent = optbit;

   /* decode resourceID */

   rtInvokeStartElement (pctxt, "resourceID", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->resourceID, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->resourceID);

   rtInvokeEndElement (pctxt, "resourceID", -1);

   /* decode subChannelID */

   rtInvokeStartElement (pctxt, "subChannelID", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->subChannelID, 0U, 8191U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->subChannelID);

   rtInvokeEndElement (pctxt, "subChannelID", -1);

   /* decode pcr_pid */

   if (pvalue->m.pcr_pidPresent) {
      rtInvokeStartElement (pctxt, "pcr_pid", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->pcr_pid, 0U, 8191U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->pcr_pid);

      rtInvokeEndElement (pctxt, "pcr_pid", -1);
   }

   /* decode programDescriptors */

   if (pvalue->m.programDescriptorsPresent) {
      rtInvokeStartElement (pctxt, "programDescriptors", -1);

      stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->programDescriptors);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeOctStrValue (pctxt, pvalue->programDescriptors.numocts, pvalue->programDescriptors.data);

      rtInvokeEndElement (pctxt, "programDescriptors", -1);
   }

   /* decode streamDescriptors */

   if (pvalue->m.streamDescriptorsPresent) {
      rtInvokeStartElement (pctxt, "streamDescriptors", -1);

      stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->streamDescriptors);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeOctStrValue (pctxt, pvalue->streamDescriptors.numocts, pvalue->streamDescriptors.data);

      rtInvokeEndElement (pctxt, "streamDescriptors", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223LogicalChannelParameters_adaptationLayerType_al3      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223LogicalChannelParameters_adaptationLayerType_al3 (OOCTXT* pctxt, H245H223LogicalChannelParameters_adaptationLayerType_al3* pvalue)
{
   int stat = ASN_OK;

   /* decode controlFieldOctets */

   rtInvokeStartElement (pctxt, "controlFieldOctets", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->controlFieldOctets, 0U, 2U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->controlFieldOctets);

   rtInvokeEndElement (pctxt, "controlFieldOctets", -1);

   /* decode sendBufferSize */

   rtInvokeStartElement (pctxt, "sendBufferSize", -1);

   stat = decodeConsUnsigned (pctxt, &pvalue->sendBufferSize, 0U, 16777215U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->sendBufferSize);

   rtInvokeEndElement (pctxt, "sendBufferSize", -1);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223AL1MParameters_transferMode                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223AL1MParameters_transferMode (OOCTXT* pctxt, H245H223AL1MParameters_transferMode* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* framed */
         case 0:
            rtInvokeStartElement (pctxt, "framed", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "framed", -1);

            break;

         /* unframed */
         case 1:
            rtInvokeStartElement (pctxt, "unframed", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "unframed", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223AL1MParameters_headerFEC                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223AL1MParameters_headerFEC (OOCTXT* pctxt, H245H223AL1MParameters_headerFEC* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* sebch16_7 */
         case 0:
            rtInvokeStartElement (pctxt, "sebch16_7", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "sebch16_7", -1);

            break;

         /* golay24_12 */
         case 1:
            rtInvokeStartElement (pctxt, "golay24_12", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "golay24_12", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223AL1MParameters_crcLength                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223AL1MParameters_crcLength (OOCTXT* pctxt, H245H223AL1MParameters_crcLength* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* crc4bit */
         case 0:
            rtInvokeStartElement (pctxt, "crc4bit", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "crc4bit", -1);

            break;

         /* crc12bit */
         case 1:
            rtInvokeStartElement (pctxt, "crc12bit", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "crc12bit", -1);

            break;

         /* crc20bit */
         case 2:
            rtInvokeStartElement (pctxt, "crc20bit", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "crc20bit", -1);

            break;

         /* crc28bit */
         case 3:
            rtInvokeStartElement (pctxt, "crc28bit", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "crc28bit", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* crc8bit */
         case 5:
            rtInvokeStartElement (pctxt, "crc8bit", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "crc8bit", -1);

            break;

         /* crc16bit */
         case 6:
            rtInvokeStartElement (pctxt, "crc16bit", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "crc16bit", -1);

            break;

         /* crc32bit */
         case 7:
            rtInvokeStartElement (pctxt, "crc32bit", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "crc32bit", -1);

            break;

         /* crcNotUsed */
         case 8:
            rtInvokeStartElement (pctxt, "crcNotUsed", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "crcNotUsed", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223AnnexCArqParameters_numberOfRetransmissions           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223AnnexCArqParameters_numberOfRetransmissions (OOCTXT* pctxt, H245H223AnnexCArqParameters_numberOfRetransmissions* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* finite */
         case 0:
            rtInvokeStartElement (pctxt, "finite", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->u.finite, 0U, 16U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.finite);

            rtInvokeEndElement (pctxt, "finite", -1);

            break;

         /* infinite */
         case 1:
            rtInvokeStartElement (pctxt, "infinite", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "infinite", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223AnnexCArqParameters                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223AnnexCArqParameters (OOCTXT* pctxt, H245H223AnnexCArqParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode numberOfRetransmissions */

   rtInvokeStartElement (pctxt, "numberOfRetransmissions", -1);

   stat = asn1PD_H245H223AnnexCArqParameters_numberOfRetransmissions (pctxt, &pvalue->numberOfRetransmissions);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "numberOfRetransmissions", -1);

   /* decode sendBufferSize */

   rtInvokeStartElement (pctxt, "sendBufferSize", -1);

   stat = decodeConsUnsigned (pctxt, &pvalue->sendBufferSize, 0U, 16777215U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->sendBufferSize);

   rtInvokeEndElement (pctxt, "sendBufferSize", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223AL1MParameters_arqType                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223AL1MParameters_arqType (OOCTXT* pctxt, H245H223AL1MParameters_arqType* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* noArq */
         case 0:
            rtInvokeStartElement (pctxt, "noArq", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "noArq", -1);

            break;

         /* typeIArq */
         case 1:
            rtInvokeStartElement (pctxt, "typeIArq", -1);

            pvalue->u.typeIArq = ALLOC_ASN1ELEM (pctxt, H245H223AnnexCArqParameters);
            if (pvalue->u.typeIArq == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H223AnnexCArqParameters (pctxt, pvalue->u.typeIArq);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "typeIArq", -1);

            break;

         /* typeIIArq */
         case 2:
            rtInvokeStartElement (pctxt, "typeIIArq", -1);

            pvalue->u.typeIIArq = ALLOC_ASN1ELEM (pctxt, H245H223AnnexCArqParameters);
            if (pvalue->u.typeIIArq == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H223AnnexCArqParameters (pctxt, pvalue->u.typeIIArq);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "typeIIArq", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223AL1MParameters                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223AL1MParameters (OOCTXT* pctxt, H245H223AL1MParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   /* decode transferMode */

   rtInvokeStartElement (pctxt, "transferMode", -1);

   stat = asn1PD_H245H223AL1MParameters_transferMode (pctxt, &pvalue->transferMode);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "transferMode", -1);

   /* decode headerFEC */

   rtInvokeStartElement (pctxt, "headerFEC", -1);

   stat = asn1PD_H245H223AL1MParameters_headerFEC (pctxt, &pvalue->headerFEC);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "headerFEC", -1);

   /* decode crcLength */

   rtInvokeStartElement (pctxt, "crcLength", -1);

   stat = asn1PD_H245H223AL1MParameters_crcLength (pctxt, &pvalue->crcLength);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "crcLength", -1);

   /* decode rcpcCodeRate */

   rtInvokeStartElement (pctxt, "rcpcCodeRate", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->rcpcCodeRate, 8U, 32U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->rcpcCodeRate);

   rtInvokeEndElement (pctxt, "rcpcCodeRate", -1);

   /* decode arqType */

   rtInvokeStartElement (pctxt, "arqType", -1);

   stat = asn1PD_H245H223AL1MParameters_arqType (pctxt, &pvalue->arqType);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "arqType", -1);

   /* decode alpduInterleaving */

   rtInvokeStartElement (pctxt, "alpduInterleaving", -1);

   stat = DECODEBIT (pctxt, &pvalue->alpduInterleaving);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->alpduInterleaving);

   rtInvokeEndElement (pctxt, "alpduInterleaving", -1);

   /* decode alsduSplitting */

   rtInvokeStartElement (pctxt, "alsduSplitting", -1);

   stat = DECODEBIT (pctxt, &pvalue->alsduSplitting);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->alsduSplitting);

   rtInvokeEndElement (pctxt, "alsduSplitting", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 1 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.rsCodeCorrectionPresent = 1;

                     rtInvokeStartElement (pctxt, "rsCodeCorrection", -1);

                     stat = decodeConsUInt8 (pctxt, &pvalue->rsCodeCorrection, 0U, 127U);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeUIntValue (pctxt, pvalue->rsCodeCorrection);

                     rtInvokeEndElement (pctxt, "rsCodeCorrection", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 1) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223AL2MParameters_headerFEC                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223AL2MParameters_headerFEC (OOCTXT* pctxt, H245H223AL2MParameters_headerFEC* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* sebch16_5 */
         case 0:
            rtInvokeStartElement (pctxt, "sebch16_5", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "sebch16_5", -1);

            break;

         /* golay24_12 */
         case 1:
            rtInvokeStartElement (pctxt, "golay24_12", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "golay24_12", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223AL2MParameters                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223AL2MParameters (OOCTXT* pctxt, H245H223AL2MParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode headerFEC */

   rtInvokeStartElement (pctxt, "headerFEC", -1);

   stat = asn1PD_H245H223AL2MParameters_headerFEC (pctxt, &pvalue->headerFEC);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "headerFEC", -1);

   /* decode alpduInterleaving */

   rtInvokeStartElement (pctxt, "alpduInterleaving", -1);

   stat = DECODEBIT (pctxt, &pvalue->alpduInterleaving);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->alpduInterleaving);

   rtInvokeEndElement (pctxt, "alpduInterleaving", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223AL3MParameters_headerFormat                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223AL3MParameters_headerFormat (OOCTXT* pctxt, H245H223AL3MParameters_headerFormat* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* sebch16_7 */
         case 0:
            rtInvokeStartElement (pctxt, "sebch16_7", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "sebch16_7", -1);

            break;

         /* golay24_12 */
         case 1:
            rtInvokeStartElement (pctxt, "golay24_12", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "golay24_12", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223AL3MParameters_crcLength                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223AL3MParameters_crcLength (OOCTXT* pctxt, H245H223AL3MParameters_crcLength* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* crc4bit */
         case 0:
            rtInvokeStartElement (pctxt, "crc4bit", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "crc4bit", -1);

            break;

         /* crc12bit */
         case 1:
            rtInvokeStartElement (pctxt, "crc12bit", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "crc12bit", -1);

            break;

         /* crc20bit */
         case 2:
            rtInvokeStartElement (pctxt, "crc20bit", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "crc20bit", -1);

            break;

         /* crc28bit */
         case 3:
            rtInvokeStartElement (pctxt, "crc28bit", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "crc28bit", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* crc8bit */
         case 5:
            rtInvokeStartElement (pctxt, "crc8bit", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "crc8bit", -1);

            break;

         /* crc16bit */
         case 6:
            rtInvokeStartElement (pctxt, "crc16bit", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "crc16bit", -1);

            break;

         /* crc32bit */
         case 7:
            rtInvokeStartElement (pctxt, "crc32bit", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "crc32bit", -1);

            break;

         /* crcNotUsed */
         case 8:
            rtInvokeStartElement (pctxt, "crcNotUsed", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "crcNotUsed", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223AL3MParameters_arqType                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223AL3MParameters_arqType (OOCTXT* pctxt, H245H223AL3MParameters_arqType* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* noArq */
         case 0:
            rtInvokeStartElement (pctxt, "noArq", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "noArq", -1);

            break;

         /* typeIArq */
         case 1:
            rtInvokeStartElement (pctxt, "typeIArq", -1);

            pvalue->u.typeIArq = ALLOC_ASN1ELEM (pctxt, H245H223AnnexCArqParameters);
            if (pvalue->u.typeIArq == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H223AnnexCArqParameters (pctxt, pvalue->u.typeIArq);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "typeIArq", -1);

            break;

         /* typeIIArq */
         case 2:
            rtInvokeStartElement (pctxt, "typeIIArq", -1);

            pvalue->u.typeIIArq = ALLOC_ASN1ELEM (pctxt, H245H223AnnexCArqParameters);
            if (pvalue->u.typeIIArq == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H223AnnexCArqParameters (pctxt, pvalue->u.typeIIArq);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "typeIIArq", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223AL3MParameters                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223AL3MParameters (OOCTXT* pctxt, H245H223AL3MParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   /* decode headerFormat */

   rtInvokeStartElement (pctxt, "headerFormat", -1);

   stat = asn1PD_H245H223AL3MParameters_headerFormat (pctxt, &pvalue->headerFormat);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "headerFormat", -1);

   /* decode crcLength */

   rtInvokeStartElement (pctxt, "crcLength", -1);

   stat = asn1PD_H245H223AL3MParameters_crcLength (pctxt, &pvalue->crcLength);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "crcLength", -1);

   /* decode rcpcCodeRate */

   rtInvokeStartElement (pctxt, "rcpcCodeRate", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->rcpcCodeRate, 8U, 32U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->rcpcCodeRate);

   rtInvokeEndElement (pctxt, "rcpcCodeRate", -1);

   /* decode arqType */

   rtInvokeStartElement (pctxt, "arqType", -1);

   stat = asn1PD_H245H223AL3MParameters_arqType (pctxt, &pvalue->arqType);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "arqType", -1);

   /* decode alpduInterleaving */

   rtInvokeStartElement (pctxt, "alpduInterleaving", -1);

   stat = DECODEBIT (pctxt, &pvalue->alpduInterleaving);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->alpduInterleaving);

   rtInvokeEndElement (pctxt, "alpduInterleaving", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 1 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.rsCodeCorrectionPresent = 1;

                     rtInvokeStartElement (pctxt, "rsCodeCorrection", -1);

                     stat = decodeConsUInt8 (pctxt, &pvalue->rsCodeCorrection, 0U, 127U);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeUIntValue (pctxt, pvalue->rsCodeCorrection);

                     rtInvokeEndElement (pctxt, "rsCodeCorrection", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 1) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223LogicalChannelParameters_adaptationLayerType          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223LogicalChannelParameters_adaptationLayerType (OOCTXT* pctxt, H245H223LogicalChannelParameters_adaptationLayerType* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 5);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* al1Framed */
         case 1:
            rtInvokeStartElement (pctxt, "al1Framed", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "al1Framed", -1);

            break;

         /* al1NotFramed */
         case 2:
            rtInvokeStartElement (pctxt, "al1NotFramed", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "al1NotFramed", -1);

            break;

         /* al2WithoutSequenceNumbers */
         case 3:
            rtInvokeStartElement (pctxt, "al2WithoutSequenceNumbers", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "al2WithoutSequenceNumbers", -1);

            break;

         /* al2WithSequenceNumbers */
         case 4:
            rtInvokeStartElement (pctxt, "al2WithSequenceNumbers", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "al2WithSequenceNumbers", -1);

            break;

         /* al3 */
         case 5:
            rtInvokeStartElement (pctxt, "al3", -1);

            pvalue->u.al3 = ALLOC_ASN1ELEM (pctxt, H245H223LogicalChannelParameters_adaptationLayerType_al3);
            if (pvalue->u.al3 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H223LogicalChannelParameters_adaptationLayerType_al3 (pctxt, pvalue->u.al3);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "al3", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 7;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* al1M */
         case 7:
            rtInvokeStartElement (pctxt, "al1M", -1);

            pvalue->u.al1M = ALLOC_ASN1ELEM (pctxt, H245H223AL1MParameters);
            if (pvalue->u.al1M == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H223AL1MParameters (pctxt, pvalue->u.al1M);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "al1M", -1);

            break;

         /* al2M */
         case 8:
            rtInvokeStartElement (pctxt, "al2M", -1);

            pvalue->u.al2M = ALLOC_ASN1ELEM (pctxt, H245H223AL2MParameters);
            if (pvalue->u.al2M == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H223AL2MParameters (pctxt, pvalue->u.al2M);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "al2M", -1);

            break;

         /* al3M */
         case 9:
            rtInvokeStartElement (pctxt, "al3M", -1);

            pvalue->u.al3M = ALLOC_ASN1ELEM (pctxt, H245H223AL3MParameters);
            if (pvalue->u.al3M == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H223AL3MParameters (pctxt, pvalue->u.al3M);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "al3M", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223LogicalChannelParameters                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223LogicalChannelParameters (OOCTXT* pctxt, H245H223LogicalChannelParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode adaptationLayerType */

   rtInvokeStartElement (pctxt, "adaptationLayerType", -1);

   stat = asn1PD_H245H223LogicalChannelParameters_adaptationLayerType (pctxt, &pvalue->adaptationLayerType);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "adaptationLayerType", -1);

   /* decode segmentableFlag */

   rtInvokeStartElement (pctxt, "segmentableFlag", -1);

   stat = DECODEBIT (pctxt, &pvalue->segmentableFlag);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->segmentableFlag);

   rtInvokeEndElement (pctxt, "segmentableFlag", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CRCLength                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CRCLength (OOCTXT* pctxt, H245CRCLength* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* crc8bit */
         case 0:
            rtInvokeStartElement (pctxt, "crc8bit", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "crc8bit", -1);

            break;

         /* crc16bit */
         case 1:
            rtInvokeStartElement (pctxt, "crc16bit", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "crc16bit", -1);

            break;

         /* crc32bit */
         case 2:
            rtInvokeStartElement (pctxt, "crc32bit", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "crc32bit", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  V76HDLCParameters                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245V76HDLCParameters (OOCTXT* pctxt, H245V76HDLCParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode crcLength */

   rtInvokeStartElement (pctxt, "crcLength", -1);

   stat = asn1PD_H245CRCLength (pctxt, &pvalue->crcLength);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "crcLength", -1);

   /* decode n401 */

   rtInvokeStartElement (pctxt, "n401", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->n401, 1U, 4095U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->n401);

   rtInvokeEndElement (pctxt, "n401", -1);

   /* decode loopbackTestProcedure */

   rtInvokeStartElement (pctxt, "loopbackTestProcedure", -1);

   stat = DECODEBIT (pctxt, &pvalue->loopbackTestProcedure);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->loopbackTestProcedure);

   rtInvokeEndElement (pctxt, "loopbackTestProcedure", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  V76LogicalChannelParameters_suspendResume                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245V76LogicalChannelParameters_suspendResume (OOCTXT* pctxt, H245V76LogicalChannelParameters_suspendResume* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* noSuspendResume */
         case 0:
            rtInvokeStartElement (pctxt, "noSuspendResume", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "noSuspendResume", -1);

            break;

         /* suspendResumewAddress */
         case 1:
            rtInvokeStartElement (pctxt, "suspendResumewAddress", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "suspendResumewAddress", -1);

            break;

         /* suspendResumewoAddress */
         case 2:
            rtInvokeStartElement (pctxt, "suspendResumewoAddress", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "suspendResumewoAddress", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  V76LogicalChannelParameters_mode_eRM_recovery             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245V76LogicalChannelParameters_mode_eRM_recovery (OOCTXT* pctxt, H245V76LogicalChannelParameters_mode_eRM_recovery* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* rej */
         case 0:
            rtInvokeStartElement (pctxt, "rej", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "rej", -1);

            break;

         /* sREJ */
         case 1:
            rtInvokeStartElement (pctxt, "sREJ", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "sREJ", -1);

            break;

         /* mSREJ */
         case 2:
            rtInvokeStartElement (pctxt, "mSREJ", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "mSREJ", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  V76LogicalChannelParameters_mode_eRM                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245V76LogicalChannelParameters_mode_eRM (OOCTXT* pctxt, H245V76LogicalChannelParameters_mode_eRM* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode windowSize */

   rtInvokeStartElement (pctxt, "windowSize", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->windowSize, 1U, 127U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->windowSize);

   rtInvokeEndElement (pctxt, "windowSize", -1);

   /* decode recovery */

   rtInvokeStartElement (pctxt, "recovery", -1);

   stat = asn1PD_H245V76LogicalChannelParameters_mode_eRM_recovery (pctxt, &pvalue->recovery);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "recovery", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  V76LogicalChannelParameters_mode                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245V76LogicalChannelParameters_mode (OOCTXT* pctxt, H245V76LogicalChannelParameters_mode* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* eRM */
         case 0:
            rtInvokeStartElement (pctxt, "eRM", -1);

            pvalue->u.eRM = ALLOC_ASN1ELEM (pctxt, H245V76LogicalChannelParameters_mode_eRM);
            if (pvalue->u.eRM == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245V76LogicalChannelParameters_mode_eRM (pctxt, pvalue->u.eRM);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "eRM", -1);

            break;

         /* uNERM */
         case 1:
            rtInvokeStartElement (pctxt, "uNERM", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "uNERM", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  V75Parameters                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245V75Parameters (OOCTXT* pctxt, H245V75Parameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode audioHeaderPresent */

   rtInvokeStartElement (pctxt, "audioHeaderPresent", -1);

   stat = DECODEBIT (pctxt, &pvalue->audioHeaderPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->audioHeaderPresent);

   rtInvokeEndElement (pctxt, "audioHeaderPresent", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  V76LogicalChannelParameters                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245V76LogicalChannelParameters (OOCTXT* pctxt, H245V76LogicalChannelParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode hdlcParameters */

   rtInvokeStartElement (pctxt, "hdlcParameters", -1);

   stat = asn1PD_H245V76HDLCParameters (pctxt, &pvalue->hdlcParameters);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "hdlcParameters", -1);

   /* decode suspendResume */

   rtInvokeStartElement (pctxt, "suspendResume", -1);

   stat = asn1PD_H245V76LogicalChannelParameters_suspendResume (pctxt, &pvalue->suspendResume);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "suspendResume", -1);

   /* decode uIH */

   rtInvokeStartElement (pctxt, "uIH", -1);

   stat = DECODEBIT (pctxt, &pvalue->uIH);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->uIH);

   rtInvokeEndElement (pctxt, "uIH", -1);

   /* decode mode */

   rtInvokeStartElement (pctxt, "mode", -1);

   stat = asn1PD_H245V76LogicalChannelParameters_mode (pctxt, &pvalue->mode);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "mode", -1);

   /* decode v75Parameters */

   rtInvokeStartElement (pctxt, "v75Parameters", -1);

   stat = asn1PD_H245V75Parameters (pctxt, &pvalue->v75Parameters);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "v75Parameters", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnicastAddress_iPAddress                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245UnicastAddress_iPAddress (OOCTXT* pctxt, H245UnicastAddress_iPAddress* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode network */

   rtInvokeStartElement (pctxt, "network", -1);

   stat = asn1PD_H245UnicastAddress_iPAddress_network (pctxt, &pvalue->network);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "network", -1);

   /* decode tsapIdentifier */

   rtInvokeStartElement (pctxt, "tsapIdentifier", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->tsapIdentifier, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->tsapIdentifier);

   rtInvokeEndElement (pctxt, "tsapIdentifier", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnicastAddress_iPXAddress                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245UnicastAddress_iPXAddress (OOCTXT* pctxt, H245UnicastAddress_iPXAddress* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode node */

   rtInvokeStartElement (pctxt, "node", -1);

   stat = asn1PD_H245UnicastAddress_iPXAddress_node (pctxt, &pvalue->node);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "node", -1);

   /* decode netnum */

   rtInvokeStartElement (pctxt, "netnum", -1);

   stat = asn1PD_H245UnicastAddress_iPXAddress_netnum (pctxt, &pvalue->netnum);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "netnum", -1);

   /* decode tsapIdentifier */

   rtInvokeStartElement (pctxt, "tsapIdentifier", -1);

   stat = asn1PD_H245UnicastAddress_iPXAddress_tsapIdentifier (pctxt, &pvalue->tsapIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "tsapIdentifier", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnicastAddress_iP6Address                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245UnicastAddress_iP6Address (OOCTXT* pctxt, H245UnicastAddress_iP6Address* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode network */

   rtInvokeStartElement (pctxt, "network", -1);

   stat = asn1PD_H245UnicastAddress_iP6Address_network (pctxt, &pvalue->network);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "network", -1);

   /* decode tsapIdentifier */

   rtInvokeStartElement (pctxt, "tsapIdentifier", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->tsapIdentifier, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->tsapIdentifier);

   rtInvokeEndElement (pctxt, "tsapIdentifier", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnicastAddress_iPSourceRouteAddress_routing               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245UnicastAddress_iPSourceRouteAddress_routing (OOCTXT* pctxt, H245UnicastAddress_iPSourceRouteAddress_routing* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* strict */
      case 0:
         rtInvokeStartElement (pctxt, "strict", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "strict", -1);

         break;

      /* loose */
      case 1:
         rtInvokeStartElement (pctxt, "loose", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "loose", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH245UnicastAddress_iPSourceRouteAddress_route_elem  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245_SeqOfH245UnicastAddress_iPSourceRouteAddress_route_element (OOCTXT* pctxt, H245_SeqOfH245UnicastAddress_iPSourceRouteAddress_route_element* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, H245UnicastAddress_iPSourceRouteAddress_route_element);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      stat = asn1PD_H245UnicastAddress_iPSourceRouteAddress_route_element (pctxt, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnicastAddress_iPSourceRouteAddress                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245UnicastAddress_iPSourceRouteAddress (OOCTXT* pctxt, H245UnicastAddress_iPSourceRouteAddress* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode routing */

   rtInvokeStartElement (pctxt, "routing", -1);

   stat = asn1PD_H245UnicastAddress_iPSourceRouteAddress_routing (pctxt, &pvalue->routing);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "routing", -1);

   /* decode network */

   rtInvokeStartElement (pctxt, "network", -1);

   stat = asn1PD_H245UnicastAddress_iPSourceRouteAddress_network (pctxt, &pvalue->network);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "network", -1);

   /* decode tsapIdentifier */

   rtInvokeStartElement (pctxt, "tsapIdentifier", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->tsapIdentifier, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->tsapIdentifier);

   rtInvokeEndElement (pctxt, "tsapIdentifier", -1);

   /* decode route */

   rtInvokeStartElement (pctxt, "route", -1);

   stat = asn1PD_H245_SeqOfH245UnicastAddress_iPSourceRouteAddress_route_element (pctxt, &pvalue->route);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "route", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnicastAddress                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245UnicastAddress (OOCTXT* pctxt, H245UnicastAddress* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 4);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* iPAddress */
         case 0:
            rtInvokeStartElement (pctxt, "iPAddress", -1);

            pvalue->u.iPAddress = ALLOC_ASN1ELEM (pctxt, H245UnicastAddress_iPAddress);
            if (pvalue->u.iPAddress == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245UnicastAddress_iPAddress (pctxt, pvalue->u.iPAddress);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "iPAddress", -1);

            break;

         /* iPXAddress */
         case 1:
            rtInvokeStartElement (pctxt, "iPXAddress", -1);

            pvalue->u.iPXAddress = ALLOC_ASN1ELEM (pctxt, H245UnicastAddress_iPXAddress);
            if (pvalue->u.iPXAddress == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245UnicastAddress_iPXAddress (pctxt, pvalue->u.iPXAddress);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "iPXAddress", -1);

            break;

         /* iP6Address */
         case 2:
            rtInvokeStartElement (pctxt, "iP6Address", -1);

            pvalue->u.iP6Address = ALLOC_ASN1ELEM (pctxt, H245UnicastAddress_iP6Address);
            if (pvalue->u.iP6Address == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245UnicastAddress_iP6Address (pctxt, pvalue->u.iP6Address);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "iP6Address", -1);

            break;

         /* netBios */
         case 3:
            rtInvokeStartElement (pctxt, "netBios", -1);

            pvalue->u.netBios = ALLOC_ASN1ELEM (pctxt, H245UnicastAddress_netBios);
            if (pvalue->u.netBios == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245UnicastAddress_netBios (pctxt, pvalue->u.netBios);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "netBios", -1);

            break;

         /* iPSourceRouteAddress */
         case 4:
            rtInvokeStartElement (pctxt, "iPSourceRouteAddress", -1);

            pvalue->u.iPSourceRouteAddress = ALLOC_ASN1ELEM (pctxt, H245UnicastAddress_iPSourceRouteAddress);
            if (pvalue->u.iPSourceRouteAddress == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245UnicastAddress_iPSourceRouteAddress (pctxt, pvalue->u.iPSourceRouteAddress);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "iPSourceRouteAddress", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 6;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* nsap */
         case 6:
            rtInvokeStartElement (pctxt, "nsap", -1);

            pvalue->u.nsap = ALLOC_ASN1ELEM (pctxt, H245UnicastAddress_nsap);
            if (pvalue->u.nsap == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245UnicastAddress_nsap (pctxt, pvalue->u.nsap);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nsap", -1);

            break;

         /* nonStandardAddress */
         case 7:
            rtInvokeStartElement (pctxt, "nonStandardAddress", -1);

            pvalue->u.nonStandardAddress = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandardAddress == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandardAddress);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandardAddress", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MulticastAddress_iPAddress                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MulticastAddress_iPAddress (OOCTXT* pctxt, H245MulticastAddress_iPAddress* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode network */

   rtInvokeStartElement (pctxt, "network", -1);

   stat = asn1PD_H245MulticastAddress_iPAddress_network (pctxt, &pvalue->network);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "network", -1);

   /* decode tsapIdentifier */

   rtInvokeStartElement (pctxt, "tsapIdentifier", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->tsapIdentifier, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->tsapIdentifier);

   rtInvokeEndElement (pctxt, "tsapIdentifier", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MulticastAddress_iP6Address                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MulticastAddress_iP6Address (OOCTXT* pctxt, H245MulticastAddress_iP6Address* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode network */

   rtInvokeStartElement (pctxt, "network", -1);

   stat = asn1PD_H245MulticastAddress_iP6Address_network (pctxt, &pvalue->network);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "network", -1);

   /* decode tsapIdentifier */

   rtInvokeStartElement (pctxt, "tsapIdentifier", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->tsapIdentifier, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->tsapIdentifier);

   rtInvokeEndElement (pctxt, "tsapIdentifier", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MulticastAddress                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MulticastAddress (OOCTXT* pctxt, H245MulticastAddress* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* iPAddress */
         case 0:
            rtInvokeStartElement (pctxt, "iPAddress", -1);

            pvalue->u.iPAddress = ALLOC_ASN1ELEM (pctxt, H245MulticastAddress_iPAddress);
            if (pvalue->u.iPAddress == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MulticastAddress_iPAddress (pctxt, pvalue->u.iPAddress);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "iPAddress", -1);

            break;

         /* iP6Address */
         case 1:
            rtInvokeStartElement (pctxt, "iP6Address", -1);

            pvalue->u.iP6Address = ALLOC_ASN1ELEM (pctxt, H245MulticastAddress_iP6Address);
            if (pvalue->u.iP6Address == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MulticastAddress_iP6Address (pctxt, pvalue->u.iP6Address);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "iP6Address", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* nsap */
         case 3:
            rtInvokeStartElement (pctxt, "nsap", -1);

            pvalue->u.nsap = ALLOC_ASN1ELEM (pctxt, H245MulticastAddress_nsap);
            if (pvalue->u.nsap == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MulticastAddress_nsap (pctxt, pvalue->u.nsap);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nsap", -1);

            break;

         /* nonStandardAddress */
         case 4:
            rtInvokeStartElement (pctxt, "nonStandardAddress", -1);

            pvalue->u.nonStandardAddress = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandardAddress == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandardAddress);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandardAddress", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportAddress                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245TransportAddress (OOCTXT* pctxt, H245TransportAddress* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* unicastAddress */
         case 0:
            rtInvokeStartElement (pctxt, "unicastAddress", -1);

            pvalue->u.unicastAddress = ALLOC_ASN1ELEM (pctxt, H245UnicastAddress);
            if (pvalue->u.unicastAddress == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245UnicastAddress (pctxt, pvalue->u.unicastAddress);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "unicastAddress", -1);

            break;

         /* multicastAddress */
         case 1:
            rtInvokeStartElement (pctxt, "multicastAddress", -1);

            pvalue->u.multicastAddress = ALLOC_ASN1ELEM (pctxt, H245MulticastAddress);
            if (pvalue->u.multicastAddress == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MulticastAddress (pctxt, pvalue->u.multicastAddress);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "multicastAddress", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalLabel                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245TerminalLabel (OOCTXT* pctxt, H245TerminalLabel* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode mcuNumber */

   rtInvokeStartElement (pctxt, "mcuNumber", -1);

   stat = asn1PD_H245McuNumber (pctxt, &pvalue->mcuNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "mcuNumber", -1);

   /* decode terminalNumber */

   rtInvokeStartElement (pctxt, "terminalNumber", -1);

   stat = asn1PD_H245TerminalNumber (pctxt, &pvalue->terminalNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "terminalNumber", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H2250LogicalChannelParameters_mediaPacketization          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H2250LogicalChannelParameters_mediaPacketization (OOCTXT* pctxt, H245H2250LogicalChannelParameters_mediaPacketization* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* h261aVideoPacketization */
         case 0:
            rtInvokeStartElement (pctxt, "h261aVideoPacketization", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "h261aVideoPacketization", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* rtpPayloadType */
         case 2:
            rtInvokeStartElement (pctxt, "rtpPayloadType", -1);

            pvalue->u.rtpPayloadType = ALLOC_ASN1ELEM (pctxt, H245RTPPayloadType);
            if (pvalue->u.rtpPayloadType == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RTPPayloadType (pctxt, pvalue->u.rtpPayloadType);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "rtpPayloadType", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H2250LogicalChannelParameters                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H2250LogicalChannelParameters (OOCTXT* pctxt, H245H2250LogicalChannelParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.associatedSessionIDPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mediaChannelPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mediaGuaranteedDeliveryPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mediaControlChannelPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mediaControlGuaranteedDeliveryPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.silenceSuppressionPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.destinationPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dynamicRTPPayloadTypePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mediaPacketizationPresent = optbit;

   /* decode nonStandard */

   if (pvalue->m.nonStandardPresent) {
      rtInvokeStartElement (pctxt, "nonStandard", -1);

      stat = asn1PD_H245_SeqOfH245NonStandardParameter (pctxt, &pvalue->nonStandard);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "nonStandard", -1);
   }

   /* decode sessionID */

   rtInvokeStartElement (pctxt, "sessionID", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->sessionID, 0U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->sessionID);

   rtInvokeEndElement (pctxt, "sessionID", -1);

   /* decode associatedSessionID */

   if (pvalue->m.associatedSessionIDPresent) {
      rtInvokeStartElement (pctxt, "associatedSessionID", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->associatedSessionID, 1U, 255U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->associatedSessionID);

      rtInvokeEndElement (pctxt, "associatedSessionID", -1);
   }

   /* decode mediaChannel */

   if (pvalue->m.mediaChannelPresent) {
      rtInvokeStartElement (pctxt, "mediaChannel", -1);

      stat = asn1PD_H245TransportAddress (pctxt, &pvalue->mediaChannel);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "mediaChannel", -1);
   }

   /* decode mediaGuaranteedDelivery */

   if (pvalue->m.mediaGuaranteedDeliveryPresent) {
      rtInvokeStartElement (pctxt, "mediaGuaranteedDelivery", -1);

      stat = DECODEBIT (pctxt, &pvalue->mediaGuaranteedDelivery);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeBoolValue (pctxt, pvalue->mediaGuaranteedDelivery);

      rtInvokeEndElement (pctxt, "mediaGuaranteedDelivery", -1);
   }

   /* decode mediaControlChannel */

   if (pvalue->m.mediaControlChannelPresent) {
      rtInvokeStartElement (pctxt, "mediaControlChannel", -1);

      stat = asn1PD_H245TransportAddress (pctxt, &pvalue->mediaControlChannel);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "mediaControlChannel", -1);
   }

   /* decode mediaControlGuaranteedDelivery */

   if (pvalue->m.mediaControlGuaranteedDeliveryPresent) {
      rtInvokeStartElement (pctxt, "mediaControlGuaranteedDelivery", -1);

      stat = DECODEBIT (pctxt, &pvalue->mediaControlGuaranteedDelivery);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeBoolValue (pctxt, pvalue->mediaControlGuaranteedDelivery);

      rtInvokeEndElement (pctxt, "mediaControlGuaranteedDelivery", -1);
   }

   /* decode silenceSuppression */

   if (pvalue->m.silenceSuppressionPresent) {
      rtInvokeStartElement (pctxt, "silenceSuppression", -1);

      stat = DECODEBIT (pctxt, &pvalue->silenceSuppression);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeBoolValue (pctxt, pvalue->silenceSuppression);

      rtInvokeEndElement (pctxt, "silenceSuppression", -1);
   }

   /* decode destination */

   if (pvalue->m.destinationPresent) {
      rtInvokeStartElement (pctxt, "destination", -1);

      stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->destination);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "destination", -1);
   }

   /* decode dynamicRTPPayloadType */

   if (pvalue->m.dynamicRTPPayloadTypePresent) {
      rtInvokeStartElement (pctxt, "dynamicRTPPayloadType", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->dynamicRTPPayloadType, 96U, 127U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->dynamicRTPPayloadType);

      rtInvokeEndElement (pctxt, "dynamicRTPPayloadType", -1);
   }

   /* decode mediaPacketization */

   if (pvalue->m.mediaPacketizationPresent) {
      rtInvokeStartElement (pctxt, "mediaPacketization", -1);

      stat = asn1PD_H245H2250LogicalChannelParameters_mediaPacketization (pctxt, &pvalue->mediaPacketization);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "mediaPacketization", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 3 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.transportCapabilityPresent = 1;

                     rtInvokeStartElement (pctxt, "transportCapability", -1);

                     stat = asn1PD_H245TransportCapability (pctxt, &pvalue->transportCapability);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "transportCapability", -1);
                     break;

                  case 1:
                     pvalue->m.redundancyEncodingPresent = 1;

                     rtInvokeStartElement (pctxt, "redundancyEncoding", -1);

                     stat = asn1PD_H245RedundancyEncoding (pctxt, &pvalue->redundancyEncoding);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "redundancyEncoding", -1);
                     break;

                  case 2:
                     pvalue->m.sourcePresent = 1;

                     rtInvokeStartElement (pctxt, "source", -1);

                     stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->source);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "source", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 3) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OpenLogicalChannel_forwardLogicalChannelParameters_multi  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters (OOCTXT* pctxt, H245OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* h222LogicalChannelParameters */
         case 0:
            rtInvokeStartElement (pctxt, "h222LogicalChannelParameters", -1);

            pvalue->u.h222LogicalChannelParameters = ALLOC_ASN1ELEM (pctxt, H245H222LogicalChannelParameters);
            if (pvalue->u.h222LogicalChannelParameters == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H222LogicalChannelParameters (pctxt, pvalue->u.h222LogicalChannelParameters);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h222LogicalChannelParameters", -1);

            break;

         /* h223LogicalChannelParameters */
         case 1:
            rtInvokeStartElement (pctxt, "h223LogicalChannelParameters", -1);

            pvalue->u.h223LogicalChannelParameters = ALLOC_ASN1ELEM (pctxt, H245H223LogicalChannelParameters);
            if (pvalue->u.h223LogicalChannelParameters == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H223LogicalChannelParameters (pctxt, pvalue->u.h223LogicalChannelParameters);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h223LogicalChannelParameters", -1);

            break;

         /* v76LogicalChannelParameters */
         case 2:
            rtInvokeStartElement (pctxt, "v76LogicalChannelParameters", -1);

            pvalue->u.v76LogicalChannelParameters = ALLOC_ASN1ELEM (pctxt, H245V76LogicalChannelParameters);
            if (pvalue->u.v76LogicalChannelParameters == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245V76LogicalChannelParameters (pctxt, pvalue->u.v76LogicalChannelParameters);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "v76LogicalChannelParameters", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* h2250LogicalChannelParameters */
         case 4:
            rtInvokeStartElement (pctxt, "h2250LogicalChannelParameters", -1);

            pvalue->u.h2250LogicalChannelParameters = ALLOC_ASN1ELEM (pctxt, H245H2250LogicalChannelParameters);
            if (pvalue->u.h2250LogicalChannelParameters == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H2250LogicalChannelParameters (pctxt, pvalue->u.h2250LogicalChannelParameters);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h2250LogicalChannelParameters", -1);

            break;

         /* none */
         case 5:
            rtInvokeStartElement (pctxt, "none", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "none", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OpenLogicalChannel_forwardLogicalChannelParameters        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245OpenLogicalChannel_forwardLogicalChannelParameters (OOCTXT* pctxt, H245OpenLogicalChannel_forwardLogicalChannelParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.portNumberPresent = optbit;

   /* decode portNumber */

   if (pvalue->m.portNumberPresent) {
      rtInvokeStartElement (pctxt, "portNumber", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->portNumber, 0U, 65535U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->portNumber);

      rtInvokeEndElement (pctxt, "portNumber", -1);
   }

   /* decode dataType */

   rtInvokeStartElement (pctxt, "dataType", -1);

   stat = asn1PD_H245DataType (pctxt, &pvalue->dataType);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "dataType", -1);

   /* decode multiplexParameters */

   rtInvokeStartElement (pctxt, "multiplexParameters", -1);

   stat = asn1PD_H245OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters (pctxt, &pvalue->multiplexParameters);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "multiplexParameters", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 2 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.forwardLogicalChannelDependencyPresent = 1;

                     rtInvokeStartElement (pctxt, "forwardLogicalChannelDependency", -1);

                     stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->forwardLogicalChannelDependency);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "forwardLogicalChannelDependency", -1);
                     break;

                  case 1:
                     pvalue->m.replacementForPresent = 1;

                     rtInvokeStartElement (pctxt, "replacementFor", -1);

                     stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->replacementFor);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "replacementFor", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 2) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OpenLogicalChannel_reverseLogicalChannelParameters_multi  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters (OOCTXT* pctxt, H245OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* h223LogicalChannelParameters */
         case 0:
            rtInvokeStartElement (pctxt, "h223LogicalChannelParameters", -1);

            pvalue->u.h223LogicalChannelParameters = ALLOC_ASN1ELEM (pctxt, H245H223LogicalChannelParameters);
            if (pvalue->u.h223LogicalChannelParameters == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H223LogicalChannelParameters (pctxt, pvalue->u.h223LogicalChannelParameters);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h223LogicalChannelParameters", -1);

            break;

         /* v76LogicalChannelParameters */
         case 1:
            rtInvokeStartElement (pctxt, "v76LogicalChannelParameters", -1);

            pvalue->u.v76LogicalChannelParameters = ALLOC_ASN1ELEM (pctxt, H245V76LogicalChannelParameters);
            if (pvalue->u.v76LogicalChannelParameters == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245V76LogicalChannelParameters (pctxt, pvalue->u.v76LogicalChannelParameters);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "v76LogicalChannelParameters", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* h2250LogicalChannelParameters */
         case 3:
            rtInvokeStartElement (pctxt, "h2250LogicalChannelParameters", -1);

            pvalue->u.h2250LogicalChannelParameters = ALLOC_ASN1ELEM (pctxt, H245H2250LogicalChannelParameters);
            if (pvalue->u.h2250LogicalChannelParameters == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H2250LogicalChannelParameters (pctxt, pvalue->u.h2250LogicalChannelParameters);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h2250LogicalChannelParameters", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OpenLogicalChannel_reverseLogicalChannelParameters        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245OpenLogicalChannel_reverseLogicalChannelParameters (OOCTXT* pctxt, H245OpenLogicalChannel_reverseLogicalChannelParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.multiplexParametersPresent = optbit;

   /* decode dataType */

   rtInvokeStartElement (pctxt, "dataType", -1);

   stat = asn1PD_H245DataType (pctxt, &pvalue->dataType);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "dataType", -1);

   /* decode multiplexParameters */

   if (pvalue->m.multiplexParametersPresent) {
      rtInvokeStartElement (pctxt, "multiplexParameters", -1);

      stat = asn1PD_H245OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters (pctxt, &pvalue->multiplexParameters);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "multiplexParameters", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 2 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.reverseLogicalChannelDependencyPresent = 1;

                     rtInvokeStartElement (pctxt, "reverseLogicalChannelDependency", -1);

                     stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->reverseLogicalChannelDependency);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "reverseLogicalChannelDependency", -1);
                     break;

                  case 1:
                     pvalue->m.replacementForPresent = 1;

                     rtInvokeStartElement (pctxt, "replacementFor", -1);

                     stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->replacementFor);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "replacementFor", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 2) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NetworkAccessParameters_distribution                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NetworkAccessParameters_distribution (OOCTXT* pctxt, H245NetworkAccessParameters_distribution* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* unicast */
         case 0:
            rtInvokeStartElement (pctxt, "unicast", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "unicast", -1);

            break;

         /* multicast */
         case 1:
            rtInvokeStartElement (pctxt, "multicast", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "multicast", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NetworkAccessParameters_networkAddress                    */
/*                                                            */
/**************************************************************/

extern EXTERN const char* gs_MULTIMEDIA_SYSTEM_CONTROL_NetworkAccessParameters_networkAddress_e164Address_CharSet;

EXTERN int asn1PD_H245NetworkAccessParameters_networkAddress (OOCTXT* pctxt, H245NetworkAccessParameters_networkAddress* pvalue)
{
   static Asn1SizeCnst e164Address_lsize1 = { 0, 1, 128, 0 };
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* q2931Address */
         case 0:
            rtInvokeStartElement (pctxt, "q2931Address", -1);

            pvalue->u.q2931Address = ALLOC_ASN1ELEM (pctxt, H245Q2931Address);
            if (pvalue->u.q2931Address == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245Q2931Address (pctxt, pvalue->u.q2931Address);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "q2931Address", -1);

            break;

         /* e164Address */
         case 1:
            rtInvokeStartElement (pctxt, "e164Address", -1);

            stat = addSizeConstraint (pctxt, &e164Address_lsize1);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            stat = decodeConstrainedStringEx (pctxt, &pvalue->u.e164Address, gs_MULTIMEDIA_SYSTEM_CONTROL_NetworkAccessParameters_networkAddress_e164Address_CharSet, 4, 4, 7);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeCharStrValue (pctxt, pvalue->u.e164Address);

            rtInvokeEndElement (pctxt, "e164Address", -1);

            break;

         /* localAreaAddress */
         case 2:
            rtInvokeStartElement (pctxt, "localAreaAddress", -1);

            pvalue->u.localAreaAddress = ALLOC_ASN1ELEM (pctxt, H245TransportAddress);
            if (pvalue->u.localAreaAddress == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245TransportAddress (pctxt, pvalue->u.localAreaAddress);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "localAreaAddress", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NetworkAccessParameters_t120SetupProcedure                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NetworkAccessParameters_t120SetupProcedure (OOCTXT* pctxt, H245NetworkAccessParameters_t120SetupProcedure* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* originateCall */
         case 0:
            rtInvokeStartElement (pctxt, "originateCall", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "originateCall", -1);

            break;

         /* waitForCall */
         case 1:
            rtInvokeStartElement (pctxt, "waitForCall", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "waitForCall", -1);

            break;

         /* issueQuery */
         case 2:
            rtInvokeStartElement (pctxt, "issueQuery", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "issueQuery", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NetworkAccessParameters                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NetworkAccessParameters (OOCTXT* pctxt, H245NetworkAccessParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.distributionPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.externalReferencePresent = optbit;

   /* decode distribution */

   if (pvalue->m.distributionPresent) {
      rtInvokeStartElement (pctxt, "distribution", -1);

      stat = asn1PD_H245NetworkAccessParameters_distribution (pctxt, &pvalue->distribution);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "distribution", -1);
   }

   /* decode networkAddress */

   rtInvokeStartElement (pctxt, "networkAddress", -1);

   stat = asn1PD_H245NetworkAccessParameters_networkAddress (pctxt, &pvalue->networkAddress);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "networkAddress", -1);

   /* decode associateConference */

   rtInvokeStartElement (pctxt, "associateConference", -1);

   stat = DECODEBIT (pctxt, &pvalue->associateConference);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->associateConference);

   rtInvokeEndElement (pctxt, "associateConference", -1);

   /* decode externalReference */

   if (pvalue->m.externalReferencePresent) {
      rtInvokeStartElement (pctxt, "externalReference", -1);

      stat = asn1PD_H245NetworkAccessParameters_externalReference (pctxt, &pvalue->externalReference);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "externalReference", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 1 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.t120SetupProcedurePresent = 1;

                     rtInvokeStartElement (pctxt, "t120SetupProcedure", -1);

                     stat = asn1PD_H245NetworkAccessParameters_t120SetupProcedure (pctxt, &pvalue->t120SetupProcedure);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "t120SetupProcedure", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 1) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EscrowData                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245EscrowData (OOCTXT* pctxt, H245EscrowData* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode escrowID */

   rtInvokeStartElement (pctxt, "escrowID", -1);

   stat = decodeObjectIdentifier (pctxt, &pvalue->escrowID);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOidValue (pctxt, pvalue->escrowID.numids, pvalue->escrowID.subid);

   rtInvokeEndElement (pctxt, "escrowID", -1);

   /* decode escrowValue */

   rtInvokeStartElement (pctxt, "escrowValue", -1);

   stat = asn1PD_H245EscrowData_escrowValue (pctxt, &pvalue->escrowValue);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "escrowValue", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncryptionSync_escrowentry                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245EncryptionSync_escrowentry (OOCTXT* pctxt, H245EncryptionSync_escrowentry* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   H245EscrowData* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245EscrowData);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245EscrowData (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncryptionSync                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245EncryptionSync (OOCTXT* pctxt, H245EncryptionSync* pvalue)
{
   static Asn1SizeCnst h235Key_lsize1 = { 0, 1, 65535, 0 };
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.escrowentryPresent = optbit;

   /* decode nonStandard */

   if (pvalue->m.nonStandardPresent) {
      rtInvokeStartElement (pctxt, "nonStandard", -1);

      stat = asn1PD_H245NonStandardParameter (pctxt, &pvalue->nonStandard);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "nonStandard", -1);
   }

   /* decode synchFlag */

   rtInvokeStartElement (pctxt, "synchFlag", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->synchFlag, 0U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->synchFlag);

   rtInvokeEndElement (pctxt, "synchFlag", -1);

   /* decode h235Key */

   rtInvokeStartElement (pctxt, "h235Key", -1);

   stat = addSizeConstraint (pctxt, &h235Key_lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->h235Key);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->h235Key.numocts, pvalue->h235Key.data);

   rtInvokeEndElement (pctxt, "h235Key", -1);

   /* decode escrowentry */

   if (pvalue->m.escrowentryPresent) {
      rtInvokeStartElement (pctxt, "escrowentry", -1);

      stat = asn1PD_H245EncryptionSync_escrowentry (pctxt, &pvalue->escrowentry);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "escrowentry", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OpenLogicalChannel                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245OpenLogicalChannel (OOCTXT* pctxt, H245OpenLogicalChannel* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.reverseLogicalChannelParametersPresent = optbit;

   /* decode forwardLogicalChannelNumber */

   rtInvokeStartElement (pctxt, "forwardLogicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->forwardLogicalChannelNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "forwardLogicalChannelNumber", -1);

   /* decode forwardLogicalChannelParameters */

   rtInvokeStartElement (pctxt, "forwardLogicalChannelParameters", -1);

   stat = asn1PD_H245OpenLogicalChannel_forwardLogicalChannelParameters (pctxt, &pvalue->forwardLogicalChannelParameters);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "forwardLogicalChannelParameters", -1);

   /* decode reverseLogicalChannelParameters */

   if (pvalue->m.reverseLogicalChannelParametersPresent) {
      rtInvokeStartElement (pctxt, "reverseLogicalChannelParameters", -1);

      stat = asn1PD_H245OpenLogicalChannel_reverseLogicalChannelParameters (pctxt, &pvalue->reverseLogicalChannelParameters);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "reverseLogicalChannelParameters", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 2 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.separateStackPresent = 1;

                     rtInvokeStartElement (pctxt, "separateStack", -1);

                     stat = asn1PD_H245NetworkAccessParameters (pctxt, &pvalue->separateStack);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "separateStack", -1);
                     break;

                  case 1:
                     pvalue->m.encryptionSyncPresent = 1;

                     rtInvokeStartElement (pctxt, "encryptionSync", -1);

                     stat = asn1PD_H245EncryptionSync (pctxt, &pvalue->encryptionSync);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "encryptionSync", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 2) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CloseLogicalChannel_source                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CloseLogicalChannel_source (OOCTXT* pctxt, H245CloseLogicalChannel_source* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* user */
      case 0:
         rtInvokeStartElement (pctxt, "user", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "user", -1);

         break;

      /* lcse */
      case 1:
         rtInvokeStartElement (pctxt, "lcse", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "lcse", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CloseLogicalChannel_reason                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CloseLogicalChannel_reason (OOCTXT* pctxt, H245CloseLogicalChannel_reason* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* unknown */
         case 0:
            rtInvokeStartElement (pctxt, "unknown", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "unknown", -1);

            break;

         /* reopen */
         case 1:
            rtInvokeStartElement (pctxt, "reopen", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "reopen", -1);

            break;

         /* reservationFailure */
         case 2:
            rtInvokeStartElement (pctxt, "reservationFailure", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "reservationFailure", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CloseLogicalChannel                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CloseLogicalChannel (OOCTXT* pctxt, H245CloseLogicalChannel* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   /* decode forwardLogicalChannelNumber */

   rtInvokeStartElement (pctxt, "forwardLogicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->forwardLogicalChannelNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "forwardLogicalChannelNumber", -1);

   /* decode source */

   rtInvokeStartElement (pctxt, "source", -1);

   stat = asn1PD_H245CloseLogicalChannel_source (pctxt, &pvalue->source);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "source", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 1 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.reasonPresent = 1;

                     rtInvokeStartElement (pctxt, "reason", -1);

                     stat = asn1PD_H245CloseLogicalChannel_reason (pctxt, &pvalue->reason);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "reason", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 1) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestChannelClose_reason                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestChannelClose_reason (OOCTXT* pctxt, H245RequestChannelClose_reason* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* unknown */
         case 0:
            rtInvokeStartElement (pctxt, "unknown", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "unknown", -1);

            break;

         /* normal */
         case 1:
            rtInvokeStartElement (pctxt, "normal", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "normal", -1);

            break;

         /* reopen */
         case 2:
            rtInvokeStartElement (pctxt, "reopen", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "reopen", -1);

            break;

         /* reservationFailure */
         case 3:
            rtInvokeStartElement (pctxt, "reservationFailure", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "reservationFailure", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestChannelClose                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestChannelClose (OOCTXT* pctxt, H245RequestChannelClose* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   /* decode forwardLogicalChannelNumber */

   rtInvokeStartElement (pctxt, "forwardLogicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->forwardLogicalChannelNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "forwardLogicalChannelNumber", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 2 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.qosCapabilityPresent = 1;

                     rtInvokeStartElement (pctxt, "qosCapability", -1);

                     stat = asn1PD_H245QOSCapability (pctxt, &pvalue->qosCapability);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "qosCapability", -1);
                     break;

                  case 1:
                     pvalue->m.reasonPresent = 1;

                     rtInvokeStartElement (pctxt, "reason", -1);

                     stat = asn1PD_H245RequestChannelClose_reason (pctxt, &pvalue->reason);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "reason", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 2) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexElement_type_subElementList                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplexElement_type_subElementList (OOCTXT* pctxt, H245MultiplexElement_type_subElementList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 2, 255, 0 };
   int stat = ASN_OK;
   H245MultiplexElement* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245MultiplexElement);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245MultiplexElement (pctxt, (H245MultiplexElement*)pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexElement_type                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplexElement_type (OOCTXT* pctxt, H245MultiplexElement_type* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* logicalChannelNumber */
      case 0:
         rtInvokeStartElement (pctxt, "logicalChannelNumber", -1);

         stat = decodeConsUInt16 (pctxt, &pvalue->u.logicalChannelNumber, 0U, 65535U);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         rtInvokeUIntValue (pctxt, pvalue->u.logicalChannelNumber);

         rtInvokeEndElement (pctxt, "logicalChannelNumber", -1);

         break;

      /* subElementList */
      case 1:
         rtInvokeStartElement (pctxt, "subElementList", -1);

         pvalue->u.subElementList = ALLOC_ASN1ELEM (pctxt, H245MultiplexElement_type_subElementList);
         if (pvalue->u.subElementList == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H245MultiplexElement_type_subElementList (pctxt, pvalue->u.subElementList);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

         rtInvokeEndElement (pctxt, "subElementList", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexElement_repeatCount                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplexElement_repeatCount (OOCTXT* pctxt, H245MultiplexElement_repeatCount* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* finite */
      case 0:
         rtInvokeStartElement (pctxt, "finite", -1);

         stat = decodeConsUInt16 (pctxt, &pvalue->u.finite, 1U, 65535U);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         rtInvokeUIntValue (pctxt, pvalue->u.finite);

         rtInvokeEndElement (pctxt, "finite", -1);

         break;

      /* untilClosingFlag */
      case 1:
         rtInvokeStartElement (pctxt, "untilClosingFlag", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "untilClosingFlag", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexElement                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplexElement (OOCTXT* pctxt, H245MultiplexElement* pvalue)
{
   int stat = ASN_OK;

   /* decode type */

   rtInvokeStartElement (pctxt, "type", -1);

   stat = asn1PD_H245MultiplexElement_type (pctxt, &pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "type", -1);

   /* decode repeatCount */

   rtInvokeStartElement (pctxt, "repeatCount", -1);

   stat = asn1PD_H245MultiplexElement_repeatCount (pctxt, &pvalue->repeatCount);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "repeatCount", -1);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexEntryDescriptor_elementList                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplexEntryDescriptor_elementList (OOCTXT* pctxt, H245MultiplexEntryDescriptor_elementList* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   H245MultiplexElement* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245MultiplexElement);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245MultiplexElement (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexEntryDescriptor                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplexEntryDescriptor (OOCTXT* pctxt, H245MultiplexEntryDescriptor* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.elementListPresent = optbit;

   /* decode multiplexTableEntryNumber */

   rtInvokeStartElement (pctxt, "multiplexTableEntryNumber", -1);

   stat = asn1PD_H245MultiplexTableEntryNumber (pctxt, &pvalue->multiplexTableEntryNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "multiplexTableEntryNumber", -1);

   /* decode elementList */

   if (pvalue->m.elementListPresent) {
      rtInvokeStartElement (pctxt, "elementList", -1);

      stat = asn1PD_H245MultiplexEntryDescriptor_elementList (pctxt, &pvalue->elementList);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "elementList", -1);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexEntrySend_multiplexEntryDescriptors              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplexEntrySend_multiplexEntryDescriptors (OOCTXT* pctxt, H245MultiplexEntrySend_multiplexEntryDescriptors* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 15, 0 };
   int stat = ASN_OK;
   H245MultiplexEntryDescriptor* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245MultiplexEntryDescriptor);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245MultiplexEntryDescriptor (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexEntrySend                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplexEntrySend (OOCTXT* pctxt, H245MultiplexEntrySend* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode sequenceNumber */

   rtInvokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode multiplexEntryDescriptors */

   rtInvokeStartElement (pctxt, "multiplexEntryDescriptors", -1);

   stat = asn1PD_H245MultiplexEntrySend_multiplexEntryDescriptors (pctxt, &pvalue->multiplexEntryDescriptors);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "multiplexEntryDescriptors", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestMultiplexEntry_entryNumbers                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestMultiplexEntry_entryNumbers (OOCTXT* pctxt, H245RequestMultiplexEntry_entryNumbers* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 15, 0 };
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      stat = asn1PD_H245MultiplexTableEntryNumber (pctxt, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestMultiplexEntry                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestMultiplexEntry (OOCTXT* pctxt, H245RequestMultiplexEntry* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode entryNumbers */

   rtInvokeStartElement (pctxt, "entryNumbers", -1);

   stat = asn1PD_H245RequestMultiplexEntry_entryNumbers (pctxt, &pvalue->entryNumbers);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "entryNumbers", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H261VideoMode_resolution                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H261VideoMode_resolution (OOCTXT* pctxt, H245H261VideoMode_resolution* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* qcif */
      case 0:
         rtInvokeStartElement (pctxt, "qcif", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "qcif", -1);

         break;

      /* cif */
      case 1:
         rtInvokeStartElement (pctxt, "cif", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "cif", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H261VideoMode                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H261VideoMode (OOCTXT* pctxt, H245H261VideoMode* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode resolution */

   rtInvokeStartElement (pctxt, "resolution", -1);

   stat = asn1PD_H245H261VideoMode_resolution (pctxt, &pvalue->resolution);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "resolution", -1);

   /* decode bitRate */

   rtInvokeStartElement (pctxt, "bitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->bitRate, 1U, 19200U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->bitRate);

   rtInvokeEndElement (pctxt, "bitRate", -1);

   /* decode stillImageTransmission */

   rtInvokeStartElement (pctxt, "stillImageTransmission", -1);

   stat = DECODEBIT (pctxt, &pvalue->stillImageTransmission);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->stillImageTransmission);

   rtInvokeEndElement (pctxt, "stillImageTransmission", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H262VideoMode_profileAndLevel                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H262VideoMode_profileAndLevel (OOCTXT* pctxt, H245H262VideoMode_profileAndLevel* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 10);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* profileAndLevel_SPatML */
         case 0:
            rtInvokeStartElement (pctxt, "profileAndLevel_SPatML", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "profileAndLevel_SPatML", -1);

            break;

         /* profileAndLevel_MPatLL */
         case 1:
            rtInvokeStartElement (pctxt, "profileAndLevel_MPatLL", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "profileAndLevel_MPatLL", -1);

            break;

         /* profileAndLevel_MPatML */
         case 2:
            rtInvokeStartElement (pctxt, "profileAndLevel_MPatML", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "profileAndLevel_MPatML", -1);

            break;

         /* profileAndLevel_MPatH_14 */
         case 3:
            rtInvokeStartElement (pctxt, "profileAndLevel_MPatH_14", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "profileAndLevel_MPatH_14", -1);

            break;

         /* profileAndLevel_MPatHL */
         case 4:
            rtInvokeStartElement (pctxt, "profileAndLevel_MPatHL", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "profileAndLevel_MPatHL", -1);

            break;

         /* profileAndLevel_SNRatLL */
         case 5:
            rtInvokeStartElement (pctxt, "profileAndLevel_SNRatLL", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "profileAndLevel_SNRatLL", -1);

            break;

         /* profileAndLevel_SNRatML */
         case 6:
            rtInvokeStartElement (pctxt, "profileAndLevel_SNRatML", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "profileAndLevel_SNRatML", -1);

            break;

         /* profileAndLevel_SpatialatH_14 */
         case 7:
            rtInvokeStartElement (pctxt, "profileAndLevel_SpatialatH_14", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "profileAndLevel_SpatialatH_14", -1);

            break;

         /* profileAndLevel_HPatML */
         case 8:
            rtInvokeStartElement (pctxt, "profileAndLevel_HPatML", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "profileAndLevel_HPatML", -1);

            break;

         /* profileAndLevel_HPatH_14 */
         case 9:
            rtInvokeStartElement (pctxt, "profileAndLevel_HPatH_14", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "profileAndLevel_HPatH_14", -1);

            break;

         /* profileAndLevel_HPatHL */
         case 10:
            rtInvokeStartElement (pctxt, "profileAndLevel_HPatHL", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "profileAndLevel_HPatHL", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 12;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H262VideoMode                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H262VideoMode (OOCTXT* pctxt, H245H262VideoMode* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.videoBitRatePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.vbvBufferSizePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.samplesPerLinePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.linesPerFramePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.framesPerSecondPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.luminanceSampleRatePresent = optbit;

   /* decode profileAndLevel */

   rtInvokeStartElement (pctxt, "profileAndLevel", -1);

   stat = asn1PD_H245H262VideoMode_profileAndLevel (pctxt, &pvalue->profileAndLevel);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "profileAndLevel", -1);

   /* decode videoBitRate */

   if (pvalue->m.videoBitRatePresent) {
      rtInvokeStartElement (pctxt, "videoBitRate", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->videoBitRate, 0U, 1073741823U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->videoBitRate);

      rtInvokeEndElement (pctxt, "videoBitRate", -1);
   }

   /* decode vbvBufferSize */

   if (pvalue->m.vbvBufferSizePresent) {
      rtInvokeStartElement (pctxt, "vbvBufferSize", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->vbvBufferSize, 0U, 262143U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->vbvBufferSize);

      rtInvokeEndElement (pctxt, "vbvBufferSize", -1);
   }

   /* decode samplesPerLine */

   if (pvalue->m.samplesPerLinePresent) {
      rtInvokeStartElement (pctxt, "samplesPerLine", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->samplesPerLine, 0U, 16383U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->samplesPerLine);

      rtInvokeEndElement (pctxt, "samplesPerLine", -1);
   }

   /* decode linesPerFrame */

   if (pvalue->m.linesPerFramePresent) {
      rtInvokeStartElement (pctxt, "linesPerFrame", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->linesPerFrame, 0U, 16383U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->linesPerFrame);

      rtInvokeEndElement (pctxt, "linesPerFrame", -1);
   }

   /* decode framesPerSecond */

   if (pvalue->m.framesPerSecondPresent) {
      rtInvokeStartElement (pctxt, "framesPerSecond", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->framesPerSecond, 0U, 15U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->framesPerSecond);

      rtInvokeEndElement (pctxt, "framesPerSecond", -1);
   }

   /* decode luminanceSampleRate */

   if (pvalue->m.luminanceSampleRatePresent) {
      rtInvokeStartElement (pctxt, "luminanceSampleRate", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->luminanceSampleRate, 0U, ASN1UINT_MAX);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->luminanceSampleRate);

      rtInvokeEndElement (pctxt, "luminanceSampleRate", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H263VideoMode_resolution                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H263VideoMode_resolution (OOCTXT* pctxt, H245H263VideoMode_resolution* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 4);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* sqcif */
         case 0:
            rtInvokeStartElement (pctxt, "sqcif", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "sqcif", -1);

            break;

         /* qcif */
         case 1:
            rtInvokeStartElement (pctxt, "qcif", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "qcif", -1);

            break;

         /* cif */
         case 2:
            rtInvokeStartElement (pctxt, "cif", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "cif", -1);

            break;

         /* cif4 */
         case 3:
            rtInvokeStartElement (pctxt, "cif4", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "cif4", -1);

            break;

         /* cif16 */
         case 4:
            rtInvokeStartElement (pctxt, "cif16", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "cif16", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 6;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* custom */
         case 6:
            rtInvokeStartElement (pctxt, "custom", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "custom", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H263VideoMode                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H263VideoMode (OOCTXT* pctxt, H245H263VideoMode* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   /* decode resolution */

   rtInvokeStartElement (pctxt, "resolution", -1);

   stat = asn1PD_H245H263VideoMode_resolution (pctxt, &pvalue->resolution);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "resolution", -1);

   /* decode bitRate */

   rtInvokeStartElement (pctxt, "bitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->bitRate, 1U, 19200U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->bitRate);

   rtInvokeEndElement (pctxt, "bitRate", -1);

   /* decode unrestrictedVector */

   rtInvokeStartElement (pctxt, "unrestrictedVector", -1);

   stat = DECODEBIT (pctxt, &pvalue->unrestrictedVector);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->unrestrictedVector);

   rtInvokeEndElement (pctxt, "unrestrictedVector", -1);

   /* decode arithmeticCoding */

   rtInvokeStartElement (pctxt, "arithmeticCoding", -1);

   stat = DECODEBIT (pctxt, &pvalue->arithmeticCoding);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->arithmeticCoding);

   rtInvokeEndElement (pctxt, "arithmeticCoding", -1);

   /* decode advancedPrediction */

   rtInvokeStartElement (pctxt, "advancedPrediction", -1);

   stat = DECODEBIT (pctxt, &pvalue->advancedPrediction);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->advancedPrediction);

   rtInvokeEndElement (pctxt, "advancedPrediction", -1);

   /* decode pbFrames */

   rtInvokeStartElement (pctxt, "pbFrames", -1);

   stat = DECODEBIT (pctxt, &pvalue->pbFrames);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->pbFrames);

   rtInvokeEndElement (pctxt, "pbFrames", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 3 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.errorCompensationPresent = 1;

                     rtInvokeStartElement (pctxt, "errorCompensation", -1);

                     stat = DECODEBIT (pctxt, &pvalue->errorCompensation);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeBoolValue (pctxt, pvalue->errorCompensation);

                     rtInvokeEndElement (pctxt, "errorCompensation", -1);
                     break;

                  case 1:
                     pvalue->m.enhancementLayerInfoPresent = 1;

                     rtInvokeStartElement (pctxt, "enhancementLayerInfo", -1);

                     stat = asn1PD_H245EnhancementLayerInfo (pctxt, &pvalue->enhancementLayerInfo);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "enhancementLayerInfo", -1);
                     break;

                  case 2:
                     pvalue->m.h263OptionsPresent = 1;

                     rtInvokeStartElement (pctxt, "h263Options", -1);

                     stat = asn1PD_H245H263Options (pctxt, &pvalue->h263Options);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "h263Options", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 3) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IS11172VideoMode                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245IS11172VideoMode (OOCTXT* pctxt, H245IS11172VideoMode* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.videoBitRatePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.vbvBufferSizePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.samplesPerLinePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.linesPerFramePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.pictureRatePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.luminanceSampleRatePresent = optbit;

   /* decode constrainedBitstream */

   rtInvokeStartElement (pctxt, "constrainedBitstream", -1);

   stat = DECODEBIT (pctxt, &pvalue->constrainedBitstream);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->constrainedBitstream);

   rtInvokeEndElement (pctxt, "constrainedBitstream", -1);

   /* decode videoBitRate */

   if (pvalue->m.videoBitRatePresent) {
      rtInvokeStartElement (pctxt, "videoBitRate", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->videoBitRate, 0U, 1073741823U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->videoBitRate);

      rtInvokeEndElement (pctxt, "videoBitRate", -1);
   }

   /* decode vbvBufferSize */

   if (pvalue->m.vbvBufferSizePresent) {
      rtInvokeStartElement (pctxt, "vbvBufferSize", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->vbvBufferSize, 0U, 262143U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->vbvBufferSize);

      rtInvokeEndElement (pctxt, "vbvBufferSize", -1);
   }

   /* decode samplesPerLine */

   if (pvalue->m.samplesPerLinePresent) {
      rtInvokeStartElement (pctxt, "samplesPerLine", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->samplesPerLine, 0U, 16383U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->samplesPerLine);

      rtInvokeEndElement (pctxt, "samplesPerLine", -1);
   }

   /* decode linesPerFrame */

   if (pvalue->m.linesPerFramePresent) {
      rtInvokeStartElement (pctxt, "linesPerFrame", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->linesPerFrame, 0U, 16383U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->linesPerFrame);

      rtInvokeEndElement (pctxt, "linesPerFrame", -1);
   }

   /* decode pictureRate */

   if (pvalue->m.pictureRatePresent) {
      rtInvokeStartElement (pctxt, "pictureRate", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->pictureRate, 0U, 15U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->pictureRate);

      rtInvokeEndElement (pctxt, "pictureRate", -1);
   }

   /* decode luminanceSampleRate */

   if (pvalue->m.luminanceSampleRatePresent) {
      rtInvokeStartElement (pctxt, "luminanceSampleRate", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->luminanceSampleRate, 0U, ASN1UINT_MAX);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->luminanceSampleRate);

      rtInvokeEndElement (pctxt, "luminanceSampleRate", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VideoMode                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245VideoMode (OOCTXT* pctxt, H245VideoMode* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 4);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* h261VideoMode */
         case 1:
            rtInvokeStartElement (pctxt, "h261VideoMode", -1);

            pvalue->u.h261VideoMode = ALLOC_ASN1ELEM (pctxt, H245H261VideoMode);
            if (pvalue->u.h261VideoMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H261VideoMode (pctxt, pvalue->u.h261VideoMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h261VideoMode", -1);

            break;

         /* h262VideoMode */
         case 2:
            rtInvokeStartElement (pctxt, "h262VideoMode", -1);

            pvalue->u.h262VideoMode = ALLOC_ASN1ELEM (pctxt, H245H262VideoMode);
            if (pvalue->u.h262VideoMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H262VideoMode (pctxt, pvalue->u.h262VideoMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h262VideoMode", -1);

            break;

         /* h263VideoMode */
         case 3:
            rtInvokeStartElement (pctxt, "h263VideoMode", -1);

            pvalue->u.h263VideoMode = ALLOC_ASN1ELEM (pctxt, H245H263VideoMode);
            if (pvalue->u.h263VideoMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H263VideoMode (pctxt, pvalue->u.h263VideoMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h263VideoMode", -1);

            break;

         /* is11172VideoMode */
         case 4:
            rtInvokeStartElement (pctxt, "is11172VideoMode", -1);

            pvalue->u.is11172VideoMode = ALLOC_ASN1ELEM (pctxt, H245IS11172VideoMode);
            if (pvalue->u.is11172VideoMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245IS11172VideoMode (pctxt, pvalue->u.is11172VideoMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "is11172VideoMode", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 6;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* genericVideoMode */
         case 6:
            rtInvokeStartElement (pctxt, "genericVideoMode", -1);

            pvalue->u.genericVideoMode = ALLOC_ASN1ELEM (pctxt, H245GenericCapability);
            if (pvalue->u.genericVideoMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245GenericCapability (pctxt, pvalue->u.genericVideoMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "genericVideoMode", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AudioMode_g7231                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245AudioMode_g7231 (OOCTXT* pctxt, H245AudioMode_g7231* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* noSilenceSuppressionLowRate */
      case 0:
         rtInvokeStartElement (pctxt, "noSilenceSuppressionLowRate", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "noSilenceSuppressionLowRate", -1);

         break;

      /* noSilenceSuppressionHighRate */
      case 1:
         rtInvokeStartElement (pctxt, "noSilenceSuppressionHighRate", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "noSilenceSuppressionHighRate", -1);

         break;

      /* silenceSuppressionLowRate */
      case 2:
         rtInvokeStartElement (pctxt, "silenceSuppressionLowRate", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "silenceSuppressionLowRate", -1);

         break;

      /* silenceSuppressionHighRate */
      case 3:
         rtInvokeStartElement (pctxt, "silenceSuppressionHighRate", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "silenceSuppressionHighRate", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IS11172AudioMode_audioLayer                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245IS11172AudioMode_audioLayer (OOCTXT* pctxt, H245IS11172AudioMode_audioLayer* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* audioLayer1 */
      case 0:
         rtInvokeStartElement (pctxt, "audioLayer1", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "audioLayer1", -1);

         break;

      /* audioLayer2 */
      case 1:
         rtInvokeStartElement (pctxt, "audioLayer2", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "audioLayer2", -1);

         break;

      /* audioLayer3 */
      case 2:
         rtInvokeStartElement (pctxt, "audioLayer3", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "audioLayer3", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IS11172AudioMode_audioSampling                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245IS11172AudioMode_audioSampling (OOCTXT* pctxt, H245IS11172AudioMode_audioSampling* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* audioSampling32k */
      case 0:
         rtInvokeStartElement (pctxt, "audioSampling32k", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "audioSampling32k", -1);

         break;

      /* audioSampling44k1 */
      case 1:
         rtInvokeStartElement (pctxt, "audioSampling44k1", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "audioSampling44k1", -1);

         break;

      /* audioSampling48k */
      case 2:
         rtInvokeStartElement (pctxt, "audioSampling48k", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "audioSampling48k", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IS11172AudioMode_multichannelType                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245IS11172AudioMode_multichannelType (OOCTXT* pctxt, H245IS11172AudioMode_multichannelType* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* singleChannel */
      case 0:
         rtInvokeStartElement (pctxt, "singleChannel", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "singleChannel", -1);

         break;

      /* twoChannelStereo */
      case 1:
         rtInvokeStartElement (pctxt, "twoChannelStereo", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "twoChannelStereo", -1);

         break;

      /* twoChannelDual */
      case 2:
         rtInvokeStartElement (pctxt, "twoChannelDual", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "twoChannelDual", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IS11172AudioMode                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245IS11172AudioMode (OOCTXT* pctxt, H245IS11172AudioMode* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode audioLayer */

   rtInvokeStartElement (pctxt, "audioLayer", -1);

   stat = asn1PD_H245IS11172AudioMode_audioLayer (pctxt, &pvalue->audioLayer);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "audioLayer", -1);

   /* decode audioSampling */

   rtInvokeStartElement (pctxt, "audioSampling", -1);

   stat = asn1PD_H245IS11172AudioMode_audioSampling (pctxt, &pvalue->audioSampling);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "audioSampling", -1);

   /* decode multichannelType */

   rtInvokeStartElement (pctxt, "multichannelType", -1);

   stat = asn1PD_H245IS11172AudioMode_multichannelType (pctxt, &pvalue->multichannelType);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "multichannelType", -1);

   /* decode bitRate */

   rtInvokeStartElement (pctxt, "bitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->bitRate, 1U, 448U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->bitRate);

   rtInvokeEndElement (pctxt, "bitRate", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IS13818AudioMode_audioLayer                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245IS13818AudioMode_audioLayer (OOCTXT* pctxt, H245IS13818AudioMode_audioLayer* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* audioLayer1 */
      case 0:
         rtInvokeStartElement (pctxt, "audioLayer1", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "audioLayer1", -1);

         break;

      /* audioLayer2 */
      case 1:
         rtInvokeStartElement (pctxt, "audioLayer2", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "audioLayer2", -1);

         break;

      /* audioLayer3 */
      case 2:
         rtInvokeStartElement (pctxt, "audioLayer3", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "audioLayer3", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IS13818AudioMode_audioSampling                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245IS13818AudioMode_audioSampling (OOCTXT* pctxt, H245IS13818AudioMode_audioSampling* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 5);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* audioSampling16k */
      case 0:
         rtInvokeStartElement (pctxt, "audioSampling16k", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "audioSampling16k", -1);

         break;

      /* audioSampling22k05 */
      case 1:
         rtInvokeStartElement (pctxt, "audioSampling22k05", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "audioSampling22k05", -1);

         break;

      /* audioSampling24k */
      case 2:
         rtInvokeStartElement (pctxt, "audioSampling24k", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "audioSampling24k", -1);

         break;

      /* audioSampling32k */
      case 3:
         rtInvokeStartElement (pctxt, "audioSampling32k", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "audioSampling32k", -1);

         break;

      /* audioSampling44k1 */
      case 4:
         rtInvokeStartElement (pctxt, "audioSampling44k1", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "audioSampling44k1", -1);

         break;

      /* audioSampling48k */
      case 5:
         rtInvokeStartElement (pctxt, "audioSampling48k", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "audioSampling48k", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IS13818AudioMode_multichannelType                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245IS13818AudioMode_multichannelType (OOCTXT* pctxt, H245IS13818AudioMode_multichannelType* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 9);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* singleChannel */
      case 0:
         rtInvokeStartElement (pctxt, "singleChannel", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "singleChannel", -1);

         break;

      /* twoChannelStereo */
      case 1:
         rtInvokeStartElement (pctxt, "twoChannelStereo", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "twoChannelStereo", -1);

         break;

      /* twoChannelDual */
      case 2:
         rtInvokeStartElement (pctxt, "twoChannelDual", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "twoChannelDual", -1);

         break;

      /* threeChannels2_1 */
      case 3:
         rtInvokeStartElement (pctxt, "threeChannels2_1", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "threeChannels2_1", -1);

         break;

      /* threeChannels3_0 */
      case 4:
         rtInvokeStartElement (pctxt, "threeChannels3_0", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "threeChannels3_0", -1);

         break;

      /* fourChannels2_0_2_0 */
      case 5:
         rtInvokeStartElement (pctxt, "fourChannels2_0_2_0", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "fourChannels2_0_2_0", -1);

         break;

      /* fourChannels2_2 */
      case 6:
         rtInvokeStartElement (pctxt, "fourChannels2_2", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "fourChannels2_2", -1);

         break;

      /* fourChannels3_1 */
      case 7:
         rtInvokeStartElement (pctxt, "fourChannels3_1", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "fourChannels3_1", -1);

         break;

      /* fiveChannels3_0_2_0 */
      case 8:
         rtInvokeStartElement (pctxt, "fiveChannels3_0_2_0", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "fiveChannels3_0_2_0", -1);

         break;

      /* fiveChannels3_2 */
      case 9:
         rtInvokeStartElement (pctxt, "fiveChannels3_2", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "fiveChannels3_2", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IS13818AudioMode                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245IS13818AudioMode (OOCTXT* pctxt, H245IS13818AudioMode* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode audioLayer */

   rtInvokeStartElement (pctxt, "audioLayer", -1);

   stat = asn1PD_H245IS13818AudioMode_audioLayer (pctxt, &pvalue->audioLayer);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "audioLayer", -1);

   /* decode audioSampling */

   rtInvokeStartElement (pctxt, "audioSampling", -1);

   stat = asn1PD_H245IS13818AudioMode_audioSampling (pctxt, &pvalue->audioSampling);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "audioSampling", -1);

   /* decode multichannelType */

   rtInvokeStartElement (pctxt, "multichannelType", -1);

   stat = asn1PD_H245IS13818AudioMode_multichannelType (pctxt, &pvalue->multichannelType);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "multichannelType", -1);

   /* decode lowFrequencyEnhancement */

   rtInvokeStartElement (pctxt, "lowFrequencyEnhancement", -1);

   stat = DECODEBIT (pctxt, &pvalue->lowFrequencyEnhancement);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->lowFrequencyEnhancement);

   rtInvokeEndElement (pctxt, "lowFrequencyEnhancement", -1);

   /* decode multilingual */

   rtInvokeStartElement (pctxt, "multilingual", -1);

   stat = DECODEBIT (pctxt, &pvalue->multilingual);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->multilingual);

   rtInvokeEndElement (pctxt, "multilingual", -1);

   /* decode bitRate */

   rtInvokeStartElement (pctxt, "bitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->bitRate, 1U, 1130U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->bitRate);

   rtInvokeEndElement (pctxt, "bitRate", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  G7231AnnexCMode_g723AnnexCAudioMode                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245G7231AnnexCMode_g723AnnexCAudioMode (OOCTXT* pctxt, H245G7231AnnexCMode_g723AnnexCAudioMode* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode highRateMode0 */

   rtInvokeStartElement (pctxt, "highRateMode0", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->highRateMode0, 27U, 78U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->highRateMode0);

   rtInvokeEndElement (pctxt, "highRateMode0", -1);

   /* decode highRateMode1 */

   rtInvokeStartElement (pctxt, "highRateMode1", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->highRateMode1, 27U, 78U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->highRateMode1);

   rtInvokeEndElement (pctxt, "highRateMode1", -1);

   /* decode lowRateMode0 */

   rtInvokeStartElement (pctxt, "lowRateMode0", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->lowRateMode0, 23U, 66U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->lowRateMode0);

   rtInvokeEndElement (pctxt, "lowRateMode0", -1);

   /* decode lowRateMode1 */

   rtInvokeStartElement (pctxt, "lowRateMode1", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->lowRateMode1, 23U, 66U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->lowRateMode1);

   rtInvokeEndElement (pctxt, "lowRateMode1", -1);

   /* decode sidMode0 */

   rtInvokeStartElement (pctxt, "sidMode0", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->sidMode0, 6U, 17U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->sidMode0);

   rtInvokeEndElement (pctxt, "sidMode0", -1);

   /* decode sidMode1 */

   rtInvokeStartElement (pctxt, "sidMode1", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->sidMode1, 6U, 17U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->sidMode1);

   rtInvokeEndElement (pctxt, "sidMode1", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  G7231AnnexCMode                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245G7231AnnexCMode (OOCTXT* pctxt, H245G7231AnnexCMode* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode maxAl_sduAudioFrames */

   rtInvokeStartElement (pctxt, "maxAl_sduAudioFrames", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maxAl_sduAudioFrames, 1U, 256U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maxAl_sduAudioFrames);

   rtInvokeEndElement (pctxt, "maxAl_sduAudioFrames", -1);

   /* decode silenceSuppression */

   rtInvokeStartElement (pctxt, "silenceSuppression", -1);

   stat = DECODEBIT (pctxt, &pvalue->silenceSuppression);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->silenceSuppression);

   rtInvokeEndElement (pctxt, "silenceSuppression", -1);

   /* decode g723AnnexCAudioMode */

   rtInvokeStartElement (pctxt, "g723AnnexCAudioMode", -1);

   stat = asn1PD_H245G7231AnnexCMode_g723AnnexCAudioMode (pctxt, &pvalue->g723AnnexCAudioMode);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "g723AnnexCAudioMode", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VBDMode                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245VBDMode (OOCTXT* pctxt, H245VBDMode* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode type */

   rtInvokeStartElement (pctxt, "type", -1);

   pvalue->type = ALLOC_ASN1ELEM (pctxt, H245AudioMode);
   if (pvalue->type == NULL)
      return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

   stat = asn1PD_H245AudioMode (pctxt, (H245AudioMode*)pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "type", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AudioMode                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245AudioMode (OOCTXT* pctxt, H245AudioMode* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 13);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* g711Alaw64k */
         case 1:
            rtInvokeStartElement (pctxt, "g711Alaw64k", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "g711Alaw64k", -1);

            break;

         /* g711Alaw56k */
         case 2:
            rtInvokeStartElement (pctxt, "g711Alaw56k", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "g711Alaw56k", -1);

            break;

         /* g711Ulaw64k */
         case 3:
            rtInvokeStartElement (pctxt, "g711Ulaw64k", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "g711Ulaw64k", -1);

            break;

         /* g711Ulaw56k */
         case 4:
            rtInvokeStartElement (pctxt, "g711Ulaw56k", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "g711Ulaw56k", -1);

            break;

         /* g722_64k */
         case 5:
            rtInvokeStartElement (pctxt, "g722_64k", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "g722_64k", -1);

            break;

         /* g722_56k */
         case 6:
            rtInvokeStartElement (pctxt, "g722_56k", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "g722_56k", -1);

            break;

         /* g722_48k */
         case 7:
            rtInvokeStartElement (pctxt, "g722_48k", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "g722_48k", -1);

            break;

         /* g728 */
         case 8:
            rtInvokeStartElement (pctxt, "g728", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "g728", -1);

            break;

         /* g729 */
         case 9:
            rtInvokeStartElement (pctxt, "g729", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "g729", -1);

            break;

         /* g729AnnexA */
         case 10:
            rtInvokeStartElement (pctxt, "g729AnnexA", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "g729AnnexA", -1);

            break;

         /* g7231 */
         case 11:
            rtInvokeStartElement (pctxt, "g7231", -1);

            pvalue->u.g7231 = ALLOC_ASN1ELEM (pctxt, H245AudioMode_g7231);
            if (pvalue->u.g7231 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245AudioMode_g7231 (pctxt, pvalue->u.g7231);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "g7231", -1);

            break;

         /* is11172AudioMode */
         case 12:
            rtInvokeStartElement (pctxt, "is11172AudioMode", -1);

            pvalue->u.is11172AudioMode = ALLOC_ASN1ELEM (pctxt, H245IS11172AudioMode);
            if (pvalue->u.is11172AudioMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245IS11172AudioMode (pctxt, pvalue->u.is11172AudioMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "is11172AudioMode", -1);

            break;

         /* is13818AudioMode */
         case 13:
            rtInvokeStartElement (pctxt, "is13818AudioMode", -1);

            pvalue->u.is13818AudioMode = ALLOC_ASN1ELEM (pctxt, H245IS13818AudioMode);
            if (pvalue->u.is13818AudioMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245IS13818AudioMode (pctxt, pvalue->u.is13818AudioMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "is13818AudioMode", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 15;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* g729wAnnexB */
         case 15:
            rtInvokeStartElement (pctxt, "g729wAnnexB", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g729wAnnexB, 1U, 256U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.g729wAnnexB);

            rtInvokeEndElement (pctxt, "g729wAnnexB", -1);

            break;

         /* g729AnnexAwAnnexB */
         case 16:
            rtInvokeStartElement (pctxt, "g729AnnexAwAnnexB", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.g729AnnexAwAnnexB, 1U, 256U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.g729AnnexAwAnnexB);

            rtInvokeEndElement (pctxt, "g729AnnexAwAnnexB", -1);

            break;

         /* g7231AnnexCMode */
         case 17:
            rtInvokeStartElement (pctxt, "g7231AnnexCMode", -1);

            pvalue->u.g7231AnnexCMode = ALLOC_ASN1ELEM (pctxt, H245G7231AnnexCMode);
            if (pvalue->u.g7231AnnexCMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245G7231AnnexCMode (pctxt, pvalue->u.g7231AnnexCMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "g7231AnnexCMode", -1);

            break;

         /* gsmFullRate */
         case 18:
            rtInvokeStartElement (pctxt, "gsmFullRate", -1);

            pvalue->u.gsmFullRate = ALLOC_ASN1ELEM (pctxt, H245GSMAudioCapability);
            if (pvalue->u.gsmFullRate == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245GSMAudioCapability (pctxt, pvalue->u.gsmFullRate);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "gsmFullRate", -1);

            break;

         /* gsmHalfRate */
         case 19:
            rtInvokeStartElement (pctxt, "gsmHalfRate", -1);

            pvalue->u.gsmHalfRate = ALLOC_ASN1ELEM (pctxt, H245GSMAudioCapability);
            if (pvalue->u.gsmHalfRate == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245GSMAudioCapability (pctxt, pvalue->u.gsmHalfRate);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "gsmHalfRate", -1);

            break;

         /* gsmEnhancedFullRate */
         case 20:
            rtInvokeStartElement (pctxt, "gsmEnhancedFullRate", -1);

            pvalue->u.gsmEnhancedFullRate = ALLOC_ASN1ELEM (pctxt, H245GSMAudioCapability);
            if (pvalue->u.gsmEnhancedFullRate == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245GSMAudioCapability (pctxt, pvalue->u.gsmEnhancedFullRate);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "gsmEnhancedFullRate", -1);

            break;

         /* genericAudioMode */
         case 21:
            rtInvokeStartElement (pctxt, "genericAudioMode", -1);

            pvalue->u.genericAudioMode = ALLOC_ASN1ELEM (pctxt, H245GenericCapability);
            if (pvalue->u.genericAudioMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245GenericCapability (pctxt, pvalue->u.genericAudioMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "genericAudioMode", -1);

            break;

         /* g729Extensions */
         case 22:
            rtInvokeStartElement (pctxt, "g729Extensions", -1);

            pvalue->u.g729Extensions = ALLOC_ASN1ELEM (pctxt, H245G729Extensions);
            if (pvalue->u.g729Extensions == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245G729Extensions (pctxt, pvalue->u.g729Extensions);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "g729Extensions", -1);

            break;

         /* vbd */
         case 23:
            rtInvokeStartElement (pctxt, "vbd", -1);

            pvalue->u.vbd = ALLOC_ASN1ELEM (pctxt, H245VBDMode);
            if (pvalue->u.vbd == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245VBDMode (pctxt, pvalue->u.vbd);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "vbd", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataMode_application_nlpid                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245DataMode_application_nlpid (OOCTXT* pctxt, H245DataMode_application_nlpid* pvalue)
{
   int stat = ASN_OK;

   /* decode nlpidProtocol */

   rtInvokeStartElement (pctxt, "nlpidProtocol", -1);

   stat = asn1PD_H245DataProtocolCapability (pctxt, &pvalue->nlpidProtocol);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "nlpidProtocol", -1);

   /* decode nlpidData */

   rtInvokeStartElement (pctxt, "nlpidData", -1);

   stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->nlpidData);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->nlpidData.numocts, pvalue->nlpidData.data);

   rtInvokeEndElement (pctxt, "nlpidData", -1);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataMode_application_t38fax                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245DataMode_application_t38fax (OOCTXT* pctxt, H245DataMode_application_t38fax* pvalue)
{
   int stat = ASN_OK;

   /* decode t38FaxProtocol */

   rtInvokeStartElement (pctxt, "t38FaxProtocol", -1);

   stat = asn1PD_H245DataProtocolCapability (pctxt, &pvalue->t38FaxProtocol);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "t38FaxProtocol", -1);

   /* decode t38FaxProfile */

   rtInvokeStartElement (pctxt, "t38FaxProfile", -1);

   stat = asn1PD_H245T38FaxProfile (pctxt, &pvalue->t38FaxProfile);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "t38FaxProfile", -1);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataMode_application                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245DataMode_application (OOCTXT* pctxt, H245DataMode_application* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 9);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* t120 */
         case 1:
            rtInvokeStartElement (pctxt, "t120", -1);

            pvalue->u.t120 = ALLOC_ASN1ELEM (pctxt, H245DataProtocolCapability);
            if (pvalue->u.t120 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.t120);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "t120", -1);

            break;

         /* dsm_cc */
         case 2:
            rtInvokeStartElement (pctxt, "dsm_cc", -1);

            pvalue->u.dsm_cc = ALLOC_ASN1ELEM (pctxt, H245DataProtocolCapability);
            if (pvalue->u.dsm_cc == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.dsm_cc);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "dsm_cc", -1);

            break;

         /* userData */
         case 3:
            rtInvokeStartElement (pctxt, "userData", -1);

            pvalue->u.userData = ALLOC_ASN1ELEM (pctxt, H245DataProtocolCapability);
            if (pvalue->u.userData == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.userData);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "userData", -1);

            break;

         /* t84 */
         case 4:
            rtInvokeStartElement (pctxt, "t84", -1);

            pvalue->u.t84 = ALLOC_ASN1ELEM (pctxt, H245DataProtocolCapability);
            if (pvalue->u.t84 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.t84);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "t84", -1);

            break;

         /* t434 */
         case 5:
            rtInvokeStartElement (pctxt, "t434", -1);

            pvalue->u.t434 = ALLOC_ASN1ELEM (pctxt, H245DataProtocolCapability);
            if (pvalue->u.t434 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.t434);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "t434", -1);

            break;

         /* h224 */
         case 6:
            rtInvokeStartElement (pctxt, "h224", -1);

            pvalue->u.h224 = ALLOC_ASN1ELEM (pctxt, H245DataProtocolCapability);
            if (pvalue->u.h224 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.h224);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h224", -1);

            break;

         /* nlpid */
         case 7:
            rtInvokeStartElement (pctxt, "nlpid", -1);

            pvalue->u.nlpid = ALLOC_ASN1ELEM (pctxt, H245DataMode_application_nlpid);
            if (pvalue->u.nlpid == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataMode_application_nlpid (pctxt, pvalue->u.nlpid);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nlpid", -1);

            break;

         /* dsvdControl */
         case 8:
            rtInvokeStartElement (pctxt, "dsvdControl", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "dsvdControl", -1);

            break;

         /* h222DataPartitioning */
         case 9:
            rtInvokeStartElement (pctxt, "h222DataPartitioning", -1);

            pvalue->u.h222DataPartitioning = ALLOC_ASN1ELEM (pctxt, H245DataProtocolCapability);
            if (pvalue->u.h222DataPartitioning == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.h222DataPartitioning);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h222DataPartitioning", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 11;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* t30fax */
         case 11:
            rtInvokeStartElement (pctxt, "t30fax", -1);

            pvalue->u.t30fax = ALLOC_ASN1ELEM (pctxt, H245DataProtocolCapability);
            if (pvalue->u.t30fax == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.t30fax);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "t30fax", -1);

            break;

         /* t140 */
         case 12:
            rtInvokeStartElement (pctxt, "t140", -1);

            pvalue->u.t140 = ALLOC_ASN1ELEM (pctxt, H245DataProtocolCapability);
            if (pvalue->u.t140 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataProtocolCapability (pctxt, pvalue->u.t140);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "t140", -1);

            break;

         /* t38fax */
         case 13:
            rtInvokeStartElement (pctxt, "t38fax", -1);

            pvalue->u.t38fax = ALLOC_ASN1ELEM (pctxt, H245DataMode_application_t38fax);
            if (pvalue->u.t38fax == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataMode_application_t38fax (pctxt, pvalue->u.t38fax);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "t38fax", -1);

            break;

         /* genericDataMode */
         case 14:
            rtInvokeStartElement (pctxt, "genericDataMode", -1);

            pvalue->u.genericDataMode = ALLOC_ASN1ELEM (pctxt, H245GenericCapability);
            if (pvalue->u.genericDataMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245GenericCapability (pctxt, pvalue->u.genericDataMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "genericDataMode", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataMode                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245DataMode (OOCTXT* pctxt, H245DataMode* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode application */

   rtInvokeStartElement (pctxt, "application", -1);

   stat = asn1PD_H245DataMode_application (pctxt, &pvalue->application);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "application", -1);

   /* decode bitRate */

   rtInvokeStartElement (pctxt, "bitRate", -1);

   stat = decodeConsUnsigned (pctxt, &pvalue->bitRate, 0U, ASN1UINT_MAX);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->bitRate);

   rtInvokeEndElement (pctxt, "bitRate", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H235Mode_mediaMode                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H235Mode_mediaMode (OOCTXT* pctxt, H245H235Mode_mediaMode* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* videoMode */
         case 1:
            rtInvokeStartElement (pctxt, "videoMode", -1);

            pvalue->u.videoMode = ALLOC_ASN1ELEM (pctxt, H245VideoMode);
            if (pvalue->u.videoMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245VideoMode (pctxt, pvalue->u.videoMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "videoMode", -1);

            break;

         /* audioMode */
         case 2:
            rtInvokeStartElement (pctxt, "audioMode", -1);

            pvalue->u.audioMode = ALLOC_ASN1ELEM (pctxt, H245AudioMode);
            if (pvalue->u.audioMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245AudioMode (pctxt, pvalue->u.audioMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "audioMode", -1);

            break;

         /* dataMode */
         case 3:
            rtInvokeStartElement (pctxt, "dataMode", -1);

            pvalue->u.dataMode = ALLOC_ASN1ELEM (pctxt, H245DataMode);
            if (pvalue->u.dataMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataMode (pctxt, pvalue->u.dataMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "dataMode", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H235Mode                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H235Mode (OOCTXT* pctxt, H245H235Mode* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode encryptionAuthenticationAndIntegrity */

   rtInvokeStartElement (pctxt, "encryptionAuthenticationAndIntegrity", -1);

   stat = asn1PD_H245EncryptionAuthenticationAndIntegrity (pctxt, &pvalue->encryptionAuthenticationAndIntegrity);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "encryptionAuthenticationAndIntegrity", -1);

   /* decode mediaMode */

   rtInvokeStartElement (pctxt, "mediaMode", -1);

   stat = asn1PD_H245H235Mode_mediaMode (pctxt, &pvalue->mediaMode);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "mediaMode", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RedundancyEncodingDTModeElement_type                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RedundancyEncodingDTModeElement_type (OOCTXT* pctxt, H245RedundancyEncodingDTModeElement_type* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 5);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* videoMode */
         case 1:
            rtInvokeStartElement (pctxt, "videoMode", -1);

            pvalue->u.videoMode = ALLOC_ASN1ELEM (pctxt, H245VideoMode);
            if (pvalue->u.videoMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245VideoMode (pctxt, pvalue->u.videoMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "videoMode", -1);

            break;

         /* audioMode */
         case 2:
            rtInvokeStartElement (pctxt, "audioMode", -1);

            pvalue->u.audioMode = ALLOC_ASN1ELEM (pctxt, H245AudioMode);
            if (pvalue->u.audioMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245AudioMode (pctxt, pvalue->u.audioMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "audioMode", -1);

            break;

         /* dataMode */
         case 3:
            rtInvokeStartElement (pctxt, "dataMode", -1);

            pvalue->u.dataMode = ALLOC_ASN1ELEM (pctxt, H245DataMode);
            if (pvalue->u.dataMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataMode (pctxt, pvalue->u.dataMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "dataMode", -1);

            break;

         /* encryptionMode */
         case 4:
            rtInvokeStartElement (pctxt, "encryptionMode", -1);

            pvalue->u.encryptionMode = ALLOC_ASN1ELEM (pctxt, H245EncryptionMode);
            if (pvalue->u.encryptionMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245EncryptionMode (pctxt, pvalue->u.encryptionMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "encryptionMode", -1);

            break;

         /* h235Mode */
         case 5:
            rtInvokeStartElement (pctxt, "h235Mode", -1);

            pvalue->u.h235Mode = ALLOC_ASN1ELEM (pctxt, H245H235Mode);
            if (pvalue->u.h235Mode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H235Mode (pctxt, pvalue->u.h235Mode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h235Mode", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 7;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RedundancyEncodingDTModeElement                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RedundancyEncodingDTModeElement (OOCTXT* pctxt, H245RedundancyEncodingDTModeElement* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode type */

   rtInvokeStartElement (pctxt, "type", -1);

   stat = asn1PD_H245RedundancyEncodingDTModeElement_type (pctxt, &pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "type", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH245RedundancyEncodingDTModeElement                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245_SeqOfH245RedundancyEncodingDTModeElement (OOCTXT* pctxt, H245_SeqOfH245RedundancyEncodingDTModeElement* pvalue)
{
   int stat = ASN_OK;
   H245RedundancyEncodingDTModeElement* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         rtInvokeStartElement (pctxt, "elem", xx1);

         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245RedundancyEncodingDTModeElement);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H245RedundancyEncodingDTModeElement (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         rtInvokeEndElement (pctxt, "elem", xx1);

         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RedundancyEncodingDTMode                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RedundancyEncodingDTMode (OOCTXT* pctxt, H245RedundancyEncodingDTMode* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode redundancyEncodingMethod */

   rtInvokeStartElement (pctxt, "redundancyEncodingMethod", -1);

   stat = asn1PD_H245RedundancyEncodingMethod (pctxt, &pvalue->redundancyEncodingMethod);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "redundancyEncodingMethod", -1);

   /* decode primary */

   rtInvokeStartElement (pctxt, "primary", -1);

   stat = asn1PD_H245RedundancyEncodingDTModeElement (pctxt, &pvalue->primary);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "primary", -1);

   /* decode secondary */

   rtInvokeStartElement (pctxt, "secondary", -1);

   stat = asn1PD_H245_SeqOfH245RedundancyEncodingDTModeElement (pctxt, &pvalue->secondary);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "secondary", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplePayloadStreamElementMode                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplePayloadStreamElementMode (OOCTXT* pctxt, H245MultiplePayloadStreamElementMode* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode type */

   rtInvokeStartElement (pctxt, "type", -1);

   pvalue->type = ALLOC_ASN1ELEM (pctxt, H245ModeElementType);
   if (pvalue->type == NULL)
      return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

   stat = asn1PD_H245ModeElementType (pctxt, (H245ModeElementType*)pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "type", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH245MultiplePayloadStreamElementMode                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245_SeqOfH245MultiplePayloadStreamElementMode (OOCTXT* pctxt, H245_SeqOfH245MultiplePayloadStreamElementMode* pvalue)
{
   int stat = ASN_OK;
   H245MultiplePayloadStreamElementMode* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         rtInvokeStartElement (pctxt, "elem", xx1);

         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245MultiplePayloadStreamElementMode);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H245MultiplePayloadStreamElementMode (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         rtInvokeEndElement (pctxt, "elem", xx1);

         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplePayloadStreamMode                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplePayloadStreamMode (OOCTXT* pctxt, H245MultiplePayloadStreamMode* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode elements */

   rtInvokeStartElement (pctxt, "elements", -1);

   stat = asn1PD_H245_SeqOfH245MultiplePayloadStreamElementMode (pctxt, &pvalue->elements);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "elements", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FECMode_rfc2733Mode_mode_separateStream_differentPort     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245FECMode_rfc2733Mode_mode_separateStream_differentPort (OOCTXT* pctxt, H245FECMode_rfc2733Mode_mode_separateStream_differentPort* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protectedPayloadTypePresent = optbit;

   /* decode protectedSessionID */

   rtInvokeStartElement (pctxt, "protectedSessionID", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->protectedSessionID, 1U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->protectedSessionID);

   rtInvokeEndElement (pctxt, "protectedSessionID", -1);

   /* decode protectedPayloadType */

   if (pvalue->m.protectedPayloadTypePresent) {
      rtInvokeStartElement (pctxt, "protectedPayloadType", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->protectedPayloadType, 0U, 127U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->protectedPayloadType);

      rtInvokeEndElement (pctxt, "protectedPayloadType", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FECMode_rfc2733Mode_mode_separateStream_samePort          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245FECMode_rfc2733Mode_mode_separateStream_samePort (OOCTXT* pctxt, H245FECMode_rfc2733Mode_mode_separateStream_samePort* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode protectedType */

   rtInvokeStartElement (pctxt, "protectedType", -1);

   pvalue->protectedType = ALLOC_ASN1ELEM (pctxt, H245ModeElementType);
   if (pvalue->protectedType == NULL)
      return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

   stat = asn1PD_H245ModeElementType (pctxt, (H245ModeElementType*)pvalue->protectedType);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "protectedType", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FECMode_rfc2733Mode_mode_separateStream                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245FECMode_rfc2733Mode_mode_separateStream (OOCTXT* pctxt, H245FECMode_rfc2733Mode_mode_separateStream* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* differentPort */
         case 0:
            rtInvokeStartElement (pctxt, "differentPort", -1);

            pvalue->u.differentPort = ALLOC_ASN1ELEM (pctxt, H245FECMode_rfc2733Mode_mode_separateStream_differentPort);
            if (pvalue->u.differentPort == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245FECMode_rfc2733Mode_mode_separateStream_differentPort (pctxt, pvalue->u.differentPort);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "differentPort", -1);

            break;

         /* samePort */
         case 1:
            rtInvokeStartElement (pctxt, "samePort", -1);

            pvalue->u.samePort = ALLOC_ASN1ELEM (pctxt, H245FECMode_rfc2733Mode_mode_separateStream_samePort);
            if (pvalue->u.samePort == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245FECMode_rfc2733Mode_mode_separateStream_samePort (pctxt, pvalue->u.samePort);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "samePort", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FECMode_rfc2733Mode_mode                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245FECMode_rfc2733Mode_mode (OOCTXT* pctxt, H245FECMode_rfc2733Mode_mode* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* redundancyEncoding */
         case 0:
            rtInvokeStartElement (pctxt, "redundancyEncoding", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "redundancyEncoding", -1);

            break;

         /* separateStream */
         case 1:
            rtInvokeStartElement (pctxt, "separateStream", -1);

            pvalue->u.separateStream = ALLOC_ASN1ELEM (pctxt, H245FECMode_rfc2733Mode_mode_separateStream);
            if (pvalue->u.separateStream == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245FECMode_rfc2733Mode_mode_separateStream (pctxt, pvalue->u.separateStream);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "separateStream", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FECMode_rfc2733Mode                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245FECMode_rfc2733Mode (OOCTXT* pctxt, H245FECMode_rfc2733Mode* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode mode */

   rtInvokeStartElement (pctxt, "mode", -1);

   stat = asn1PD_H245FECMode_rfc2733Mode_mode (pctxt, &pvalue->mode);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "mode", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FECMode                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245FECMode (OOCTXT* pctxt, H245FECMode* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* rfc2733Mode */
         case 0:
            rtInvokeStartElement (pctxt, "rfc2733Mode", -1);

            pvalue->u.rfc2733Mode = ALLOC_ASN1ELEM (pctxt, H245FECMode_rfc2733Mode);
            if (pvalue->u.rfc2733Mode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245FECMode_rfc2733Mode (pctxt, pvalue->u.rfc2733Mode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "rfc2733Mode", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ModeElementType                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ModeElementType (OOCTXT* pctxt, H245ModeElementType* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 4);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* videoMode */
         case 1:
            rtInvokeStartElement (pctxt, "videoMode", -1);

            pvalue->u.videoMode = ALLOC_ASN1ELEM (pctxt, H245VideoMode);
            if (pvalue->u.videoMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245VideoMode (pctxt, pvalue->u.videoMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "videoMode", -1);

            break;

         /* audioMode */
         case 2:
            rtInvokeStartElement (pctxt, "audioMode", -1);

            pvalue->u.audioMode = ALLOC_ASN1ELEM (pctxt, H245AudioMode);
            if (pvalue->u.audioMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245AudioMode (pctxt, pvalue->u.audioMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "audioMode", -1);

            break;

         /* dataMode */
         case 3:
            rtInvokeStartElement (pctxt, "dataMode", -1);

            pvalue->u.dataMode = ALLOC_ASN1ELEM (pctxt, H245DataMode);
            if (pvalue->u.dataMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataMode (pctxt, pvalue->u.dataMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "dataMode", -1);

            break;

         /* encryptionMode */
         case 4:
            rtInvokeStartElement (pctxt, "encryptionMode", -1);

            pvalue->u.encryptionMode = ALLOC_ASN1ELEM (pctxt, H245EncryptionMode);
            if (pvalue->u.encryptionMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245EncryptionMode (pctxt, pvalue->u.encryptionMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "encryptionMode", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 6;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* h235Mode */
         case 6:
            rtInvokeStartElement (pctxt, "h235Mode", -1);

            pvalue->u.h235Mode = ALLOC_ASN1ELEM (pctxt, H245H235Mode);
            if (pvalue->u.h235Mode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H235Mode (pctxt, pvalue->u.h235Mode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h235Mode", -1);

            break;

         /* multiplexedStreamMode */
         case 7:
            rtInvokeStartElement (pctxt, "multiplexedStreamMode", -1);

            pvalue->u.multiplexedStreamMode = ALLOC_ASN1ELEM (pctxt, H245MultiplexedStreamParameter);
            if (pvalue->u.multiplexedStreamMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultiplexedStreamParameter (pctxt, pvalue->u.multiplexedStreamMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "multiplexedStreamMode", -1);

            break;

         /* redundancyEncodingDTMode */
         case 8:
            rtInvokeStartElement (pctxt, "redundancyEncodingDTMode", -1);

            pvalue->u.redundancyEncodingDTMode = ALLOC_ASN1ELEM (pctxt, H245RedundancyEncodingDTMode);
            if (pvalue->u.redundancyEncodingDTMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RedundancyEncodingDTMode (pctxt, pvalue->u.redundancyEncodingDTMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "redundancyEncodingDTMode", -1);

            break;

         /* multiplePayloadStreamMode */
         case 9:
            rtInvokeStartElement (pctxt, "multiplePayloadStreamMode", -1);

            pvalue->u.multiplePayloadStreamMode = ALLOC_ASN1ELEM (pctxt, H245MultiplePayloadStreamMode);
            if (pvalue->u.multiplePayloadStreamMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultiplePayloadStreamMode (pctxt, pvalue->u.multiplePayloadStreamMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "multiplePayloadStreamMode", -1);

            break;

         /* fecMode */
         case 10:
            rtInvokeStartElement (pctxt, "fecMode", -1);

            pvalue->u.fecMode = ALLOC_ASN1ELEM (pctxt, H245FECMode);
            if (pvalue->u.fecMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245FECMode (pctxt, pvalue->u.fecMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "fecMode", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223ModeParameters_adaptationLayerType_al3                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223ModeParameters_adaptationLayerType_al3 (OOCTXT* pctxt, H245H223ModeParameters_adaptationLayerType_al3* pvalue)
{
   int stat = ASN_OK;

   /* decode controlFieldOctets */

   rtInvokeStartElement (pctxt, "controlFieldOctets", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->controlFieldOctets, 0U, 2U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->controlFieldOctets);

   rtInvokeEndElement (pctxt, "controlFieldOctets", -1);

   /* decode sendBufferSize */

   rtInvokeStartElement (pctxt, "sendBufferSize", -1);

   stat = decodeConsUnsigned (pctxt, &pvalue->sendBufferSize, 0U, 16777215U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->sendBufferSize);

   rtInvokeEndElement (pctxt, "sendBufferSize", -1);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223ModeParameters_adaptationLayerType                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223ModeParameters_adaptationLayerType (OOCTXT* pctxt, H245H223ModeParameters_adaptationLayerType* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 5);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* al1Framed */
         case 1:
            rtInvokeStartElement (pctxt, "al1Framed", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "al1Framed", -1);

            break;

         /* al1NotFramed */
         case 2:
            rtInvokeStartElement (pctxt, "al1NotFramed", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "al1NotFramed", -1);

            break;

         /* al2WithoutSequenceNumbers */
         case 3:
            rtInvokeStartElement (pctxt, "al2WithoutSequenceNumbers", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "al2WithoutSequenceNumbers", -1);

            break;

         /* al2WithSequenceNumbers */
         case 4:
            rtInvokeStartElement (pctxt, "al2WithSequenceNumbers", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "al2WithSequenceNumbers", -1);

            break;

         /* al3 */
         case 5:
            rtInvokeStartElement (pctxt, "al3", -1);

            pvalue->u.al3 = ALLOC_ASN1ELEM (pctxt, H245H223ModeParameters_adaptationLayerType_al3);
            if (pvalue->u.al3 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H223ModeParameters_adaptationLayerType_al3 (pctxt, pvalue->u.al3);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "al3", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 7;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* al1M */
         case 7:
            rtInvokeStartElement (pctxt, "al1M", -1);

            pvalue->u.al1M = ALLOC_ASN1ELEM (pctxt, H245H223AL1MParameters);
            if (pvalue->u.al1M == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H223AL1MParameters (pctxt, pvalue->u.al1M);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "al1M", -1);

            break;

         /* al2M */
         case 8:
            rtInvokeStartElement (pctxt, "al2M", -1);

            pvalue->u.al2M = ALLOC_ASN1ELEM (pctxt, H245H223AL2MParameters);
            if (pvalue->u.al2M == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H223AL2MParameters (pctxt, pvalue->u.al2M);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "al2M", -1);

            break;

         /* al3M */
         case 9:
            rtInvokeStartElement (pctxt, "al3M", -1);

            pvalue->u.al3M = ALLOC_ASN1ELEM (pctxt, H245H223AL3MParameters);
            if (pvalue->u.al3M == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H223AL3MParameters (pctxt, pvalue->u.al3M);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "al3M", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223ModeParameters                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223ModeParameters (OOCTXT* pctxt, H245H223ModeParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode adaptationLayerType */

   rtInvokeStartElement (pctxt, "adaptationLayerType", -1);

   stat = asn1PD_H245H223ModeParameters_adaptationLayerType (pctxt, &pvalue->adaptationLayerType);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "adaptationLayerType", -1);

   /* decode segmentableFlag */

   rtInvokeStartElement (pctxt, "segmentableFlag", -1);

   stat = DECODEBIT (pctxt, &pvalue->segmentableFlag);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->segmentableFlag);

   rtInvokeEndElement (pctxt, "segmentableFlag", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  V76ModeParameters                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245V76ModeParameters (OOCTXT* pctxt, H245V76ModeParameters* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* suspendResumewAddress */
         case 0:
            rtInvokeStartElement (pctxt, "suspendResumewAddress", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "suspendResumewAddress", -1);

            break;

         /* suspendResumewoAddress */
         case 1:
            rtInvokeStartElement (pctxt, "suspendResumewoAddress", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "suspendResumewoAddress", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RedundancyEncodingMode_secondaryEncoding                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RedundancyEncodingMode_secondaryEncoding (OOCTXT* pctxt, H245RedundancyEncodingMode_secondaryEncoding* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* audioData */
         case 1:
            rtInvokeStartElement (pctxt, "audioData", -1);

            pvalue->u.audioData = ALLOC_ASN1ELEM (pctxt, H245AudioMode);
            if (pvalue->u.audioData == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245AudioMode (pctxt, pvalue->u.audioData);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "audioData", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RedundancyEncodingMode                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RedundancyEncodingMode (OOCTXT* pctxt, H245RedundancyEncodingMode* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.secondaryEncodingPresent = optbit;

   /* decode redundancyEncodingMethod */

   rtInvokeStartElement (pctxt, "redundancyEncodingMethod", -1);

   stat = asn1PD_H245RedundancyEncodingMethod (pctxt, &pvalue->redundancyEncodingMethod);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "redundancyEncodingMethod", -1);

   /* decode secondaryEncoding */

   if (pvalue->m.secondaryEncodingPresent) {
      rtInvokeStartElement (pctxt, "secondaryEncoding", -1);

      stat = asn1PD_H245RedundancyEncodingMode_secondaryEncoding (pctxt, &pvalue->secondaryEncoding);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "secondaryEncoding", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H2250ModeParameters                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H2250ModeParameters (OOCTXT* pctxt, H245H2250ModeParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.redundancyEncodingModePresent = optbit;

   /* decode redundancyEncodingMode */

   if (pvalue->m.redundancyEncodingModePresent) {
      rtInvokeStartElement (pctxt, "redundancyEncodingMode", -1);

      stat = asn1PD_H245RedundancyEncodingMode (pctxt, &pvalue->redundancyEncodingMode);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "redundancyEncodingMode", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexedStreamModeParameters                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplexedStreamModeParameters (OOCTXT* pctxt, H245MultiplexedStreamModeParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode logicalChannelNumber */

   rtInvokeStartElement (pctxt, "logicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "logicalChannelNumber", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ModeElement                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ModeElement (OOCTXT* pctxt, H245ModeElement* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.h223ModeParametersPresent = optbit;

   /* decode type */

   rtInvokeStartElement (pctxt, "type", -1);

   stat = asn1PD_H245ModeElementType (pctxt, &pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "type", -1);

   /* decode h223ModeParameters */

   if (pvalue->m.h223ModeParametersPresent) {
      rtInvokeStartElement (pctxt, "h223ModeParameters", -1);

      stat = asn1PD_H245H223ModeParameters (pctxt, &pvalue->h223ModeParameters);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "h223ModeParameters", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 4 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.v76ModeParametersPresent = 1;

                     rtInvokeStartElement (pctxt, "v76ModeParameters", -1);

                     stat = asn1PD_H245V76ModeParameters (pctxt, &pvalue->v76ModeParameters);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "v76ModeParameters", -1);
                     break;

                  case 1:
                     pvalue->m.h2250ModeParametersPresent = 1;

                     rtInvokeStartElement (pctxt, "h2250ModeParameters", -1);

                     stat = asn1PD_H245H2250ModeParameters (pctxt, &pvalue->h2250ModeParameters);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "h2250ModeParameters", -1);
                     break;

                  case 2:
                     pvalue->m.genericModeParametersPresent = 1;

                     rtInvokeStartElement (pctxt, "genericModeParameters", -1);

                     stat = asn1PD_H245GenericCapability (pctxt, &pvalue->genericModeParameters);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "genericModeParameters", -1);
                     break;

                  case 3:
                     pvalue->m.multiplexedStreamModeParametersPresent = 1;

                     rtInvokeStartElement (pctxt, "multiplexedStreamModeParameters", -1);

                     stat = asn1PD_H245MultiplexedStreamModeParameters (pctxt, &pvalue->multiplexedStreamModeParameters);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "multiplexedStreamModeParameters", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 4) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ModeDescription                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ModeDescription (OOCTXT* pctxt, H245ModeDescription* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   H245ModeElement* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245ModeElement);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245ModeElement (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestMode_requestedModes                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestMode_requestedModes (OOCTXT* pctxt, H245RequestMode_requestedModes* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   H245ModeDescription* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245ModeDescription);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245ModeDescription (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestMode                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestMode (OOCTXT* pctxt, H245RequestMode* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode sequenceNumber */

   rtInvokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode requestedModes */

   rtInvokeStartElement (pctxt, "requestedModes", -1);

   stat = asn1PD_H245RequestMode_requestedModes (pctxt, &pvalue->requestedModes);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "requestedModes", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RoundTripDelayRequest                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RoundTripDelayRequest (OOCTXT* pctxt, H245RoundTripDelayRequest* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode sequenceNumber */

   rtInvokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "sequenceNumber", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaintenanceLoopRequest_type                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MaintenanceLoopRequest_type (OOCTXT* pctxt, H245MaintenanceLoopRequest_type* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* systemLoop */
         case 0:
            rtInvokeStartElement (pctxt, "systemLoop", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "systemLoop", -1);

            break;

         /* mediaLoop */
         case 1:
            rtInvokeStartElement (pctxt, "mediaLoop", -1);

            stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.mediaLoop);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "mediaLoop", -1);

            break;

         /* logicalChannelLoop */
         case 2:
            rtInvokeStartElement (pctxt, "logicalChannelLoop", -1);

            stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.logicalChannelLoop);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "logicalChannelLoop", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaintenanceLoopRequest                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MaintenanceLoopRequest (OOCTXT* pctxt, H245MaintenanceLoopRequest* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode type */

   rtInvokeStartElement (pctxt, "type", -1);

   stat = asn1PD_H245MaintenanceLoopRequest_type (pctxt, &pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "type", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommunicationModeRequest                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CommunicationModeRequest (OOCTXT* pctxt, H245CommunicationModeRequest* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Criteria                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245Criteria (OOCTXT* pctxt, H245Criteria* pvalue)
{
   static Asn1SizeCnst value_lsize1 = { 0, 1, 65535, 0 };
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode field */

   rtInvokeStartElement (pctxt, "field", -1);

   stat = decodeObjectIdentifier (pctxt, &pvalue->field);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOidValue (pctxt, pvalue->field.numids, pvalue->field.subid);

   rtInvokeEndElement (pctxt, "field", -1);

   /* decode value */

   rtInvokeStartElement (pctxt, "value", -1);

   stat = addSizeConstraint (pctxt, &value_lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->value);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeOctStrValue (pctxt, pvalue->value.numocts, pvalue->value.data);

   rtInvokeEndElement (pctxt, "value", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CertSelectionCriteria                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CertSelectionCriteria (OOCTXT* pctxt, H245CertSelectionCriteria* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 16, 0 };
   int stat = ASN_OK;
   H245Criteria* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245Criteria);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245Criteria (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConferenceRequest_requestTerminalCertificate              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ConferenceRequest_requestTerminalCertificate (OOCTXT* pctxt, H245ConferenceRequest_requestTerminalCertificate* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.terminalLabelPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.certSelectionCriteriaPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sRandomPresent = optbit;

   /* decode terminalLabel */

   if (pvalue->m.terminalLabelPresent) {
      rtInvokeStartElement (pctxt, "terminalLabel", -1);

      stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->terminalLabel);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "terminalLabel", -1);
   }

   /* decode certSelectionCriteria */

   if (pvalue->m.certSelectionCriteriaPresent) {
      rtInvokeStartElement (pctxt, "certSelectionCriteria", -1);

      stat = asn1PD_H245CertSelectionCriteria (pctxt, &pvalue->certSelectionCriteria);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "certSelectionCriteria", -1);
   }

   /* decode sRandom */

   if (pvalue->m.sRandomPresent) {
      rtInvokeStartElement (pctxt, "sRandom", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->sRandom, 1U, ASN1UINT_MAX);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->sRandom);

      rtInvokeEndElement (pctxt, "sRandom", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RemoteMCRequest                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RemoteMCRequest (OOCTXT* pctxt, H245RemoteMCRequest* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* masterActivate */
         case 0:
            rtInvokeStartElement (pctxt, "masterActivate", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "masterActivate", -1);

            break;

         /* slaveActivate */
         case 1:
            rtInvokeStartElement (pctxt, "slaveActivate", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "slaveActivate", -1);

            break;

         /* deActivate */
         case 2:
            rtInvokeStartElement (pctxt, "deActivate", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "deActivate", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConferenceRequest                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ConferenceRequest (OOCTXT* pctxt, H245ConferenceRequest* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 7);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* terminalListRequest */
         case 0:
            rtInvokeStartElement (pctxt, "terminalListRequest", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "terminalListRequest", -1);

            break;

         /* makeMeChair */
         case 1:
            rtInvokeStartElement (pctxt, "makeMeChair", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "makeMeChair", -1);

            break;

         /* cancelMakeMeChair */
         case 2:
            rtInvokeStartElement (pctxt, "cancelMakeMeChair", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "cancelMakeMeChair", -1);

            break;

         /* dropTerminal */
         case 3:
            rtInvokeStartElement (pctxt, "dropTerminal", -1);

            pvalue->u.dropTerminal = ALLOC_ASN1ELEM (pctxt, H245TerminalLabel);
            if (pvalue->u.dropTerminal == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245TerminalLabel (pctxt, pvalue->u.dropTerminal);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "dropTerminal", -1);

            break;

         /* requestTerminalID */
         case 4:
            rtInvokeStartElement (pctxt, "requestTerminalID", -1);

            pvalue->u.requestTerminalID = ALLOC_ASN1ELEM (pctxt, H245TerminalLabel);
            if (pvalue->u.requestTerminalID == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245TerminalLabel (pctxt, pvalue->u.requestTerminalID);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "requestTerminalID", -1);

            break;

         /* enterH243Password */
         case 5:
            rtInvokeStartElement (pctxt, "enterH243Password", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "enterH243Password", -1);

            break;

         /* enterH243TerminalID */
         case 6:
            rtInvokeStartElement (pctxt, "enterH243TerminalID", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "enterH243TerminalID", -1);

            break;

         /* enterH243ConferenceID */
         case 7:
            rtInvokeStartElement (pctxt, "enterH243ConferenceID", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "enterH243ConferenceID", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 9;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* enterExtensionAddress */
         case 9:
            rtInvokeStartElement (pctxt, "enterExtensionAddress", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "enterExtensionAddress", -1);

            break;

         /* requestChairTokenOwner */
         case 10:
            rtInvokeStartElement (pctxt, "requestChairTokenOwner", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "requestChairTokenOwner", -1);

            break;

         /* requestTerminalCertificate */
         case 11:
            rtInvokeStartElement (pctxt, "requestTerminalCertificate", -1);

            pvalue->u.requestTerminalCertificate = ALLOC_ASN1ELEM (pctxt, H245ConferenceRequest_requestTerminalCertificate);
            if (pvalue->u.requestTerminalCertificate == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245ConferenceRequest_requestTerminalCertificate (pctxt, pvalue->u.requestTerminalCertificate);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "requestTerminalCertificate", -1);

            break;

         /* broadcastMyLogicalChannel */
         case 12:
            rtInvokeStartElement (pctxt, "broadcastMyLogicalChannel", -1);

            stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.broadcastMyLogicalChannel);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "broadcastMyLogicalChannel", -1);

            break;

         /* makeTerminalBroadcaster */
         case 13:
            rtInvokeStartElement (pctxt, "makeTerminalBroadcaster", -1);

            pvalue->u.makeTerminalBroadcaster = ALLOC_ASN1ELEM (pctxt, H245TerminalLabel);
            if (pvalue->u.makeTerminalBroadcaster == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245TerminalLabel (pctxt, pvalue->u.makeTerminalBroadcaster);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "makeTerminalBroadcaster", -1);

            break;

         /* sendThisSource */
         case 14:
            rtInvokeStartElement (pctxt, "sendThisSource", -1);

            pvalue->u.sendThisSource = ALLOC_ASN1ELEM (pctxt, H245TerminalLabel);
            if (pvalue->u.sendThisSource == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245TerminalLabel (pctxt, pvalue->u.sendThisSource);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "sendThisSource", -1);

            break;

         /* requestAllTerminalIDs */
         case 15:
            rtInvokeStartElement (pctxt, "requestAllTerminalIDs", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "requestAllTerminalIDs", -1);

            break;

         /* remoteMCRequest */
         case 16:
            rtInvokeStartElement (pctxt, "remoteMCRequest", -1);

            pvalue->u.remoteMCRequest = ALLOC_ASN1ELEM (pctxt, H245RemoteMCRequest);
            if (pvalue->u.remoteMCRequest == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RemoteMCRequest (pctxt, pvalue->u.remoteMCRequest);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "remoteMCRequest", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultilinkRequest_callInformation                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultilinkRequest_callInformation (OOCTXT* pctxt, H245MultilinkRequest_callInformation* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode maxNumberOfAdditionalConnections */

   rtInvokeStartElement (pctxt, "maxNumberOfAdditionalConnections", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maxNumberOfAdditionalConnections, 1U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maxNumberOfAdditionalConnections);

   rtInvokeEndElement (pctxt, "maxNumberOfAdditionalConnections", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DialingInformationNetworkType                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245DialingInformationNetworkType (OOCTXT* pctxt, H245DialingInformationNetworkType* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardMessage);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardMessage (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* n_isdn */
         case 1:
            rtInvokeStartElement (pctxt, "n_isdn", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "n_isdn", -1);

            break;

         /* gstn */
         case 2:
            rtInvokeStartElement (pctxt, "gstn", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "gstn", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* mobile */
         case 4:
            rtInvokeStartElement (pctxt, "mobile", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "mobile", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DialingInformationNumber_networkType                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245DialingInformationNumber_networkType (OOCTXT* pctxt, H245DialingInformationNumber_networkType* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 255, 0 };
   int stat = ASN_OK;
   H245DialingInformationNetworkType* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245DialingInformationNetworkType);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245DialingInformationNetworkType (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DialingInformationNumber                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245DialingInformationNumber (OOCTXT* pctxt, H245DialingInformationNumber* pvalue)
{
   static Asn1SizeCnst networkAddress_lsize1 = { 0, 0, 40, 0 };
   static Asn1SizeCnst subAddress_lsize1 = { 0, 1, 40, 0 };
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.subAddressPresent = optbit;

   /* decode networkAddress */

   rtInvokeStartElement (pctxt, "networkAddress", -1);

   stat = addSizeConstraint (pctxt, &networkAddress_lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeConstrainedStringEx (pctxt, &pvalue->networkAddress, NUM_CANSET, 4, 4, 4);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeCharStrValue (pctxt, pvalue->networkAddress);

   rtInvokeEndElement (pctxt, "networkAddress", -1);

   /* decode subAddress */

   if (pvalue->m.subAddressPresent) {
      rtInvokeStartElement (pctxt, "subAddress", -1);

      stat = addSizeConstraint (pctxt, &subAddress_lsize1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeConstrainedStringEx (pctxt, &pvalue->subAddress, 0, 8, 7, 7);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeCharStrValue (pctxt, pvalue->subAddress);

      rtInvokeEndElement (pctxt, "subAddress", -1);
   }

   /* decode networkType */

   rtInvokeStartElement (pctxt, "networkType", -1);

   stat = asn1PD_H245DialingInformationNumber_networkType (pctxt, &pvalue->networkType);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "networkType", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DialingInformation_differential                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245DialingInformation_differential (OOCTXT* pctxt, H245DialingInformation_differential* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 65535, 0 };
   int stat = ASN_OK;
   H245DialingInformationNumber* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245DialingInformationNumber);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245DialingInformationNumber (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DialingInformation                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245DialingInformation (OOCTXT* pctxt, H245DialingInformation* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardMessage);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardMessage (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* differential */
         case 1:
            rtInvokeStartElement (pctxt, "differential", -1);

            pvalue->u.differential = ALLOC_ASN1ELEM (pctxt, H245DialingInformation_differential);
            if (pvalue->u.differential == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DialingInformation_differential (pctxt, pvalue->u.differential);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "differential", -1);

            break;

         /* infoNotAvailable */
         case 2:
            rtInvokeStartElement (pctxt, "infoNotAvailable", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.infoNotAvailable, 1U, 65535U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.infoNotAvailable);

            rtInvokeEndElement (pctxt, "infoNotAvailable", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultilinkRequest_addConnection                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultilinkRequest_addConnection (OOCTXT* pctxt, H245MultilinkRequest_addConnection* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode sequenceNumber */

   rtInvokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode dialingInformation */

   rtInvokeStartElement (pctxt, "dialingInformation", -1);

   stat = asn1PD_H245DialingInformation (pctxt, &pvalue->dialingInformation);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "dialingInformation", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConnectionIdentifier                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ConnectionIdentifier (OOCTXT* pctxt, H245ConnectionIdentifier* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode channelTag */

   rtInvokeStartElement (pctxt, "channelTag", -1);

   stat = decodeConsUnsigned (pctxt, &pvalue->channelTag, 0U, ASN1UINT_MAX);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->channelTag);

   rtInvokeEndElement (pctxt, "channelTag", -1);

   /* decode sequenceNumber */

   rtInvokeStartElement (pctxt, "sequenceNumber", -1);

   stat = decodeConsUnsigned (pctxt, &pvalue->sequenceNumber, 0U, ASN1UINT_MAX);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->sequenceNumber);

   rtInvokeEndElement (pctxt, "sequenceNumber", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultilinkRequest_removeConnection                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultilinkRequest_removeConnection (OOCTXT* pctxt, H245MultilinkRequest_removeConnection* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode connectionIdentifier */

   rtInvokeStartElement (pctxt, "connectionIdentifier", -1);

   stat = asn1PD_H245ConnectionIdentifier (pctxt, &pvalue->connectionIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "connectionIdentifier", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultilinkRequest_maximumHeaderInterval_requestType        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultilinkRequest_maximumHeaderInterval_requestType (OOCTXT* pctxt, H245MultilinkRequest_maximumHeaderInterval_requestType* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* currentIntervalInformation */
         case 0:
            rtInvokeStartElement (pctxt, "currentIntervalInformation", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "currentIntervalInformation", -1);

            break;

         /* requestedInterval */
         case 1:
            rtInvokeStartElement (pctxt, "requestedInterval", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.requestedInterval, 0U, 65535U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.requestedInterval);

            rtInvokeEndElement (pctxt, "requestedInterval", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultilinkRequest_maximumHeaderInterval                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultilinkRequest_maximumHeaderInterval (OOCTXT* pctxt, H245MultilinkRequest_maximumHeaderInterval* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode requestType */

   rtInvokeStartElement (pctxt, "requestType", -1);

   stat = asn1PD_H245MultilinkRequest_maximumHeaderInterval_requestType (pctxt, &pvalue->requestType);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "requestType", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultilinkRequest                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultilinkRequest (OOCTXT* pctxt, H245MultilinkRequest* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 4);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardMessage);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardMessage (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* callInformation */
         case 1:
            rtInvokeStartElement (pctxt, "callInformation", -1);

            pvalue->u.callInformation = ALLOC_ASN1ELEM (pctxt, H245MultilinkRequest_callInformation);
            if (pvalue->u.callInformation == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultilinkRequest_callInformation (pctxt, pvalue->u.callInformation);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "callInformation", -1);

            break;

         /* addConnection */
         case 2:
            rtInvokeStartElement (pctxt, "addConnection", -1);

            pvalue->u.addConnection = ALLOC_ASN1ELEM (pctxt, H245MultilinkRequest_addConnection);
            if (pvalue->u.addConnection == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultilinkRequest_addConnection (pctxt, pvalue->u.addConnection);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "addConnection", -1);

            break;

         /* removeConnection */
         case 3:
            rtInvokeStartElement (pctxt, "removeConnection", -1);

            pvalue->u.removeConnection = ALLOC_ASN1ELEM (pctxt, H245MultilinkRequest_removeConnection);
            if (pvalue->u.removeConnection == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultilinkRequest_removeConnection (pctxt, pvalue->u.removeConnection);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "removeConnection", -1);

            break;

         /* maximumHeaderInterval */
         case 4:
            rtInvokeStartElement (pctxt, "maximumHeaderInterval", -1);

            pvalue->u.maximumHeaderInterval = ALLOC_ASN1ELEM (pctxt, H245MultilinkRequest_maximumHeaderInterval);
            if (pvalue->u.maximumHeaderInterval == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultilinkRequest_maximumHeaderInterval (pctxt, pvalue->u.maximumHeaderInterval);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "maximumHeaderInterval", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 6;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LogicalChannelRateRequest                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245LogicalChannelRateRequest (OOCTXT* pctxt, H245LogicalChannelRateRequest* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode sequenceNumber */

   rtInvokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode logicalChannelNumber */

   rtInvokeStartElement (pctxt, "logicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "logicalChannelNumber", -1);

   /* decode maximumBitRate */

   rtInvokeStartElement (pctxt, "maximumBitRate", -1);

   stat = asn1PD_H245MaximumBitRate (pctxt, &pvalue->maximumBitRate);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "maximumBitRate", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestMessage                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestMessage (OOCTXT* pctxt, H245RequestMessage* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 10);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardMessage);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardMessage (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* masterSlaveDetermination */
         case 1:
            rtInvokeStartElement (pctxt, "masterSlaveDetermination", -1);

            pvalue->u.masterSlaveDetermination = ALLOC_ASN1ELEM (pctxt, H245MasterSlaveDetermination);
            if (pvalue->u.masterSlaveDetermination == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MasterSlaveDetermination (pctxt, pvalue->u.masterSlaveDetermination);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "masterSlaveDetermination", -1);

            break;

         /* terminalCapabilitySet */
         case 2:
            rtInvokeStartElement (pctxt, "terminalCapabilitySet", -1);

            pvalue->u.terminalCapabilitySet = ALLOC_ASN1ELEM (pctxt, H245TerminalCapabilitySet);
            if (pvalue->u.terminalCapabilitySet == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245TerminalCapabilitySet (pctxt, pvalue->u.terminalCapabilitySet);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "terminalCapabilitySet", -1);

            break;

         /* openLogicalChannel */
         case 3:
            rtInvokeStartElement (pctxt, "openLogicalChannel", -1);

            pvalue->u.openLogicalChannel = ALLOC_ASN1ELEM (pctxt, H245OpenLogicalChannel);
            if (pvalue->u.openLogicalChannel == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245OpenLogicalChannel (pctxt, pvalue->u.openLogicalChannel);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "openLogicalChannel", -1);

            break;

         /* closeLogicalChannel */
         case 4:
            rtInvokeStartElement (pctxt, "closeLogicalChannel", -1);

            pvalue->u.closeLogicalChannel = ALLOC_ASN1ELEM (pctxt, H245CloseLogicalChannel);
            if (pvalue->u.closeLogicalChannel == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245CloseLogicalChannel (pctxt, pvalue->u.closeLogicalChannel);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "closeLogicalChannel", -1);

            break;

         /* requestChannelClose */
         case 5:
            rtInvokeStartElement (pctxt, "requestChannelClose", -1);

            pvalue->u.requestChannelClose = ALLOC_ASN1ELEM (pctxt, H245RequestChannelClose);
            if (pvalue->u.requestChannelClose == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RequestChannelClose (pctxt, pvalue->u.requestChannelClose);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "requestChannelClose", -1);

            break;

         /* multiplexEntrySend */
         case 6:
            rtInvokeStartElement (pctxt, "multiplexEntrySend", -1);

            pvalue->u.multiplexEntrySend = ALLOC_ASN1ELEM (pctxt, H245MultiplexEntrySend);
            if (pvalue->u.multiplexEntrySend == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultiplexEntrySend (pctxt, pvalue->u.multiplexEntrySend);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "multiplexEntrySend", -1);

            break;

         /* requestMultiplexEntry */
         case 7:
            rtInvokeStartElement (pctxt, "requestMultiplexEntry", -1);

            pvalue->u.requestMultiplexEntry = ALLOC_ASN1ELEM (pctxt, H245RequestMultiplexEntry);
            if (pvalue->u.requestMultiplexEntry == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RequestMultiplexEntry (pctxt, pvalue->u.requestMultiplexEntry);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "requestMultiplexEntry", -1);

            break;

         /* requestMode */
         case 8:
            rtInvokeStartElement (pctxt, "requestMode", -1);

            pvalue->u.requestMode = ALLOC_ASN1ELEM (pctxt, H245RequestMode);
            if (pvalue->u.requestMode == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RequestMode (pctxt, pvalue->u.requestMode);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "requestMode", -1);

            break;

         /* roundTripDelayRequest */
         case 9:
            rtInvokeStartElement (pctxt, "roundTripDelayRequest", -1);

            pvalue->u.roundTripDelayRequest = ALLOC_ASN1ELEM (pctxt, H245RoundTripDelayRequest);
            if (pvalue->u.roundTripDelayRequest == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RoundTripDelayRequest (pctxt, pvalue->u.roundTripDelayRequest);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "roundTripDelayRequest", -1);

            break;

         /* maintenanceLoopRequest */
         case 10:
            rtInvokeStartElement (pctxt, "maintenanceLoopRequest", -1);

            pvalue->u.maintenanceLoopRequest = ALLOC_ASN1ELEM (pctxt, H245MaintenanceLoopRequest);
            if (pvalue->u.maintenanceLoopRequest == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MaintenanceLoopRequest (pctxt, pvalue->u.maintenanceLoopRequest);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "maintenanceLoopRequest", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 12;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* communicationModeRequest */
         case 12:
            rtInvokeStartElement (pctxt, "communicationModeRequest", -1);

            pvalue->u.communicationModeRequest = ALLOC_ASN1ELEM (pctxt, H245CommunicationModeRequest);
            if (pvalue->u.communicationModeRequest == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245CommunicationModeRequest (pctxt, pvalue->u.communicationModeRequest);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "communicationModeRequest", -1);

            break;

         /* conferenceRequest */
         case 13:
            rtInvokeStartElement (pctxt, "conferenceRequest", -1);

            pvalue->u.conferenceRequest = ALLOC_ASN1ELEM (pctxt, H245ConferenceRequest);
            if (pvalue->u.conferenceRequest == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245ConferenceRequest (pctxt, pvalue->u.conferenceRequest);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "conferenceRequest", -1);

            break;

         /* multilinkRequest */
         case 14:
            rtInvokeStartElement (pctxt, "multilinkRequest", -1);

            pvalue->u.multilinkRequest = ALLOC_ASN1ELEM (pctxt, H245MultilinkRequest);
            if (pvalue->u.multilinkRequest == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultilinkRequest (pctxt, pvalue->u.multilinkRequest);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "multilinkRequest", -1);

            break;

         /* logicalChannelRateRequest */
         case 15:
            rtInvokeStartElement (pctxt, "logicalChannelRateRequest", -1);

            pvalue->u.logicalChannelRateRequest = ALLOC_ASN1ELEM (pctxt, H245LogicalChannelRateRequest);
            if (pvalue->u.logicalChannelRateRequest == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245LogicalChannelRateRequest (pctxt, pvalue->u.logicalChannelRateRequest);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "logicalChannelRateRequest", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MasterSlaveDeterminationAck_decision                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MasterSlaveDeterminationAck_decision (OOCTXT* pctxt, H245MasterSlaveDeterminationAck_decision* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* master */
      case 0:
         rtInvokeStartElement (pctxt, "master", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "master", -1);

         break;

      /* slave */
      case 1:
         rtInvokeStartElement (pctxt, "slave", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "slave", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MasterSlaveDeterminationAck                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MasterSlaveDeterminationAck (OOCTXT* pctxt, H245MasterSlaveDeterminationAck* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode decision */

   rtInvokeStartElement (pctxt, "decision", -1);

   stat = asn1PD_H245MasterSlaveDeterminationAck_decision (pctxt, &pvalue->decision);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "decision", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MasterSlaveDeterminationReject_cause                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MasterSlaveDeterminationReject_cause (OOCTXT* pctxt, H245MasterSlaveDeterminationReject_cause* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* identicalNumbers */
         case 0:
            rtInvokeStartElement (pctxt, "identicalNumbers", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "identicalNumbers", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MasterSlaveDeterminationReject                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MasterSlaveDeterminationReject (OOCTXT* pctxt, H245MasterSlaveDeterminationReject* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode cause */

   rtInvokeStartElement (pctxt, "cause", -1);

   stat = asn1PD_H245MasterSlaveDeterminationReject_cause (pctxt, &pvalue->cause);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "cause", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalCapabilitySetAck                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245TerminalCapabilitySetAck (OOCTXT* pctxt, H245TerminalCapabilitySetAck* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode sequenceNumber */

   rtInvokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "sequenceNumber", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalCapabilitySetReject_cause_tableEntryCapacityExce  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded (OOCTXT* pctxt, H245TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* highestEntryNumberProcessed */
      case 0:
         rtInvokeStartElement (pctxt, "highestEntryNumberProcessed", -1);

         stat = asn1PD_H245CapabilityTableEntryNumber (pctxt, &pvalue->u.highestEntryNumberProcessed);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

         rtInvokeEndElement (pctxt, "highestEntryNumberProcessed", -1);

         break;

      /* noneProcessed */
      case 1:
         rtInvokeStartElement (pctxt, "noneProcessed", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "noneProcessed", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalCapabilitySetReject_cause                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245TerminalCapabilitySetReject_cause (OOCTXT* pctxt, H245TerminalCapabilitySetReject_cause* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* unspecified */
         case 0:
            rtInvokeStartElement (pctxt, "unspecified", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "unspecified", -1);

            break;

         /* undefinedTableEntryUsed */
         case 1:
            rtInvokeStartElement (pctxt, "undefinedTableEntryUsed", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "undefinedTableEntryUsed", -1);

            break;

         /* descriptorCapacityExceeded */
         case 2:
            rtInvokeStartElement (pctxt, "descriptorCapacityExceeded", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "descriptorCapacityExceeded", -1);

            break;

         /* tableEntryCapacityExceeded */
         case 3:
            rtInvokeStartElement (pctxt, "tableEntryCapacityExceeded", -1);

            pvalue->u.tableEntryCapacityExceeded = ALLOC_ASN1ELEM (pctxt, H245TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded);
            if (pvalue->u.tableEntryCapacityExceeded == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded (pctxt, pvalue->u.tableEntryCapacityExceeded);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "tableEntryCapacityExceeded", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalCapabilitySetReject                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245TerminalCapabilitySetReject (OOCTXT* pctxt, H245TerminalCapabilitySetReject* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode sequenceNumber */

   rtInvokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode cause */

   rtInvokeStartElement (pctxt, "cause", -1);

   stat = asn1PD_H245TerminalCapabilitySetReject_cause (pctxt, &pvalue->cause);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "cause", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OpenLogicalChannelAck_reverseLogicalChannelParameters_mu  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters (OOCTXT* pctxt, H245OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* h222LogicalChannelParameters */
         case 0:
            rtInvokeStartElement (pctxt, "h222LogicalChannelParameters", -1);

            pvalue->u.h222LogicalChannelParameters = ALLOC_ASN1ELEM (pctxt, H245H222LogicalChannelParameters);
            if (pvalue->u.h222LogicalChannelParameters == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H222LogicalChannelParameters (pctxt, pvalue->u.h222LogicalChannelParameters);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h222LogicalChannelParameters", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* h2250LogicalChannelParameters */
         case 2:
            rtInvokeStartElement (pctxt, "h2250LogicalChannelParameters", -1);

            pvalue->u.h2250LogicalChannelParameters = ALLOC_ASN1ELEM (pctxt, H245H2250LogicalChannelParameters);
            if (pvalue->u.h2250LogicalChannelParameters == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H2250LogicalChannelParameters (pctxt, pvalue->u.h2250LogicalChannelParameters);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h2250LogicalChannelParameters", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OpenLogicalChannelAck_reverseLogicalChannelParameters     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245OpenLogicalChannelAck_reverseLogicalChannelParameters (OOCTXT* pctxt, H245OpenLogicalChannelAck_reverseLogicalChannelParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.portNumberPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.multiplexParametersPresent = optbit;

   /* decode reverseLogicalChannelNumber */

   rtInvokeStartElement (pctxt, "reverseLogicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->reverseLogicalChannelNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "reverseLogicalChannelNumber", -1);

   /* decode portNumber */

   if (pvalue->m.portNumberPresent) {
      rtInvokeStartElement (pctxt, "portNumber", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->portNumber, 0U, 65535U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->portNumber);

      rtInvokeEndElement (pctxt, "portNumber", -1);
   }

   /* decode multiplexParameters */

   if (pvalue->m.multiplexParametersPresent) {
      rtInvokeStartElement (pctxt, "multiplexParameters", -1);

      stat = asn1PD_H245OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters (pctxt, &pvalue->multiplexParameters);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "multiplexParameters", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 1 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.replacementForPresent = 1;

                     rtInvokeStartElement (pctxt, "replacementFor", -1);

                     stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->replacementFor);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "replacementFor", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 1) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H2250LogicalChannelAckParameters                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H2250LogicalChannelAckParameters (OOCTXT* pctxt, H245H2250LogicalChannelAckParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sessionIDPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mediaChannelPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mediaControlChannelPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dynamicRTPPayloadTypePresent = optbit;

   /* decode nonStandard */

   if (pvalue->m.nonStandardPresent) {
      rtInvokeStartElement (pctxt, "nonStandard", -1);

      stat = asn1PD_H245_SeqOfH245NonStandardParameter (pctxt, &pvalue->nonStandard);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "nonStandard", -1);
   }

   /* decode sessionID */

   if (pvalue->m.sessionIDPresent) {
      rtInvokeStartElement (pctxt, "sessionID", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->sessionID, 1U, 255U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->sessionID);

      rtInvokeEndElement (pctxt, "sessionID", -1);
   }

   /* decode mediaChannel */

   if (pvalue->m.mediaChannelPresent) {
      rtInvokeStartElement (pctxt, "mediaChannel", -1);

      stat = asn1PD_H245TransportAddress (pctxt, &pvalue->mediaChannel);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "mediaChannel", -1);
   }

   /* decode mediaControlChannel */

   if (pvalue->m.mediaControlChannelPresent) {
      rtInvokeStartElement (pctxt, "mediaControlChannel", -1);

      stat = asn1PD_H245TransportAddress (pctxt, &pvalue->mediaControlChannel);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "mediaControlChannel", -1);
   }

   /* decode dynamicRTPPayloadType */

   if (pvalue->m.dynamicRTPPayloadTypePresent) {
      rtInvokeStartElement (pctxt, "dynamicRTPPayloadType", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->dynamicRTPPayloadType, 96U, 127U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->dynamicRTPPayloadType);

      rtInvokeEndElement (pctxt, "dynamicRTPPayloadType", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 2 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.flowControlToZeroPresent = 1;

                     rtInvokeStartElement (pctxt, "flowControlToZero", -1);

                     stat = DECODEBIT (pctxt, &pvalue->flowControlToZero);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeBoolValue (pctxt, pvalue->flowControlToZero);

                     rtInvokeEndElement (pctxt, "flowControlToZero", -1);
                     break;

                  case 1:
                     pvalue->m.portNumberPresent = 1;

                     rtInvokeStartElement (pctxt, "portNumber", -1);

                     stat = decodeConsUInt16 (pctxt, &pvalue->portNumber, 0U, 65535U);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeUIntValue (pctxt, pvalue->portNumber);

                     rtInvokeEndElement (pctxt, "portNumber", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 2) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OpenLogicalChannelAck_forwardMultiplexAckParameters       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245OpenLogicalChannelAck_forwardMultiplexAckParameters (OOCTXT* pctxt, H245OpenLogicalChannelAck_forwardMultiplexAckParameters* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* h2250LogicalChannelAckParameters */
         case 0:
            rtInvokeStartElement (pctxt, "h2250LogicalChannelAckParameters", -1);

            pvalue->u.h2250LogicalChannelAckParameters = ALLOC_ASN1ELEM (pctxt, H245H2250LogicalChannelAckParameters);
            if (pvalue->u.h2250LogicalChannelAckParameters == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H2250LogicalChannelAckParameters (pctxt, pvalue->u.h2250LogicalChannelAckParameters);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h2250LogicalChannelAckParameters", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OpenLogicalChannelAck                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245OpenLogicalChannelAck (OOCTXT* pctxt, H245OpenLogicalChannelAck* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.reverseLogicalChannelParametersPresent = optbit;

   /* decode forwardLogicalChannelNumber */

   rtInvokeStartElement (pctxt, "forwardLogicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->forwardLogicalChannelNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "forwardLogicalChannelNumber", -1);

   /* decode reverseLogicalChannelParameters */

   if (pvalue->m.reverseLogicalChannelParametersPresent) {
      rtInvokeStartElement (pctxt, "reverseLogicalChannelParameters", -1);

      stat = asn1PD_H245OpenLogicalChannelAck_reverseLogicalChannelParameters (pctxt, &pvalue->reverseLogicalChannelParameters);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "reverseLogicalChannelParameters", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 3 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.separateStackPresent = 1;

                     rtInvokeStartElement (pctxt, "separateStack", -1);

                     stat = asn1PD_H245NetworkAccessParameters (pctxt, &pvalue->separateStack);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "separateStack", -1);
                     break;

                  case 1:
                     pvalue->m.forwardMultiplexAckParametersPresent = 1;

                     rtInvokeStartElement (pctxt, "forwardMultiplexAckParameters", -1);

                     stat = asn1PD_H245OpenLogicalChannelAck_forwardMultiplexAckParameters (pctxt, &pvalue->forwardMultiplexAckParameters);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "forwardMultiplexAckParameters", -1);
                     break;

                  case 2:
                     pvalue->m.encryptionSyncPresent = 1;

                     rtInvokeStartElement (pctxt, "encryptionSync", -1);

                     stat = asn1PD_H245EncryptionSync (pctxt, &pvalue->encryptionSync);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "encryptionSync", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 3) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OpenLogicalChannelReject_cause                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245OpenLogicalChannelReject_cause (OOCTXT* pctxt, H245OpenLogicalChannelReject_cause* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 5);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* unspecified */
         case 0:
            rtInvokeStartElement (pctxt, "unspecified", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "unspecified", -1);

            break;

         /* unsuitableReverseParameters */
         case 1:
            rtInvokeStartElement (pctxt, "unsuitableReverseParameters", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "unsuitableReverseParameters", -1);

            break;

         /* dataTypeNotSupported */
         case 2:
            rtInvokeStartElement (pctxt, "dataTypeNotSupported", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "dataTypeNotSupported", -1);

            break;

         /* dataTypeNotAvailable */
         case 3:
            rtInvokeStartElement (pctxt, "dataTypeNotAvailable", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "dataTypeNotAvailable", -1);

            break;

         /* unknownDataType */
         case 4:
            rtInvokeStartElement (pctxt, "unknownDataType", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "unknownDataType", -1);

            break;

         /* dataTypeALCombinationNotSupported */
         case 5:
            rtInvokeStartElement (pctxt, "dataTypeALCombinationNotSupported", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "dataTypeALCombinationNotSupported", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 7;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* multicastChannelNotAllowed */
         case 7:
            rtInvokeStartElement (pctxt, "multicastChannelNotAllowed", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "multicastChannelNotAllowed", -1);

            break;

         /* insufficientBandwidth */
         case 8:
            rtInvokeStartElement (pctxt, "insufficientBandwidth", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "insufficientBandwidth", -1);

            break;

         /* separateStackEstablishmentFailed */
         case 9:
            rtInvokeStartElement (pctxt, "separateStackEstablishmentFailed", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "separateStackEstablishmentFailed", -1);

            break;

         /* invalidSessionID */
         case 10:
            rtInvokeStartElement (pctxt, "invalidSessionID", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "invalidSessionID", -1);

            break;

         /* masterSlaveConflict */
         case 11:
            rtInvokeStartElement (pctxt, "masterSlaveConflict", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "masterSlaveConflict", -1);

            break;

         /* waitForCommunicationMode */
         case 12:
            rtInvokeStartElement (pctxt, "waitForCommunicationMode", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "waitForCommunicationMode", -1);

            break;

         /* invalidDependentChannel */
         case 13:
            rtInvokeStartElement (pctxt, "invalidDependentChannel", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "invalidDependentChannel", -1);

            break;

         /* replacementForRejected */
         case 14:
            rtInvokeStartElement (pctxt, "replacementForRejected", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "replacementForRejected", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OpenLogicalChannelReject                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245OpenLogicalChannelReject (OOCTXT* pctxt, H245OpenLogicalChannelReject* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode forwardLogicalChannelNumber */

   rtInvokeStartElement (pctxt, "forwardLogicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->forwardLogicalChannelNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "forwardLogicalChannelNumber", -1);

   /* decode cause */

   rtInvokeStartElement (pctxt, "cause", -1);

   stat = asn1PD_H245OpenLogicalChannelReject_cause (pctxt, &pvalue->cause);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "cause", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CloseLogicalChannelAck                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CloseLogicalChannelAck (OOCTXT* pctxt, H245CloseLogicalChannelAck* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode forwardLogicalChannelNumber */

   rtInvokeStartElement (pctxt, "forwardLogicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->forwardLogicalChannelNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "forwardLogicalChannelNumber", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestChannelCloseAck                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestChannelCloseAck (OOCTXT* pctxt, H245RequestChannelCloseAck* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode forwardLogicalChannelNumber */

   rtInvokeStartElement (pctxt, "forwardLogicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->forwardLogicalChannelNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "forwardLogicalChannelNumber", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestChannelCloseReject_cause                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestChannelCloseReject_cause (OOCTXT* pctxt, H245RequestChannelCloseReject_cause* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* unspecified */
         case 0:
            rtInvokeStartElement (pctxt, "unspecified", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "unspecified", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestChannelCloseReject                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestChannelCloseReject (OOCTXT* pctxt, H245RequestChannelCloseReject* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode forwardLogicalChannelNumber */

   rtInvokeStartElement (pctxt, "forwardLogicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->forwardLogicalChannelNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "forwardLogicalChannelNumber", -1);

   /* decode cause */

   rtInvokeStartElement (pctxt, "cause", -1);

   stat = asn1PD_H245RequestChannelCloseReject_cause (pctxt, &pvalue->cause);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "cause", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexEntrySendAck_multiplexTableEntryNumber           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplexEntrySendAck_multiplexTableEntryNumber (OOCTXT* pctxt, H245MultiplexEntrySendAck_multiplexTableEntryNumber* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 15, 0 };
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      stat = asn1PD_H245MultiplexTableEntryNumber (pctxt, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexEntrySendAck                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplexEntrySendAck (OOCTXT* pctxt, H245MultiplexEntrySendAck* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode sequenceNumber */

   rtInvokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode multiplexTableEntryNumber */

   rtInvokeStartElement (pctxt, "multiplexTableEntryNumber", -1);

   stat = asn1PD_H245MultiplexEntrySendAck_multiplexTableEntryNumber (pctxt, &pvalue->multiplexTableEntryNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "multiplexTableEntryNumber", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexEntryRejectionDescriptions_cause                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplexEntryRejectionDescriptions_cause (OOCTXT* pctxt, H245MultiplexEntryRejectionDescriptions_cause* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* unspecifiedCause */
         case 0:
            rtInvokeStartElement (pctxt, "unspecifiedCause", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "unspecifiedCause", -1);

            break;

         /* descriptorTooComplex */
         case 1:
            rtInvokeStartElement (pctxt, "descriptorTooComplex", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "descriptorTooComplex", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexEntryRejectionDescriptions                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplexEntryRejectionDescriptions (OOCTXT* pctxt, H245MultiplexEntryRejectionDescriptions* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode multiplexTableEntryNumber */

   rtInvokeStartElement (pctxt, "multiplexTableEntryNumber", -1);

   stat = asn1PD_H245MultiplexTableEntryNumber (pctxt, &pvalue->multiplexTableEntryNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "multiplexTableEntryNumber", -1);

   /* decode cause */

   rtInvokeStartElement (pctxt, "cause", -1);

   stat = asn1PD_H245MultiplexEntryRejectionDescriptions_cause (pctxt, &pvalue->cause);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "cause", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexEntrySendReject_rejectionDescriptions            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplexEntrySendReject_rejectionDescriptions (OOCTXT* pctxt, H245MultiplexEntrySendReject_rejectionDescriptions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 15, 0 };
   int stat = ASN_OK;
   H245MultiplexEntryRejectionDescriptions* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245MultiplexEntryRejectionDescriptions);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245MultiplexEntryRejectionDescriptions (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexEntrySendReject                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplexEntrySendReject (OOCTXT* pctxt, H245MultiplexEntrySendReject* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode sequenceNumber */

   rtInvokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode rejectionDescriptions */

   rtInvokeStartElement (pctxt, "rejectionDescriptions", -1);

   stat = asn1PD_H245MultiplexEntrySendReject_rejectionDescriptions (pctxt, &pvalue->rejectionDescriptions);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "rejectionDescriptions", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestMultiplexEntryAck_entryNumbers                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestMultiplexEntryAck_entryNumbers (OOCTXT* pctxt, H245RequestMultiplexEntryAck_entryNumbers* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 15, 0 };
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      stat = asn1PD_H245MultiplexTableEntryNumber (pctxt, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestMultiplexEntryAck                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestMultiplexEntryAck (OOCTXT* pctxt, H245RequestMultiplexEntryAck* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode entryNumbers */

   rtInvokeStartElement (pctxt, "entryNumbers", -1);

   stat = asn1PD_H245RequestMultiplexEntryAck_entryNumbers (pctxt, &pvalue->entryNumbers);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "entryNumbers", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestMultiplexEntryReject_entryNumbers                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestMultiplexEntryReject_entryNumbers (OOCTXT* pctxt, H245RequestMultiplexEntryReject_entryNumbers* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 15, 0 };
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      stat = asn1PD_H245MultiplexTableEntryNumber (pctxt, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestMultiplexEntryRejectionDescriptions_cause          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestMultiplexEntryRejectionDescriptions_cause (OOCTXT* pctxt, H245RequestMultiplexEntryRejectionDescriptions_cause* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* unspecifiedCause */
         case 0:
            rtInvokeStartElement (pctxt, "unspecifiedCause", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "unspecifiedCause", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestMultiplexEntryRejectionDescriptions                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestMultiplexEntryRejectionDescriptions (OOCTXT* pctxt, H245RequestMultiplexEntryRejectionDescriptions* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode multiplexTableEntryNumber */

   rtInvokeStartElement (pctxt, "multiplexTableEntryNumber", -1);

   stat = asn1PD_H245MultiplexTableEntryNumber (pctxt, &pvalue->multiplexTableEntryNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "multiplexTableEntryNumber", -1);

   /* decode cause */

   rtInvokeStartElement (pctxt, "cause", -1);

   stat = asn1PD_H245RequestMultiplexEntryRejectionDescriptions_cause (pctxt, &pvalue->cause);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "cause", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestMultiplexEntryReject_rejectionDescriptions         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestMultiplexEntryReject_rejectionDescriptions (OOCTXT* pctxt, H245RequestMultiplexEntryReject_rejectionDescriptions* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 15, 0 };
   int stat = ASN_OK;
   H245RequestMultiplexEntryRejectionDescriptions* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245RequestMultiplexEntryRejectionDescriptions);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245RequestMultiplexEntryRejectionDescriptions (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestMultiplexEntryReject                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestMultiplexEntryReject (OOCTXT* pctxt, H245RequestMultiplexEntryReject* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode entryNumbers */

   rtInvokeStartElement (pctxt, "entryNumbers", -1);

   stat = asn1PD_H245RequestMultiplexEntryReject_entryNumbers (pctxt, &pvalue->entryNumbers);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "entryNumbers", -1);

   /* decode rejectionDescriptions */

   rtInvokeStartElement (pctxt, "rejectionDescriptions", -1);

   stat = asn1PD_H245RequestMultiplexEntryReject_rejectionDescriptions (pctxt, &pvalue->rejectionDescriptions);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "rejectionDescriptions", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestModeAck_response                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestModeAck_response (OOCTXT* pctxt, H245RequestModeAck_response* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* willTransmitMostPreferredMode */
         case 0:
            rtInvokeStartElement (pctxt, "willTransmitMostPreferredMode", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "willTransmitMostPreferredMode", -1);

            break;

         /* willTransmitLessPreferredMode */
         case 1:
            rtInvokeStartElement (pctxt, "willTransmitLessPreferredMode", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "willTransmitLessPreferredMode", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestModeAck                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestModeAck (OOCTXT* pctxt, H245RequestModeAck* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode sequenceNumber */

   rtInvokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode response */

   rtInvokeStartElement (pctxt, "response", -1);

   stat = asn1PD_H245RequestModeAck_response (pctxt, &pvalue->response);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "response", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestModeReject_cause                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestModeReject_cause (OOCTXT* pctxt, H245RequestModeReject_cause* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* modeUnavailable */
         case 0:
            rtInvokeStartElement (pctxt, "modeUnavailable", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "modeUnavailable", -1);

            break;

         /* multipointConstraint */
         case 1:
            rtInvokeStartElement (pctxt, "multipointConstraint", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "multipointConstraint", -1);

            break;

         /* requestDenied */
         case 2:
            rtInvokeStartElement (pctxt, "requestDenied", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "requestDenied", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestModeReject                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestModeReject (OOCTXT* pctxt, H245RequestModeReject* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode sequenceNumber */

   rtInvokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode cause */

   rtInvokeStartElement (pctxt, "cause", -1);

   stat = asn1PD_H245RequestModeReject_cause (pctxt, &pvalue->cause);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "cause", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RoundTripDelayResponse                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RoundTripDelayResponse (OOCTXT* pctxt, H245RoundTripDelayResponse* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode sequenceNumber */

   rtInvokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "sequenceNumber", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaintenanceLoopAck_type                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MaintenanceLoopAck_type (OOCTXT* pctxt, H245MaintenanceLoopAck_type* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* systemLoop */
         case 0:
            rtInvokeStartElement (pctxt, "systemLoop", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "systemLoop", -1);

            break;

         /* mediaLoop */
         case 1:
            rtInvokeStartElement (pctxt, "mediaLoop", -1);

            stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.mediaLoop);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "mediaLoop", -1);

            break;

         /* logicalChannelLoop */
         case 2:
            rtInvokeStartElement (pctxt, "logicalChannelLoop", -1);

            stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.logicalChannelLoop);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "logicalChannelLoop", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaintenanceLoopAck                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MaintenanceLoopAck (OOCTXT* pctxt, H245MaintenanceLoopAck* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode type */

   rtInvokeStartElement (pctxt, "type", -1);

   stat = asn1PD_H245MaintenanceLoopAck_type (pctxt, &pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "type", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaintenanceLoopReject_type                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MaintenanceLoopReject_type (OOCTXT* pctxt, H245MaintenanceLoopReject_type* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* systemLoop */
         case 0:
            rtInvokeStartElement (pctxt, "systemLoop", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "systemLoop", -1);

            break;

         /* mediaLoop */
         case 1:
            rtInvokeStartElement (pctxt, "mediaLoop", -1);

            stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.mediaLoop);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "mediaLoop", -1);

            break;

         /* logicalChannelLoop */
         case 2:
            rtInvokeStartElement (pctxt, "logicalChannelLoop", -1);

            stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.logicalChannelLoop);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "logicalChannelLoop", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaintenanceLoopReject_cause                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MaintenanceLoopReject_cause (OOCTXT* pctxt, H245MaintenanceLoopReject_cause* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* canNotPerformLoop */
         case 0:
            rtInvokeStartElement (pctxt, "canNotPerformLoop", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "canNotPerformLoop", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaintenanceLoopReject                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MaintenanceLoopReject (OOCTXT* pctxt, H245MaintenanceLoopReject* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode type */

   rtInvokeStartElement (pctxt, "type", -1);

   stat = asn1PD_H245MaintenanceLoopReject_type (pctxt, &pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "type", -1);

   /* decode cause */

   rtInvokeStartElement (pctxt, "cause", -1);

   stat = asn1PD_H245MaintenanceLoopReject_cause (pctxt, &pvalue->cause);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "cause", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommunicationModeTableEntry_dataType                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CommunicationModeTableEntry_dataType (OOCTXT* pctxt, H245CommunicationModeTableEntry_dataType* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* videoData */
         case 0:
            rtInvokeStartElement (pctxt, "videoData", -1);

            pvalue->u.videoData = ALLOC_ASN1ELEM (pctxt, H245VideoCapability);
            if (pvalue->u.videoData == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245VideoCapability (pctxt, pvalue->u.videoData);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "videoData", -1);

            break;

         /* audioData */
         case 1:
            rtInvokeStartElement (pctxt, "audioData", -1);

            pvalue->u.audioData = ALLOC_ASN1ELEM (pctxt, H245AudioCapability);
            if (pvalue->u.audioData == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245AudioCapability (pctxt, pvalue->u.audioData);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "audioData", -1);

            break;

         /* data */
         case 2:
            rtInvokeStartElement (pctxt, "data", -1);

            pvalue->u.data = ALLOC_ASN1ELEM (pctxt, H245DataApplicationCapability);
            if (pvalue->u.data == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245DataApplicationCapability (pctxt, pvalue->u.data);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "data", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommunicationModeTableEntry                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CommunicationModeTableEntry (OOCTXT* pctxt, H245CommunicationModeTableEntry* pvalue)
{
   static Asn1SizeCnst sessionDescription_lsize1 = { 0, 1, 128, 0 };
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.associatedSessionIDPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.terminalLabelPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mediaChannelPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mediaGuaranteedDeliveryPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mediaControlChannelPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mediaControlGuaranteedDeliveryPresent = optbit;

   /* decode nonStandard */

   if (pvalue->m.nonStandardPresent) {
      rtInvokeStartElement (pctxt, "nonStandard", -1);

      stat = asn1PD_H245_SeqOfH245NonStandardParameter (pctxt, &pvalue->nonStandard);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "nonStandard", -1);
   }

   /* decode sessionID */

   rtInvokeStartElement (pctxt, "sessionID", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->sessionID, 1U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->sessionID);

   rtInvokeEndElement (pctxt, "sessionID", -1);

   /* decode associatedSessionID */

   if (pvalue->m.associatedSessionIDPresent) {
      rtInvokeStartElement (pctxt, "associatedSessionID", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->associatedSessionID, 1U, 255U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->associatedSessionID);

      rtInvokeEndElement (pctxt, "associatedSessionID", -1);
   }

   /* decode terminalLabel */

   if (pvalue->m.terminalLabelPresent) {
      rtInvokeStartElement (pctxt, "terminalLabel", -1);

      stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->terminalLabel);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "terminalLabel", -1);
   }

   /* decode sessionDescription */

   rtInvokeStartElement (pctxt, "sessionDescription", -1);

   stat = addSizeConstraint (pctxt, &sessionDescription_lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeBMPString (pctxt, &pvalue->sessionDescription, 0);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeCharStr16BitValue (pctxt, pvalue->sessionDescription.nchars, pvalue->sessionDescription.data);

   rtInvokeEndElement (pctxt, "sessionDescription", -1);

   /* decode dataType */

   rtInvokeStartElement (pctxt, "dataType", -1);

   stat = asn1PD_H245CommunicationModeTableEntry_dataType (pctxt, &pvalue->dataType);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "dataType", -1);

   /* decode mediaChannel */

   if (pvalue->m.mediaChannelPresent) {
      rtInvokeStartElement (pctxt, "mediaChannel", -1);

      stat = asn1PD_H245TransportAddress (pctxt, &pvalue->mediaChannel);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "mediaChannel", -1);
   }

   /* decode mediaGuaranteedDelivery */

   if (pvalue->m.mediaGuaranteedDeliveryPresent) {
      rtInvokeStartElement (pctxt, "mediaGuaranteedDelivery", -1);

      stat = DECODEBIT (pctxt, &pvalue->mediaGuaranteedDelivery);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeBoolValue (pctxt, pvalue->mediaGuaranteedDelivery);

      rtInvokeEndElement (pctxt, "mediaGuaranteedDelivery", -1);
   }

   /* decode mediaControlChannel */

   if (pvalue->m.mediaControlChannelPresent) {
      rtInvokeStartElement (pctxt, "mediaControlChannel", -1);

      stat = asn1PD_H245TransportAddress (pctxt, &pvalue->mediaControlChannel);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "mediaControlChannel", -1);
   }

   /* decode mediaControlGuaranteedDelivery */

   if (pvalue->m.mediaControlGuaranteedDeliveryPresent) {
      rtInvokeStartElement (pctxt, "mediaControlGuaranteedDelivery", -1);

      stat = DECODEBIT (pctxt, &pvalue->mediaControlGuaranteedDelivery);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeBoolValue (pctxt, pvalue->mediaControlGuaranteedDelivery);

      rtInvokeEndElement (pctxt, "mediaControlGuaranteedDelivery", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 3 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.redundancyEncodingPresent = 1;

                     rtInvokeStartElement (pctxt, "redundancyEncoding", -1);

                     stat = asn1PD_H245RedundancyEncoding (pctxt, &pvalue->redundancyEncoding);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "redundancyEncoding", -1);
                     break;

                  case 1:
                     pvalue->m.sessionDependencyPresent = 1;

                     rtInvokeStartElement (pctxt, "sessionDependency", -1);

                     stat = decodeConsUInt8 (pctxt, &pvalue->sessionDependency, 1U, 255U);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     rtInvokeUIntValue (pctxt, pvalue->sessionDependency);

                     rtInvokeEndElement (pctxt, "sessionDependency", -1);
                     break;

                  case 2:
                     pvalue->m.destinationPresent = 1;

                     rtInvokeStartElement (pctxt, "destination", -1);

                     stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->destination);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "destination", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 3) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommunicationModeResponse_communicationModeTable          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CommunicationModeResponse_communicationModeTable (OOCTXT* pctxt, H245CommunicationModeResponse_communicationModeTable* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   H245CommunicationModeTableEntry* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245CommunicationModeTableEntry);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245CommunicationModeTableEntry (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommunicationModeResponse                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CommunicationModeResponse (OOCTXT* pctxt, H245CommunicationModeResponse* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 0);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* communicationModeTable */
         case 0:
            rtInvokeStartElement (pctxt, "communicationModeTable", -1);

            pvalue->u.communicationModeTable = ALLOC_ASN1ELEM (pctxt, H245CommunicationModeResponse_communicationModeTable);
            if (pvalue->u.communicationModeTable == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245CommunicationModeResponse_communicationModeTable (pctxt, pvalue->u.communicationModeTable);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "communicationModeTable", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 2;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConferenceResponse_mCTerminalIDResponse                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ConferenceResponse_mCTerminalIDResponse (OOCTXT* pctxt, H245ConferenceResponse_mCTerminalIDResponse* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode terminalLabel */

   rtInvokeStartElement (pctxt, "terminalLabel", -1);

   stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->terminalLabel);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "terminalLabel", -1);

   /* decode terminalID */

   rtInvokeStartElement (pctxt, "terminalID", -1);

   stat = asn1PD_H245TerminalID (pctxt, &pvalue->terminalID);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "terminalID", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConferenceResponse_terminalIDResponse                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ConferenceResponse_terminalIDResponse (OOCTXT* pctxt, H245ConferenceResponse_terminalIDResponse* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode terminalLabel */

   rtInvokeStartElement (pctxt, "terminalLabel", -1);

   stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->terminalLabel);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "terminalLabel", -1);

   /* decode terminalID */

   rtInvokeStartElement (pctxt, "terminalID", -1);

   stat = asn1PD_H245TerminalID (pctxt, &pvalue->terminalID);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "terminalID", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConferenceResponse_conferenceIDResponse                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ConferenceResponse_conferenceIDResponse (OOCTXT* pctxt, H245ConferenceResponse_conferenceIDResponse* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode terminalLabel */

   rtInvokeStartElement (pctxt, "terminalLabel", -1);

   stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->terminalLabel);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "terminalLabel", -1);

   /* decode conferenceID */

   rtInvokeStartElement (pctxt, "conferenceID", -1);

   stat = asn1PD_H245ConferenceID (pctxt, &pvalue->conferenceID);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "conferenceID", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConferenceResponse_passwordResponse                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ConferenceResponse_passwordResponse (OOCTXT* pctxt, H245ConferenceResponse_passwordResponse* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode terminalLabel */

   rtInvokeStartElement (pctxt, "terminalLabel", -1);

   stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->terminalLabel);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "terminalLabel", -1);

   /* decode password */

   rtInvokeStartElement (pctxt, "password", -1);

   stat = asn1PD_H245Password (pctxt, &pvalue->password);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "password", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConferenceResponse_terminalListResponse                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ConferenceResponse_terminalListResponse (OOCTXT* pctxt, H245ConferenceResponse_terminalListResponse* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   H245TerminalLabel* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245TerminalLabel);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245TerminalLabel (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConferenceResponse_makeMeChairResponse                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ConferenceResponse_makeMeChairResponse (OOCTXT* pctxt, H245ConferenceResponse_makeMeChairResponse* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* grantedChairToken */
         case 0:
            rtInvokeStartElement (pctxt, "grantedChairToken", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "grantedChairToken", -1);

            break;

         /* deniedChairToken */
         case 1:
            rtInvokeStartElement (pctxt, "deniedChairToken", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "deniedChairToken", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConferenceResponse_extensionAddressResponse               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ConferenceResponse_extensionAddressResponse (OOCTXT* pctxt, H245ConferenceResponse_extensionAddressResponse* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode extensionAddress */

   rtInvokeStartElement (pctxt, "extensionAddress", -1);

   stat = asn1PD_H245TerminalID (pctxt, &pvalue->extensionAddress);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "extensionAddress", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConferenceResponse_chairTokenOwnerResponse                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ConferenceResponse_chairTokenOwnerResponse (OOCTXT* pctxt, H245ConferenceResponse_chairTokenOwnerResponse* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode terminalLabel */

   rtInvokeStartElement (pctxt, "terminalLabel", -1);

   stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->terminalLabel);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "terminalLabel", -1);

   /* decode terminalID */

   rtInvokeStartElement (pctxt, "terminalID", -1);

   stat = asn1PD_H245TerminalID (pctxt, &pvalue->terminalID);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "terminalID", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConferenceResponse_terminalCertificateResponse            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ConferenceResponse_terminalCertificateResponse (OOCTXT* pctxt, H245ConferenceResponse_terminalCertificateResponse* pvalue)
{
   static Asn1SizeCnst certificateResponse_lsize1 = { 0, 1, 65535, 0 };
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.terminalLabelPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.certificateResponsePresent = optbit;

   /* decode terminalLabel */

   if (pvalue->m.terminalLabelPresent) {
      rtInvokeStartElement (pctxt, "terminalLabel", -1);

      stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->terminalLabel);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "terminalLabel", -1);
   }

   /* decode certificateResponse */

   if (pvalue->m.certificateResponsePresent) {
      rtInvokeStartElement (pctxt, "certificateResponse", -1);

      stat = addSizeConstraint (pctxt, &certificateResponse_lsize1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->certificateResponse);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeOctStrValue (pctxt, pvalue->certificateResponse.numocts, pvalue->certificateResponse.data);

      rtInvokeEndElement (pctxt, "certificateResponse", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConferenceResponse_broadcastMyLogicalChannelResponse      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ConferenceResponse_broadcastMyLogicalChannelResponse (OOCTXT* pctxt, H245ConferenceResponse_broadcastMyLogicalChannelResponse* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* grantedBroadcastMyLogicalChannel */
         case 0:
            rtInvokeStartElement (pctxt, "grantedBroadcastMyLogicalChannel", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "grantedBroadcastMyLogicalChannel", -1);

            break;

         /* deniedBroadcastMyLogicalChannel */
         case 1:
            rtInvokeStartElement (pctxt, "deniedBroadcastMyLogicalChannel", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "deniedBroadcastMyLogicalChannel", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConferenceResponse_makeTerminalBroadcasterResponse        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ConferenceResponse_makeTerminalBroadcasterResponse (OOCTXT* pctxt, H245ConferenceResponse_makeTerminalBroadcasterResponse* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* grantedMakeTerminalBroadcaster */
         case 0:
            rtInvokeStartElement (pctxt, "grantedMakeTerminalBroadcaster", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "grantedMakeTerminalBroadcaster", -1);

            break;

         /* deniedMakeTerminalBroadcaster */
         case 1:
            rtInvokeStartElement (pctxt, "deniedMakeTerminalBroadcaster", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "deniedMakeTerminalBroadcaster", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConferenceResponse_sendThisSourceResponse                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ConferenceResponse_sendThisSourceResponse (OOCTXT* pctxt, H245ConferenceResponse_sendThisSourceResponse* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* grantedSendThisSource */
         case 0:
            rtInvokeStartElement (pctxt, "grantedSendThisSource", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "grantedSendThisSource", -1);

            break;

         /* deniedSendThisSource */
         case 1:
            rtInvokeStartElement (pctxt, "deniedSendThisSource", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "deniedSendThisSource", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalInformation                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245TerminalInformation (OOCTXT* pctxt, H245TerminalInformation* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode terminalLabel */

   rtInvokeStartElement (pctxt, "terminalLabel", -1);

   stat = asn1PD_H245TerminalLabel (pctxt, &pvalue->terminalLabel);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "terminalLabel", -1);

   /* decode terminalID */

   rtInvokeStartElement (pctxt, "terminalID", -1);

   stat = asn1PD_H245TerminalID (pctxt, &pvalue->terminalID);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "terminalID", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH245TerminalInformation                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245_SeqOfH245TerminalInformation (OOCTXT* pctxt, H245_SeqOfH245TerminalInformation* pvalue)
{
   int stat = ASN_OK;
   H245TerminalInformation* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         rtInvokeStartElement (pctxt, "elem", xx1);

         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245TerminalInformation);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H245TerminalInformation (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         rtInvokeEndElement (pctxt, "elem", xx1);

         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestAllTerminalIDsResponse                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestAllTerminalIDsResponse (OOCTXT* pctxt, H245RequestAllTerminalIDsResponse* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode terminalInformation */

   rtInvokeStartElement (pctxt, "terminalInformation", -1);

   stat = asn1PD_H245_SeqOfH245TerminalInformation (pctxt, &pvalue->terminalInformation);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "terminalInformation", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RemoteMCResponse_reject                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RemoteMCResponse_reject (OOCTXT* pctxt, H245RemoteMCResponse_reject* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* unspecified */
         case 0:
            rtInvokeStartElement (pctxt, "unspecified", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "unspecified", -1);

            break;

         /* functionNotSupported */
         case 1:
            rtInvokeStartElement (pctxt, "functionNotSupported", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "functionNotSupported", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RemoteMCResponse                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RemoteMCResponse (OOCTXT* pctxt, H245RemoteMCResponse* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* accept */
         case 0:
            rtInvokeStartElement (pctxt, "accept", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "accept", -1);

            break;

         /* reject */
         case 1:
            rtInvokeStartElement (pctxt, "reject", -1);

            pvalue->u.reject = ALLOC_ASN1ELEM (pctxt, H245RemoteMCResponse_reject);
            if (pvalue->u.reject == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RemoteMCResponse_reject (pctxt, pvalue->u.reject);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "reject", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConferenceResponse                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ConferenceResponse (OOCTXT* pctxt, H245ConferenceResponse* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 7);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* mCTerminalIDResponse */
         case 0:
            rtInvokeStartElement (pctxt, "mCTerminalIDResponse", -1);

            pvalue->u.mCTerminalIDResponse = ALLOC_ASN1ELEM (pctxt, H245ConferenceResponse_mCTerminalIDResponse);
            if (pvalue->u.mCTerminalIDResponse == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245ConferenceResponse_mCTerminalIDResponse (pctxt, pvalue->u.mCTerminalIDResponse);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "mCTerminalIDResponse", -1);

            break;

         /* terminalIDResponse */
         case 1:
            rtInvokeStartElement (pctxt, "terminalIDResponse", -1);

            pvalue->u.terminalIDResponse = ALLOC_ASN1ELEM (pctxt, H245ConferenceResponse_terminalIDResponse);
            if (pvalue->u.terminalIDResponse == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245ConferenceResponse_terminalIDResponse (pctxt, pvalue->u.terminalIDResponse);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "terminalIDResponse", -1);

            break;

         /* conferenceIDResponse */
         case 2:
            rtInvokeStartElement (pctxt, "conferenceIDResponse", -1);

            pvalue->u.conferenceIDResponse = ALLOC_ASN1ELEM (pctxt, H245ConferenceResponse_conferenceIDResponse);
            if (pvalue->u.conferenceIDResponse == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245ConferenceResponse_conferenceIDResponse (pctxt, pvalue->u.conferenceIDResponse);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "conferenceIDResponse", -1);

            break;

         /* passwordResponse */
         case 3:
            rtInvokeStartElement (pctxt, "passwordResponse", -1);

            pvalue->u.passwordResponse = ALLOC_ASN1ELEM (pctxt, H245ConferenceResponse_passwordResponse);
            if (pvalue->u.passwordResponse == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245ConferenceResponse_passwordResponse (pctxt, pvalue->u.passwordResponse);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "passwordResponse", -1);

            break;

         /* terminalListResponse */
         case 4:
            rtInvokeStartElement (pctxt, "terminalListResponse", -1);

            pvalue->u.terminalListResponse = ALLOC_ASN1ELEM (pctxt, H245ConferenceResponse_terminalListResponse);
            if (pvalue->u.terminalListResponse == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245ConferenceResponse_terminalListResponse (pctxt, pvalue->u.terminalListResponse);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "terminalListResponse", -1);

            break;

         /* videoCommandReject */
         case 5:
            rtInvokeStartElement (pctxt, "videoCommandReject", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "videoCommandReject", -1);

            break;

         /* terminalDropReject */
         case 6:
            rtInvokeStartElement (pctxt, "terminalDropReject", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "terminalDropReject", -1);

            break;

         /* makeMeChairResponse */
         case 7:
            rtInvokeStartElement (pctxt, "makeMeChairResponse", -1);

            pvalue->u.makeMeChairResponse = ALLOC_ASN1ELEM (pctxt, H245ConferenceResponse_makeMeChairResponse);
            if (pvalue->u.makeMeChairResponse == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245ConferenceResponse_makeMeChairResponse (pctxt, pvalue->u.makeMeChairResponse);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "makeMeChairResponse", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 9;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* extensionAddressResponse */
         case 9:
            rtInvokeStartElement (pctxt, "extensionAddressResponse", -1);

            pvalue->u.extensionAddressResponse = ALLOC_ASN1ELEM (pctxt, H245ConferenceResponse_extensionAddressResponse);
            if (pvalue->u.extensionAddressResponse == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245ConferenceResponse_extensionAddressResponse (pctxt, pvalue->u.extensionAddressResponse);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "extensionAddressResponse", -1);

            break;

         /* chairTokenOwnerResponse */
         case 10:
            rtInvokeStartElement (pctxt, "chairTokenOwnerResponse", -1);

            pvalue->u.chairTokenOwnerResponse = ALLOC_ASN1ELEM (pctxt, H245ConferenceResponse_chairTokenOwnerResponse);
            if (pvalue->u.chairTokenOwnerResponse == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245ConferenceResponse_chairTokenOwnerResponse (pctxt, pvalue->u.chairTokenOwnerResponse);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "chairTokenOwnerResponse", -1);

            break;

         /* terminalCertificateResponse */
         case 11:
            rtInvokeStartElement (pctxt, "terminalCertificateResponse", -1);

            pvalue->u.terminalCertificateResponse = ALLOC_ASN1ELEM (pctxt, H245ConferenceResponse_terminalCertificateResponse);
            if (pvalue->u.terminalCertificateResponse == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245ConferenceResponse_terminalCertificateResponse (pctxt, pvalue->u.terminalCertificateResponse);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "terminalCertificateResponse", -1);

            break;

         /* broadcastMyLogicalChannelResponse */
         case 12:
            rtInvokeStartElement (pctxt, "broadcastMyLogicalChannelResponse", -1);

            pvalue->u.broadcastMyLogicalChannelResponse = ALLOC_ASN1ELEM (pctxt, H245ConferenceResponse_broadcastMyLogicalChannelResponse);
            if (pvalue->u.broadcastMyLogicalChannelResponse == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245ConferenceResponse_broadcastMyLogicalChannelResponse (pctxt, pvalue->u.broadcastMyLogicalChannelResponse);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "broadcastMyLogicalChannelResponse", -1);

            break;

         /* makeTerminalBroadcasterResponse */
         case 13:
            rtInvokeStartElement (pctxt, "makeTerminalBroadcasterResponse", -1);

            pvalue->u.makeTerminalBroadcasterResponse = ALLOC_ASN1ELEM (pctxt, H245ConferenceResponse_makeTerminalBroadcasterResponse);
            if (pvalue->u.makeTerminalBroadcasterResponse == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245ConferenceResponse_makeTerminalBroadcasterResponse (pctxt, pvalue->u.makeTerminalBroadcasterResponse);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "makeTerminalBroadcasterResponse", -1);

            break;

         /* sendThisSourceResponse */
         case 14:
            rtInvokeStartElement (pctxt, "sendThisSourceResponse", -1);

            pvalue->u.sendThisSourceResponse = ALLOC_ASN1ELEM (pctxt, H245ConferenceResponse_sendThisSourceResponse);
            if (pvalue->u.sendThisSourceResponse == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245ConferenceResponse_sendThisSourceResponse (pctxt, pvalue->u.sendThisSourceResponse);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "sendThisSourceResponse", -1);

            break;

         /* requestAllTerminalIDsResponse */
         case 15:
            rtInvokeStartElement (pctxt, "requestAllTerminalIDsResponse", -1);

            pvalue->u.requestAllTerminalIDsResponse = ALLOC_ASN1ELEM (pctxt, H245RequestAllTerminalIDsResponse);
            if (pvalue->u.requestAllTerminalIDsResponse == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RequestAllTerminalIDsResponse (pctxt, pvalue->u.requestAllTerminalIDsResponse);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "requestAllTerminalIDsResponse", -1);

            break;

         /* remoteMCResponse */
         case 16:
            rtInvokeStartElement (pctxt, "remoteMCResponse", -1);

            pvalue->u.remoteMCResponse = ALLOC_ASN1ELEM (pctxt, H245RemoteMCResponse);
            if (pvalue->u.remoteMCResponse == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RemoteMCResponse (pctxt, pvalue->u.remoteMCResponse);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "remoteMCResponse", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultilinkResponse_callInformation                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultilinkResponse_callInformation (OOCTXT* pctxt, H245MultilinkResponse_callInformation* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode dialingInformation */

   rtInvokeStartElement (pctxt, "dialingInformation", -1);

   stat = asn1PD_H245DialingInformation (pctxt, &pvalue->dialingInformation);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "dialingInformation", -1);

   /* decode callAssociationNumber */

   rtInvokeStartElement (pctxt, "callAssociationNumber", -1);

   stat = decodeConsUnsigned (pctxt, &pvalue->callAssociationNumber, 0U, ASN1UINT_MAX);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->callAssociationNumber);

   rtInvokeEndElement (pctxt, "callAssociationNumber", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultilinkResponse_addConnection_responseCode_rejected     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultilinkResponse_addConnection_responseCode_rejected (OOCTXT* pctxt, H245MultilinkResponse_addConnection_responseCode_rejected* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* connectionsNotAvailable */
         case 0:
            rtInvokeStartElement (pctxt, "connectionsNotAvailable", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "connectionsNotAvailable", -1);

            break;

         /* userRejected */
         case 1:
            rtInvokeStartElement (pctxt, "userRejected", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "userRejected", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultilinkResponse_addConnection_responseCode              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultilinkResponse_addConnection_responseCode (OOCTXT* pctxt, H245MultilinkResponse_addConnection_responseCode* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* accepted */
         case 0:
            rtInvokeStartElement (pctxt, "accepted", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "accepted", -1);

            break;

         /* rejected */
         case 1:
            rtInvokeStartElement (pctxt, "rejected", -1);

            pvalue->u.rejected = ALLOC_ASN1ELEM (pctxt, H245MultilinkResponse_addConnection_responseCode_rejected);
            if (pvalue->u.rejected == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultilinkResponse_addConnection_responseCode_rejected (pctxt, pvalue->u.rejected);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "rejected", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultilinkResponse_addConnection                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultilinkResponse_addConnection (OOCTXT* pctxt, H245MultilinkResponse_addConnection* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode sequenceNumber */

   rtInvokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode responseCode */

   rtInvokeStartElement (pctxt, "responseCode", -1);

   stat = asn1PD_H245MultilinkResponse_addConnection_responseCode (pctxt, &pvalue->responseCode);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "responseCode", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultilinkResponse_removeConnection                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultilinkResponse_removeConnection (OOCTXT* pctxt, H245MultilinkResponse_removeConnection* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode connectionIdentifier */

   rtInvokeStartElement (pctxt, "connectionIdentifier", -1);

   stat = asn1PD_H245ConnectionIdentifier (pctxt, &pvalue->connectionIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "connectionIdentifier", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultilinkResponse_maximumHeaderInterval                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultilinkResponse_maximumHeaderInterval (OOCTXT* pctxt, H245MultilinkResponse_maximumHeaderInterval* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode currentInterval */

   rtInvokeStartElement (pctxt, "currentInterval", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->currentInterval, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->currentInterval);

   rtInvokeEndElement (pctxt, "currentInterval", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultilinkResponse                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultilinkResponse (OOCTXT* pctxt, H245MultilinkResponse* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 4);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardMessage);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardMessage (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* callInformation */
         case 1:
            rtInvokeStartElement (pctxt, "callInformation", -1);

            pvalue->u.callInformation = ALLOC_ASN1ELEM (pctxt, H245MultilinkResponse_callInformation);
            if (pvalue->u.callInformation == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultilinkResponse_callInformation (pctxt, pvalue->u.callInformation);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "callInformation", -1);

            break;

         /* addConnection */
         case 2:
            rtInvokeStartElement (pctxt, "addConnection", -1);

            pvalue->u.addConnection = ALLOC_ASN1ELEM (pctxt, H245MultilinkResponse_addConnection);
            if (pvalue->u.addConnection == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultilinkResponse_addConnection (pctxt, pvalue->u.addConnection);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "addConnection", -1);

            break;

         /* removeConnection */
         case 3:
            rtInvokeStartElement (pctxt, "removeConnection", -1);

            pvalue->u.removeConnection = ALLOC_ASN1ELEM (pctxt, H245MultilinkResponse_removeConnection);
            if (pvalue->u.removeConnection == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultilinkResponse_removeConnection (pctxt, pvalue->u.removeConnection);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "removeConnection", -1);

            break;

         /* maximumHeaderInterval */
         case 4:
            rtInvokeStartElement (pctxt, "maximumHeaderInterval", -1);

            pvalue->u.maximumHeaderInterval = ALLOC_ASN1ELEM (pctxt, H245MultilinkResponse_maximumHeaderInterval);
            if (pvalue->u.maximumHeaderInterval == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultilinkResponse_maximumHeaderInterval (pctxt, pvalue->u.maximumHeaderInterval);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "maximumHeaderInterval", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 6;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LogicalChannelRateAcknowledge                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245LogicalChannelRateAcknowledge (OOCTXT* pctxt, H245LogicalChannelRateAcknowledge* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode sequenceNumber */

   rtInvokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode logicalChannelNumber */

   rtInvokeStartElement (pctxt, "logicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "logicalChannelNumber", -1);

   /* decode maximumBitRate */

   rtInvokeStartElement (pctxt, "maximumBitRate", -1);

   stat = asn1PD_H245MaximumBitRate (pctxt, &pvalue->maximumBitRate);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "maximumBitRate", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LogicalChannelRateRejectReason                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245LogicalChannelRateRejectReason (OOCTXT* pctxt, H245LogicalChannelRateRejectReason* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* undefinedReason */
         case 0:
            rtInvokeStartElement (pctxt, "undefinedReason", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "undefinedReason", -1);

            break;

         /* insufficientResources */
         case 1:
            rtInvokeStartElement (pctxt, "insufficientResources", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "insufficientResources", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LogicalChannelRateReject                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245LogicalChannelRateReject (OOCTXT* pctxt, H245LogicalChannelRateReject* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.currentMaximumBitRatePresent = optbit;

   /* decode sequenceNumber */

   rtInvokeStartElement (pctxt, "sequenceNumber", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->sequenceNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "sequenceNumber", -1);

   /* decode logicalChannelNumber */

   rtInvokeStartElement (pctxt, "logicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "logicalChannelNumber", -1);

   /* decode rejectReason */

   rtInvokeStartElement (pctxt, "rejectReason", -1);

   stat = asn1PD_H245LogicalChannelRateRejectReason (pctxt, &pvalue->rejectReason);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "rejectReason", -1);

   /* decode currentMaximumBitRate */

   if (pvalue->m.currentMaximumBitRatePresent) {
      rtInvokeStartElement (pctxt, "currentMaximumBitRate", -1);

      stat = asn1PD_H245MaximumBitRate (pctxt, &pvalue->currentMaximumBitRate);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "currentMaximumBitRate", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ResponseMessage                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ResponseMessage (OOCTXT* pctxt, H245ResponseMessage* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 18);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardMessage);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardMessage (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* masterSlaveDeterminationAck */
         case 1:
            rtInvokeStartElement (pctxt, "masterSlaveDeterminationAck", -1);

            pvalue->u.masterSlaveDeterminationAck = ALLOC_ASN1ELEM (pctxt, H245MasterSlaveDeterminationAck);
            if (pvalue->u.masterSlaveDeterminationAck == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MasterSlaveDeterminationAck (pctxt, pvalue->u.masterSlaveDeterminationAck);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "masterSlaveDeterminationAck", -1);

            break;

         /* masterSlaveDeterminationReject */
         case 2:
            rtInvokeStartElement (pctxt, "masterSlaveDeterminationReject", -1);

            pvalue->u.masterSlaveDeterminationReject = ALLOC_ASN1ELEM (pctxt, H245MasterSlaveDeterminationReject);
            if (pvalue->u.masterSlaveDeterminationReject == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MasterSlaveDeterminationReject (pctxt, pvalue->u.masterSlaveDeterminationReject);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "masterSlaveDeterminationReject", -1);

            break;

         /* terminalCapabilitySetAck */
         case 3:
            rtInvokeStartElement (pctxt, "terminalCapabilitySetAck", -1);

            pvalue->u.terminalCapabilitySetAck = ALLOC_ASN1ELEM (pctxt, H245TerminalCapabilitySetAck);
            if (pvalue->u.terminalCapabilitySetAck == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245TerminalCapabilitySetAck (pctxt, pvalue->u.terminalCapabilitySetAck);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "terminalCapabilitySetAck", -1);

            break;

         /* terminalCapabilitySetReject */
         case 4:
            rtInvokeStartElement (pctxt, "terminalCapabilitySetReject", -1);

            pvalue->u.terminalCapabilitySetReject = ALLOC_ASN1ELEM (pctxt, H245TerminalCapabilitySetReject);
            if (pvalue->u.terminalCapabilitySetReject == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245TerminalCapabilitySetReject (pctxt, pvalue->u.terminalCapabilitySetReject);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "terminalCapabilitySetReject", -1);

            break;

         /* openLogicalChannelAck */
         case 5:
            rtInvokeStartElement (pctxt, "openLogicalChannelAck", -1);

            pvalue->u.openLogicalChannelAck = ALLOC_ASN1ELEM (pctxt, H245OpenLogicalChannelAck);
            if (pvalue->u.openLogicalChannelAck == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245OpenLogicalChannelAck (pctxt, pvalue->u.openLogicalChannelAck);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "openLogicalChannelAck", -1);

            break;

         /* openLogicalChannelReject */
         case 6:
            rtInvokeStartElement (pctxt, "openLogicalChannelReject", -1);

            pvalue->u.openLogicalChannelReject = ALLOC_ASN1ELEM (pctxt, H245OpenLogicalChannelReject);
            if (pvalue->u.openLogicalChannelReject == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245OpenLogicalChannelReject (pctxt, pvalue->u.openLogicalChannelReject);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "openLogicalChannelReject", -1);

            break;

         /* closeLogicalChannelAck */
         case 7:
            rtInvokeStartElement (pctxt, "closeLogicalChannelAck", -1);

            pvalue->u.closeLogicalChannelAck = ALLOC_ASN1ELEM (pctxt, H245CloseLogicalChannelAck);
            if (pvalue->u.closeLogicalChannelAck == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245CloseLogicalChannelAck (pctxt, pvalue->u.closeLogicalChannelAck);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "closeLogicalChannelAck", -1);

            break;

         /* requestChannelCloseAck */
         case 8:
            rtInvokeStartElement (pctxt, "requestChannelCloseAck", -1);

            pvalue->u.requestChannelCloseAck = ALLOC_ASN1ELEM (pctxt, H245RequestChannelCloseAck);
            if (pvalue->u.requestChannelCloseAck == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RequestChannelCloseAck (pctxt, pvalue->u.requestChannelCloseAck);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "requestChannelCloseAck", -1);

            break;

         /* requestChannelCloseReject */
         case 9:
            rtInvokeStartElement (pctxt, "requestChannelCloseReject", -1);

            pvalue->u.requestChannelCloseReject = ALLOC_ASN1ELEM (pctxt, H245RequestChannelCloseReject);
            if (pvalue->u.requestChannelCloseReject == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RequestChannelCloseReject (pctxt, pvalue->u.requestChannelCloseReject);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "requestChannelCloseReject", -1);

            break;

         /* multiplexEntrySendAck */
         case 10:
            rtInvokeStartElement (pctxt, "multiplexEntrySendAck", -1);

            pvalue->u.multiplexEntrySendAck = ALLOC_ASN1ELEM (pctxt, H245MultiplexEntrySendAck);
            if (pvalue->u.multiplexEntrySendAck == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultiplexEntrySendAck (pctxt, pvalue->u.multiplexEntrySendAck);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "multiplexEntrySendAck", -1);

            break;

         /* multiplexEntrySendReject */
         case 11:
            rtInvokeStartElement (pctxt, "multiplexEntrySendReject", -1);

            pvalue->u.multiplexEntrySendReject = ALLOC_ASN1ELEM (pctxt, H245MultiplexEntrySendReject);
            if (pvalue->u.multiplexEntrySendReject == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultiplexEntrySendReject (pctxt, pvalue->u.multiplexEntrySendReject);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "multiplexEntrySendReject", -1);

            break;

         /* requestMultiplexEntryAck */
         case 12:
            rtInvokeStartElement (pctxt, "requestMultiplexEntryAck", -1);

            pvalue->u.requestMultiplexEntryAck = ALLOC_ASN1ELEM (pctxt, H245RequestMultiplexEntryAck);
            if (pvalue->u.requestMultiplexEntryAck == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RequestMultiplexEntryAck (pctxt, pvalue->u.requestMultiplexEntryAck);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "requestMultiplexEntryAck", -1);

            break;

         /* requestMultiplexEntryReject */
         case 13:
            rtInvokeStartElement (pctxt, "requestMultiplexEntryReject", -1);

            pvalue->u.requestMultiplexEntryReject = ALLOC_ASN1ELEM (pctxt, H245RequestMultiplexEntryReject);
            if (pvalue->u.requestMultiplexEntryReject == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RequestMultiplexEntryReject (pctxt, pvalue->u.requestMultiplexEntryReject);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "requestMultiplexEntryReject", -1);

            break;

         /* requestModeAck */
         case 14:
            rtInvokeStartElement (pctxt, "requestModeAck", -1);

            pvalue->u.requestModeAck = ALLOC_ASN1ELEM (pctxt, H245RequestModeAck);
            if (pvalue->u.requestModeAck == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RequestModeAck (pctxt, pvalue->u.requestModeAck);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "requestModeAck", -1);

            break;

         /* requestModeReject */
         case 15:
            rtInvokeStartElement (pctxt, "requestModeReject", -1);

            pvalue->u.requestModeReject = ALLOC_ASN1ELEM (pctxt, H245RequestModeReject);
            if (pvalue->u.requestModeReject == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RequestModeReject (pctxt, pvalue->u.requestModeReject);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "requestModeReject", -1);

            break;

         /* roundTripDelayResponse */
         case 16:
            rtInvokeStartElement (pctxt, "roundTripDelayResponse", -1);

            pvalue->u.roundTripDelayResponse = ALLOC_ASN1ELEM (pctxt, H245RoundTripDelayResponse);
            if (pvalue->u.roundTripDelayResponse == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RoundTripDelayResponse (pctxt, pvalue->u.roundTripDelayResponse);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "roundTripDelayResponse", -1);

            break;

         /* maintenanceLoopAck */
         case 17:
            rtInvokeStartElement (pctxt, "maintenanceLoopAck", -1);

            pvalue->u.maintenanceLoopAck = ALLOC_ASN1ELEM (pctxt, H245MaintenanceLoopAck);
            if (pvalue->u.maintenanceLoopAck == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MaintenanceLoopAck (pctxt, pvalue->u.maintenanceLoopAck);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "maintenanceLoopAck", -1);

            break;

         /* maintenanceLoopReject */
         case 18:
            rtInvokeStartElement (pctxt, "maintenanceLoopReject", -1);

            pvalue->u.maintenanceLoopReject = ALLOC_ASN1ELEM (pctxt, H245MaintenanceLoopReject);
            if (pvalue->u.maintenanceLoopReject == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MaintenanceLoopReject (pctxt, pvalue->u.maintenanceLoopReject);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "maintenanceLoopReject", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 20;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* communicationModeResponse */
         case 20:
            rtInvokeStartElement (pctxt, "communicationModeResponse", -1);

            pvalue->u.communicationModeResponse = ALLOC_ASN1ELEM (pctxt, H245CommunicationModeResponse);
            if (pvalue->u.communicationModeResponse == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245CommunicationModeResponse (pctxt, pvalue->u.communicationModeResponse);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "communicationModeResponse", -1);

            break;

         /* conferenceResponse */
         case 21:
            rtInvokeStartElement (pctxt, "conferenceResponse", -1);

            pvalue->u.conferenceResponse = ALLOC_ASN1ELEM (pctxt, H245ConferenceResponse);
            if (pvalue->u.conferenceResponse == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245ConferenceResponse (pctxt, pvalue->u.conferenceResponse);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "conferenceResponse", -1);

            break;

         /* multilinkResponse */
         case 22:
            rtInvokeStartElement (pctxt, "multilinkResponse", -1);

            pvalue->u.multilinkResponse = ALLOC_ASN1ELEM (pctxt, H245MultilinkResponse);
            if (pvalue->u.multilinkResponse == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultilinkResponse (pctxt, pvalue->u.multilinkResponse);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "multilinkResponse", -1);

            break;

         /* logicalChannelRateAcknowledge */
         case 23:
            rtInvokeStartElement (pctxt, "logicalChannelRateAcknowledge", -1);

            pvalue->u.logicalChannelRateAcknowledge = ALLOC_ASN1ELEM (pctxt, H245LogicalChannelRateAcknowledge);
            if (pvalue->u.logicalChannelRateAcknowledge == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245LogicalChannelRateAcknowledge (pctxt, pvalue->u.logicalChannelRateAcknowledge);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "logicalChannelRateAcknowledge", -1);

            break;

         /* logicalChannelRateReject */
         case 24:
            rtInvokeStartElement (pctxt, "logicalChannelRateReject", -1);

            pvalue->u.logicalChannelRateReject = ALLOC_ASN1ELEM (pctxt, H245LogicalChannelRateReject);
            if (pvalue->u.logicalChannelRateReject == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245LogicalChannelRateReject (pctxt, pvalue->u.logicalChannelRateReject);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "logicalChannelRateReject", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MaintenanceLoopOffCommand                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MaintenanceLoopOffCommand (OOCTXT* pctxt, H245MaintenanceLoopOffCommand* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SendTerminalCapabilitySet_specificRequest_capabilityTabl  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers (OOCTXT* pctxt, H245SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 65535, 0 };
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, H245CapabilityTableEntryNumber);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      stat = asn1PD_H245CapabilityTableEntryNumber (pctxt, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SendTerminalCapabilitySet_specificRequest_capabilityDesc  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers (OOCTXT* pctxt, H245SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      stat = asn1PD_H245CapabilityDescriptorNumber (pctxt, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SendTerminalCapabilitySet_specificRequest                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245SendTerminalCapabilitySet_specificRequest (OOCTXT* pctxt, H245SendTerminalCapabilitySet_specificRequest* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.capabilityTableEntryNumbersPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.capabilityDescriptorNumbersPresent = optbit;

   /* decode multiplexCapability */

   rtInvokeStartElement (pctxt, "multiplexCapability", -1);

   stat = DECODEBIT (pctxt, &pvalue->multiplexCapability);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->multiplexCapability);

   rtInvokeEndElement (pctxt, "multiplexCapability", -1);

   /* decode capabilityTableEntryNumbers */

   if (pvalue->m.capabilityTableEntryNumbersPresent) {
      rtInvokeStartElement (pctxt, "capabilityTableEntryNumbers", -1);

      stat = asn1PD_H245SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers (pctxt, &pvalue->capabilityTableEntryNumbers);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "capabilityTableEntryNumbers", -1);
   }

   /* decode capabilityDescriptorNumbers */

   if (pvalue->m.capabilityDescriptorNumbersPresent) {
      rtInvokeStartElement (pctxt, "capabilityDescriptorNumbers", -1);

      stat = asn1PD_H245SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers (pctxt, &pvalue->capabilityDescriptorNumbers);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "capabilityDescriptorNumbers", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SendTerminalCapabilitySet                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245SendTerminalCapabilitySet (OOCTXT* pctxt, H245SendTerminalCapabilitySet* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* specificRequest */
         case 0:
            rtInvokeStartElement (pctxt, "specificRequest", -1);

            pvalue->u.specificRequest = ALLOC_ASN1ELEM (pctxt, H245SendTerminalCapabilitySet_specificRequest);
            if (pvalue->u.specificRequest == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245SendTerminalCapabilitySet_specificRequest (pctxt, pvalue->u.specificRequest);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "specificRequest", -1);

            break;

         /* genericRequest */
         case 1:
            rtInvokeStartElement (pctxt, "genericRequest", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "genericRequest", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncryptionCommand_encryptionAlgorithmID                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245EncryptionCommand_encryptionAlgorithmID (OOCTXT* pctxt, H245EncryptionCommand_encryptionAlgorithmID* pvalue)
{
   int stat = ASN_OK;

   /* decode h233AlgorithmIdentifier */

   rtInvokeStartElement (pctxt, "h233AlgorithmIdentifier", -1);

   stat = asn1PD_H245SequenceNumber (pctxt, &pvalue->h233AlgorithmIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "h233AlgorithmIdentifier", -1);

   /* decode associatedAlgorithm */

   rtInvokeStartElement (pctxt, "associatedAlgorithm", -1);

   stat = asn1PD_H245NonStandardParameter (pctxt, &pvalue->associatedAlgorithm);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "associatedAlgorithm", -1);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncryptionCommand                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245EncryptionCommand (OOCTXT* pctxt, H245EncryptionCommand* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* encryptionSE */
         case 0:
            rtInvokeStartElement (pctxt, "encryptionSE", -1);

            pvalue->u.encryptionSE = ALLOC_ASN1ELEM (pctxt, ASN1DynOctStr);
            if (pvalue->u.encryptionSE == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)pvalue->u.encryptionSE);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeOctStrValue (pctxt, pvalue->u.encryptionSE->numocts, pvalue->u.encryptionSE->data);

            rtInvokeEndElement (pctxt, "encryptionSE", -1);

            break;

         /* encryptionIVRequest */
         case 1:
            rtInvokeStartElement (pctxt, "encryptionIVRequest", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "encryptionIVRequest", -1);

            break;

         /* encryptionAlgorithmID */
         case 2:
            rtInvokeStartElement (pctxt, "encryptionAlgorithmID", -1);

            pvalue->u.encryptionAlgorithmID = ALLOC_ASN1ELEM (pctxt, H245EncryptionCommand_encryptionAlgorithmID);
            if (pvalue->u.encryptionAlgorithmID == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245EncryptionCommand_encryptionAlgorithmID (pctxt, pvalue->u.encryptionAlgorithmID);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "encryptionAlgorithmID", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FlowControlCommand_scope                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245FlowControlCommand_scope (OOCTXT* pctxt, H245FlowControlCommand_scope* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* logicalChannelNumber */
      case 0:
         rtInvokeStartElement (pctxt, "logicalChannelNumber", -1);

         stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.logicalChannelNumber);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

         rtInvokeEndElement (pctxt, "logicalChannelNumber", -1);

         break;

      /* resourceID */
      case 1:
         rtInvokeStartElement (pctxt, "resourceID", -1);

         stat = decodeConsUInt16 (pctxt, &pvalue->u.resourceID, 0U, 65535U);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         rtInvokeUIntValue (pctxt, pvalue->u.resourceID);

         rtInvokeEndElement (pctxt, "resourceID", -1);

         break;

      /* wholeMultiplex */
      case 2:
         rtInvokeStartElement (pctxt, "wholeMultiplex", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "wholeMultiplex", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FlowControlCommand_restriction                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245FlowControlCommand_restriction (OOCTXT* pctxt, H245FlowControlCommand_restriction* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* maximumBitRate */
      case 0:
         rtInvokeStartElement (pctxt, "maximumBitRate", -1);

         stat = decodeConsUnsigned (pctxt, &pvalue->u.maximumBitRate, 0U, 16777215U);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         rtInvokeUIntValue (pctxt, pvalue->u.maximumBitRate);

         rtInvokeEndElement (pctxt, "maximumBitRate", -1);

         break;

      /* noRestriction */
      case 1:
         rtInvokeStartElement (pctxt, "noRestriction", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "noRestriction", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FlowControlCommand                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245FlowControlCommand (OOCTXT* pctxt, H245FlowControlCommand* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode scope */

   rtInvokeStartElement (pctxt, "scope", -1);

   stat = asn1PD_H245FlowControlCommand_scope (pctxt, &pvalue->scope);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "scope", -1);

   /* decode restriction */

   rtInvokeStartElement (pctxt, "restriction", -1);

   stat = asn1PD_H245FlowControlCommand_restriction (pctxt, &pvalue->restriction);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "restriction", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EndSessionCommand_gstnOptions                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245EndSessionCommand_gstnOptions (OOCTXT* pctxt, H245EndSessionCommand_gstnOptions* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 4);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* telephonyMode */
         case 0:
            rtInvokeStartElement (pctxt, "telephonyMode", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "telephonyMode", -1);

            break;

         /* v8bis */
         case 1:
            rtInvokeStartElement (pctxt, "v8bis", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "v8bis", -1);

            break;

         /* v34DSVD */
         case 2:
            rtInvokeStartElement (pctxt, "v34DSVD", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "v34DSVD", -1);

            break;

         /* v34DuplexFAX */
         case 3:
            rtInvokeStartElement (pctxt, "v34DuplexFAX", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "v34DuplexFAX", -1);

            break;

         /* v34H324 */
         case 4:
            rtInvokeStartElement (pctxt, "v34H324", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "v34H324", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 6;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EndSessionCommand_isdnOptions                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245EndSessionCommand_isdnOptions (OOCTXT* pctxt, H245EndSessionCommand_isdnOptions* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* telephonyMode */
         case 0:
            rtInvokeStartElement (pctxt, "telephonyMode", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "telephonyMode", -1);

            break;

         /* v140 */
         case 1:
            rtInvokeStartElement (pctxt, "v140", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "v140", -1);

            break;

         /* terminalOnHold */
         case 2:
            rtInvokeStartElement (pctxt, "terminalOnHold", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "terminalOnHold", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EndSessionCommand                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245EndSessionCommand (OOCTXT* pctxt, H245EndSessionCommand* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* disconnect */
         case 1:
            rtInvokeStartElement (pctxt, "disconnect", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "disconnect", -1);

            break;

         /* gstnOptions */
         case 2:
            rtInvokeStartElement (pctxt, "gstnOptions", -1);

            pvalue->u.gstnOptions = ALLOC_ASN1ELEM (pctxt, H245EndSessionCommand_gstnOptions);
            if (pvalue->u.gstnOptions == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245EndSessionCommand_gstnOptions (pctxt, pvalue->u.gstnOptions);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "gstnOptions", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* isdnOptions */
         case 4:
            rtInvokeStartElement (pctxt, "isdnOptions", -1);

            pvalue->u.isdnOptions = ALLOC_ASN1ELEM (pctxt, H245EndSessionCommand_isdnOptions);
            if (pvalue->u.isdnOptions == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245EndSessionCommand_isdnOptions (pctxt, pvalue->u.isdnOptions);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "isdnOptions", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MiscellaneousCommand_type_videoFastUpdateGOB              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MiscellaneousCommand_type_videoFastUpdateGOB (OOCTXT* pctxt, H245MiscellaneousCommand_type_videoFastUpdateGOB* pvalue)
{
   int stat = ASN_OK;

   /* decode firstGOB */

   rtInvokeStartElement (pctxt, "firstGOB", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->firstGOB, 0U, 17U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->firstGOB);

   rtInvokeEndElement (pctxt, "firstGOB", -1);

   /* decode numberOfGOBs */

   rtInvokeStartElement (pctxt, "numberOfGOBs", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->numberOfGOBs, 1U, 18U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->numberOfGOBs);

   rtInvokeEndElement (pctxt, "numberOfGOBs", -1);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MiscellaneousCommand_type_videoFastUpdateMB               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MiscellaneousCommand_type_videoFastUpdateMB (OOCTXT* pctxt, H245MiscellaneousCommand_type_videoFastUpdateMB* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.firstGOBPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.firstMBPresent = optbit;

   /* decode firstGOB */

   if (pvalue->m.firstGOBPresent) {
      rtInvokeStartElement (pctxt, "firstGOB", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->firstGOB, 0U, 255U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->firstGOB);

      rtInvokeEndElement (pctxt, "firstGOB", -1);
   }

   /* decode firstMB */

   if (pvalue->m.firstMBPresent) {
      rtInvokeStartElement (pctxt, "firstMB", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->firstMB, 1U, 8192U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->firstMB);

      rtInvokeEndElement (pctxt, "firstMB", -1);
   }

   /* decode numberOfMBs */

   rtInvokeStartElement (pctxt, "numberOfMBs", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->numberOfMBs, 1U, 8192U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->numberOfMBs);

   rtInvokeEndElement (pctxt, "numberOfMBs", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  KeyProtectionMethod                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245KeyProtectionMethod (OOCTXT* pctxt, H245KeyProtectionMethod* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode secureChannel */

   rtInvokeStartElement (pctxt, "secureChannel", -1);

   stat = DECODEBIT (pctxt, &pvalue->secureChannel);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->secureChannel);

   rtInvokeEndElement (pctxt, "secureChannel", -1);

   /* decode sharedSecret */

   rtInvokeStartElement (pctxt, "sharedSecret", -1);

   stat = DECODEBIT (pctxt, &pvalue->sharedSecret);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->sharedSecret);

   rtInvokeEndElement (pctxt, "sharedSecret", -1);

   /* decode certProtectedKey */

   rtInvokeStartElement (pctxt, "certProtectedKey", -1);

   stat = DECODEBIT (pctxt, &pvalue->certProtectedKey);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->certProtectedKey);

   rtInvokeEndElement (pctxt, "certProtectedKey", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncryptionUpdateRequest                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245EncryptionUpdateRequest (OOCTXT* pctxt, H245EncryptionUpdateRequest* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.keyProtectionMethodPresent = optbit;

   /* decode keyProtectionMethod */

   if (pvalue->m.keyProtectionMethodPresent) {
      rtInvokeStartElement (pctxt, "keyProtectionMethod", -1);

      stat = asn1PD_H245KeyProtectionMethod (pctxt, &pvalue->keyProtectionMethod);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "keyProtectionMethod", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MiscellaneousCommand_type_progressiveRefinementStart_rep  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MiscellaneousCommand_type_progressiveRefinementStart_repeatCount (OOCTXT* pctxt, H245MiscellaneousCommand_type_progressiveRefinementStart_repeatCount* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* doOneProgression */
         case 0:
            rtInvokeStartElement (pctxt, "doOneProgression", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "doOneProgression", -1);

            break;

         /* doContinuousProgressions */
         case 1:
            rtInvokeStartElement (pctxt, "doContinuousProgressions", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "doContinuousProgressions", -1);

            break;

         /* doOneIndependentProgression */
         case 2:
            rtInvokeStartElement (pctxt, "doOneIndependentProgression", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "doOneIndependentProgression", -1);

            break;

         /* doContinuousIndependentProgressions */
         case 3:
            rtInvokeStartElement (pctxt, "doContinuousIndependentProgressions", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "doContinuousIndependentProgressions", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MiscellaneousCommand_type_progressiveRefinementStart      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MiscellaneousCommand_type_progressiveRefinementStart (OOCTXT* pctxt, H245MiscellaneousCommand_type_progressiveRefinementStart* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode repeatCount */

   rtInvokeStartElement (pctxt, "repeatCount", -1);

   stat = asn1PD_H245MiscellaneousCommand_type_progressiveRefinementStart_repeatCount (pctxt, &pvalue->repeatCount);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "repeatCount", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MiscellaneousCommand_type_videoBadMBs                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MiscellaneousCommand_type_videoBadMBs (OOCTXT* pctxt, H245MiscellaneousCommand_type_videoBadMBs* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode firstMB */

   rtInvokeStartElement (pctxt, "firstMB", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->firstMB, 1U, 9216U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->firstMB);

   rtInvokeEndElement (pctxt, "firstMB", -1);

   /* decode numberOfMBs */

   rtInvokeStartElement (pctxt, "numberOfMBs", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->numberOfMBs, 1U, 9216U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->numberOfMBs);

   rtInvokeEndElement (pctxt, "numberOfMBs", -1);

   /* decode temporalReference */

   rtInvokeStartElement (pctxt, "temporalReference", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->temporalReference, 0U, 1023U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->temporalReference);

   rtInvokeEndElement (pctxt, "temporalReference", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PictureReference                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245PictureReference (OOCTXT* pctxt, H245PictureReference* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* pictureNumber */
         case 0:
            rtInvokeStartElement (pctxt, "pictureNumber", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.pictureNumber, 0U, 1023U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.pictureNumber);

            rtInvokeEndElement (pctxt, "pictureNumber", -1);

            break;

         /* longTermPictureIndex */
         case 1:
            rtInvokeStartElement (pctxt, "longTermPictureIndex", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->u.longTermPictureIndex, 0U, 255U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.longTermPictureIndex);

            rtInvokeEndElement (pctxt, "longTermPictureIndex", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH245PictureReference                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245_SeqOfH245PictureReference (OOCTXT* pctxt, H245_SeqOfH245PictureReference* pvalue)
{
   int stat = ASN_OK;
   H245PictureReference* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         rtInvokeStartElement (pctxt, "elem", xx1);

         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245PictureReference);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H245PictureReference (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         rtInvokeEndElement (pctxt, "elem", xx1);

         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MiscellaneousCommand_type_lostPartialPicture              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MiscellaneousCommand_type_lostPartialPicture (OOCTXT* pctxt, H245MiscellaneousCommand_type_lostPartialPicture* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode pictureReference */

   rtInvokeStartElement (pctxt, "pictureReference", -1);

   stat = asn1PD_H245PictureReference (pctxt, &pvalue->pictureReference);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "pictureReference", -1);

   /* decode firstMB */

   rtInvokeStartElement (pctxt, "firstMB", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->firstMB, 1U, 9216U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->firstMB);

   rtInvokeEndElement (pctxt, "firstMB", -1);

   /* decode numberOfMBs */

   rtInvokeStartElement (pctxt, "numberOfMBs", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->numberOfMBs, 1U, 9216U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->numberOfMBs);

   rtInvokeEndElement (pctxt, "numberOfMBs", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MiscellaneousCommand_type                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MiscellaneousCommand_type (OOCTXT* pctxt, H245MiscellaneousCommand_type* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 9);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* equaliseDelay */
         case 0:
            rtInvokeStartElement (pctxt, "equaliseDelay", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "equaliseDelay", -1);

            break;

         /* zeroDelay */
         case 1:
            rtInvokeStartElement (pctxt, "zeroDelay", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "zeroDelay", -1);

            break;

         /* multipointModeCommand */
         case 2:
            rtInvokeStartElement (pctxt, "multipointModeCommand", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "multipointModeCommand", -1);

            break;

         /* cancelMultipointModeCommand */
         case 3:
            rtInvokeStartElement (pctxt, "cancelMultipointModeCommand", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "cancelMultipointModeCommand", -1);

            break;

         /* videoFreezePicture */
         case 4:
            rtInvokeStartElement (pctxt, "videoFreezePicture", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "videoFreezePicture", -1);

            break;

         /* videoFastUpdatePicture */
         case 5:
            rtInvokeStartElement (pctxt, "videoFastUpdatePicture", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "videoFastUpdatePicture", -1);

            break;

         /* videoFastUpdateGOB */
         case 6:
            rtInvokeStartElement (pctxt, "videoFastUpdateGOB", -1);

            pvalue->u.videoFastUpdateGOB = ALLOC_ASN1ELEM (pctxt, H245MiscellaneousCommand_type_videoFastUpdateGOB);
            if (pvalue->u.videoFastUpdateGOB == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MiscellaneousCommand_type_videoFastUpdateGOB (pctxt, pvalue->u.videoFastUpdateGOB);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "videoFastUpdateGOB", -1);

            break;

         /* videoTemporalSpatialTradeOff */
         case 7:
            rtInvokeStartElement (pctxt, "videoTemporalSpatialTradeOff", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->u.videoTemporalSpatialTradeOff, 0U, 31U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.videoTemporalSpatialTradeOff);

            rtInvokeEndElement (pctxt, "videoTemporalSpatialTradeOff", -1);

            break;

         /* videoSendSyncEveryGOB */
         case 8:
            rtInvokeStartElement (pctxt, "videoSendSyncEveryGOB", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "videoSendSyncEveryGOB", -1);

            break;

         /* videoSendSyncEveryGOBCancel */
         case 9:
            rtInvokeStartElement (pctxt, "videoSendSyncEveryGOBCancel", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "videoSendSyncEveryGOBCancel", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 11;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* videoFastUpdateMB */
         case 11:
            rtInvokeStartElement (pctxt, "videoFastUpdateMB", -1);

            pvalue->u.videoFastUpdateMB = ALLOC_ASN1ELEM (pctxt, H245MiscellaneousCommand_type_videoFastUpdateMB);
            if (pvalue->u.videoFastUpdateMB == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MiscellaneousCommand_type_videoFastUpdateMB (pctxt, pvalue->u.videoFastUpdateMB);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "videoFastUpdateMB", -1);

            break;

         /* maxH223MUXPDUsize */
         case 12:
            rtInvokeStartElement (pctxt, "maxH223MUXPDUsize", -1);

            stat = decodeConsUInt16 (pctxt, &pvalue->u.maxH223MUXPDUsize, 1U, 65535U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.maxH223MUXPDUsize);

            rtInvokeEndElement (pctxt, "maxH223MUXPDUsize", -1);

            break;

         /* encryptionUpdate */
         case 13:
            rtInvokeStartElement (pctxt, "encryptionUpdate", -1);

            pvalue->u.encryptionUpdate = ALLOC_ASN1ELEM (pctxt, H245EncryptionSync);
            if (pvalue->u.encryptionUpdate == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245EncryptionSync (pctxt, pvalue->u.encryptionUpdate);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "encryptionUpdate", -1);

            break;

         /* encryptionUpdateRequest */
         case 14:
            rtInvokeStartElement (pctxt, "encryptionUpdateRequest", -1);

            pvalue->u.encryptionUpdateRequest = ALLOC_ASN1ELEM (pctxt, H245EncryptionUpdateRequest);
            if (pvalue->u.encryptionUpdateRequest == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245EncryptionUpdateRequest (pctxt, pvalue->u.encryptionUpdateRequest);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "encryptionUpdateRequest", -1);

            break;

         /* switchReceiveMediaOff */
         case 15:
            rtInvokeStartElement (pctxt, "switchReceiveMediaOff", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "switchReceiveMediaOff", -1);

            break;

         /* switchReceiveMediaOn */
         case 16:
            rtInvokeStartElement (pctxt, "switchReceiveMediaOn", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "switchReceiveMediaOn", -1);

            break;

         /* progressiveRefinementStart */
         case 17:
            rtInvokeStartElement (pctxt, "progressiveRefinementStart", -1);

            pvalue->u.progressiveRefinementStart = ALLOC_ASN1ELEM (pctxt, H245MiscellaneousCommand_type_progressiveRefinementStart);
            if (pvalue->u.progressiveRefinementStart == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MiscellaneousCommand_type_progressiveRefinementStart (pctxt, pvalue->u.progressiveRefinementStart);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "progressiveRefinementStart", -1);

            break;

         /* progressiveRefinementAbortOne */
         case 18:
            rtInvokeStartElement (pctxt, "progressiveRefinementAbortOne", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "progressiveRefinementAbortOne", -1);

            break;

         /* progressiveRefinementAbortContinuous */
         case 19:
            rtInvokeStartElement (pctxt, "progressiveRefinementAbortContinuous", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "progressiveRefinementAbortContinuous", -1);

            break;

         /* videoBadMBs */
         case 20:
            rtInvokeStartElement (pctxt, "videoBadMBs", -1);

            pvalue->u.videoBadMBs = ALLOC_ASN1ELEM (pctxt, H245MiscellaneousCommand_type_videoBadMBs);
            if (pvalue->u.videoBadMBs == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MiscellaneousCommand_type_videoBadMBs (pctxt, pvalue->u.videoBadMBs);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "videoBadMBs", -1);

            break;

         /* lostPicture */
         case 21:
            rtInvokeStartElement (pctxt, "lostPicture", -1);

            pvalue->u.lostPicture = ALLOC_ASN1ELEM (pctxt, H245_SeqOfH245PictureReference);
            if (pvalue->u.lostPicture == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245_SeqOfH245PictureReference (pctxt, pvalue->u.lostPicture);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "lostPicture", -1);

            break;

         /* lostPartialPicture */
         case 22:
            rtInvokeStartElement (pctxt, "lostPartialPicture", -1);

            pvalue->u.lostPartialPicture = ALLOC_ASN1ELEM (pctxt, H245MiscellaneousCommand_type_lostPartialPicture);
            if (pvalue->u.lostPartialPicture == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MiscellaneousCommand_type_lostPartialPicture (pctxt, pvalue->u.lostPartialPicture);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "lostPartialPicture", -1);

            break;

         /* recoveryReferencePicture */
         case 23:
            rtInvokeStartElement (pctxt, "recoveryReferencePicture", -1);

            pvalue->u.recoveryReferencePicture = ALLOC_ASN1ELEM (pctxt, H245_SeqOfH245PictureReference);
            if (pvalue->u.recoveryReferencePicture == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245_SeqOfH245PictureReference (pctxt, pvalue->u.recoveryReferencePicture);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "recoveryReferencePicture", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MiscellaneousCommand                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MiscellaneousCommand (OOCTXT* pctxt, H245MiscellaneousCommand* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode logicalChannelNumber */

   rtInvokeStartElement (pctxt, "logicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "logicalChannelNumber", -1);

   /* decode type */

   rtInvokeStartElement (pctxt, "type", -1);

   stat = asn1PD_H245MiscellaneousCommand_type (pctxt, &pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "type", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommunicationModeCommand_communicationModeTable           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CommunicationModeCommand_communicationModeTable (OOCTXT* pctxt, H245CommunicationModeCommand_communicationModeTable* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;
   H245CommunicationModeTableEntry* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H245CommunicationModeTableEntry);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H245CommunicationModeTableEntry (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommunicationModeCommand                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CommunicationModeCommand (OOCTXT* pctxt, H245CommunicationModeCommand* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode communicationModeTable */

   rtInvokeStartElement (pctxt, "communicationModeTable", -1);

   stat = asn1PD_H245CommunicationModeCommand_communicationModeTable (pctxt, &pvalue->communicationModeTable);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "communicationModeTable", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SubstituteConferenceIDCommand                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245SubstituteConferenceIDCommand (OOCTXT* pctxt, H245SubstituteConferenceIDCommand* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode conferenceIdentifier */

   rtInvokeStartElement (pctxt, "conferenceIdentifier", -1);

   stat = asn1PD_H245SubstituteConferenceIDCommand_conferenceIdentifier (pctxt, &pvalue->conferenceIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "conferenceIdentifier", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConferenceCommand                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ConferenceCommand (OOCTXT* pctxt, H245ConferenceCommand* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 6);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* broadcastMyLogicalChannel */
         case 0:
            rtInvokeStartElement (pctxt, "broadcastMyLogicalChannel", -1);

            stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.broadcastMyLogicalChannel);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "broadcastMyLogicalChannel", -1);

            break;

         /* cancelBroadcastMyLogicalChannel */
         case 1:
            rtInvokeStartElement (pctxt, "cancelBroadcastMyLogicalChannel", -1);

            stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.cancelBroadcastMyLogicalChannel);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "cancelBroadcastMyLogicalChannel", -1);

            break;

         /* makeTerminalBroadcaster */
         case 2:
            rtInvokeStartElement (pctxt, "makeTerminalBroadcaster", -1);

            pvalue->u.makeTerminalBroadcaster = ALLOC_ASN1ELEM (pctxt, H245TerminalLabel);
            if (pvalue->u.makeTerminalBroadcaster == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245TerminalLabel (pctxt, pvalue->u.makeTerminalBroadcaster);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "makeTerminalBroadcaster", -1);

            break;

         /* cancelMakeTerminalBroadcaster */
         case 3:
            rtInvokeStartElement (pctxt, "cancelMakeTerminalBroadcaster", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "cancelMakeTerminalBroadcaster", -1);

            break;

         /* sendThisSource */
         case 4:
            rtInvokeStartElement (pctxt, "sendThisSource", -1);

            pvalue->u.sendThisSource = ALLOC_ASN1ELEM (pctxt, H245TerminalLabel);
            if (pvalue->u.sendThisSource == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245TerminalLabel (pctxt, pvalue->u.sendThisSource);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "sendThisSource", -1);

            break;

         /* cancelSendThisSource */
         case 5:
            rtInvokeStartElement (pctxt, "cancelSendThisSource", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "cancelSendThisSource", -1);

            break;

         /* dropConference */
         case 6:
            rtInvokeStartElement (pctxt, "dropConference", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "dropConference", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 8;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* substituteConferenceIDCommand */
         case 8:
            rtInvokeStartElement (pctxt, "substituteConferenceIDCommand", -1);

            pvalue->u.substituteConferenceIDCommand = ALLOC_ASN1ELEM (pctxt, H245SubstituteConferenceIDCommand);
            if (pvalue->u.substituteConferenceIDCommand == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245SubstituteConferenceIDCommand (pctxt, pvalue->u.substituteConferenceIDCommand);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "substituteConferenceIDCommand", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223MultiplexReconfiguration_h223ModeChange               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223MultiplexReconfiguration_h223ModeChange (OOCTXT* pctxt, H245H223MultiplexReconfiguration_h223ModeChange* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* toLevel0 */
         case 0:
            rtInvokeStartElement (pctxt, "toLevel0", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "toLevel0", -1);

            break;

         /* toLevel1 */
         case 1:
            rtInvokeStartElement (pctxt, "toLevel1", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "toLevel1", -1);

            break;

         /* toLevel2 */
         case 2:
            rtInvokeStartElement (pctxt, "toLevel2", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "toLevel2", -1);

            break;

         /* toLevel2withOptionalHeader */
         case 3:
            rtInvokeStartElement (pctxt, "toLevel2withOptionalHeader", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "toLevel2withOptionalHeader", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223MultiplexReconfiguration_h223AnnexADoubleFlag         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223MultiplexReconfiguration_h223AnnexADoubleFlag (OOCTXT* pctxt, H245H223MultiplexReconfiguration_h223AnnexADoubleFlag* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* start */
         case 0:
            rtInvokeStartElement (pctxt, "start", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "start", -1);

            break;

         /* stop */
         case 1:
            rtInvokeStartElement (pctxt, "stop", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "stop", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223MultiplexReconfiguration                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223MultiplexReconfiguration (OOCTXT* pctxt, H245H223MultiplexReconfiguration* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* h223ModeChange */
         case 0:
            rtInvokeStartElement (pctxt, "h223ModeChange", -1);

            pvalue->u.h223ModeChange = ALLOC_ASN1ELEM (pctxt, H245H223MultiplexReconfiguration_h223ModeChange);
            if (pvalue->u.h223ModeChange == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H223MultiplexReconfiguration_h223ModeChange (pctxt, pvalue->u.h223ModeChange);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h223ModeChange", -1);

            break;

         /* h223AnnexADoubleFlag */
         case 1:
            rtInvokeStartElement (pctxt, "h223AnnexADoubleFlag", -1);

            pvalue->u.h223AnnexADoubleFlag = ALLOC_ASN1ELEM (pctxt, H245H223MultiplexReconfiguration_h223AnnexADoubleFlag);
            if (pvalue->u.h223AnnexADoubleFlag == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H223MultiplexReconfiguration_h223AnnexADoubleFlag (pctxt, pvalue->u.h223AnnexADoubleFlag);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h223AnnexADoubleFlag", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NewATMVCCommand_aal_aal1_clockRecovery                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NewATMVCCommand_aal_aal1_clockRecovery (OOCTXT* pctxt, H245NewATMVCCommand_aal_aal1_clockRecovery* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nullClockRecovery */
         case 0:
            rtInvokeStartElement (pctxt, "nullClockRecovery", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "nullClockRecovery", -1);

            break;

         /* srtsClockRecovery */
         case 1:
            rtInvokeStartElement (pctxt, "srtsClockRecovery", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "srtsClockRecovery", -1);

            break;

         /* adaptiveClockRecovery */
         case 2:
            rtInvokeStartElement (pctxt, "adaptiveClockRecovery", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "adaptiveClockRecovery", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NewATMVCCommand_aal_aal1_errorCorrection                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NewATMVCCommand_aal_aal1_errorCorrection (OOCTXT* pctxt, H245NewATMVCCommand_aal_aal1_errorCorrection* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nullErrorCorrection */
         case 0:
            rtInvokeStartElement (pctxt, "nullErrorCorrection", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "nullErrorCorrection", -1);

            break;

         /* longInterleaver */
         case 1:
            rtInvokeStartElement (pctxt, "longInterleaver", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "longInterleaver", -1);

            break;

         /* shortInterleaver */
         case 2:
            rtInvokeStartElement (pctxt, "shortInterleaver", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "shortInterleaver", -1);

            break;

         /* errorCorrectionOnly */
         case 3:
            rtInvokeStartElement (pctxt, "errorCorrectionOnly", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "errorCorrectionOnly", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NewATMVCCommand_aal_aal1                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NewATMVCCommand_aal_aal1 (OOCTXT* pctxt, H245NewATMVCCommand_aal_aal1* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode clockRecovery */

   rtInvokeStartElement (pctxt, "clockRecovery", -1);

   stat = asn1PD_H245NewATMVCCommand_aal_aal1_clockRecovery (pctxt, &pvalue->clockRecovery);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "clockRecovery", -1);

   /* decode errorCorrection */

   rtInvokeStartElement (pctxt, "errorCorrection", -1);

   stat = asn1PD_H245NewATMVCCommand_aal_aal1_errorCorrection (pctxt, &pvalue->errorCorrection);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "errorCorrection", -1);

   /* decode structuredDataTransfer */

   rtInvokeStartElement (pctxt, "structuredDataTransfer", -1);

   stat = DECODEBIT (pctxt, &pvalue->structuredDataTransfer);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->structuredDataTransfer);

   rtInvokeEndElement (pctxt, "structuredDataTransfer", -1);

   /* decode partiallyFilledCells */

   rtInvokeStartElement (pctxt, "partiallyFilledCells", -1);

   stat = DECODEBIT (pctxt, &pvalue->partiallyFilledCells);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->partiallyFilledCells);

   rtInvokeEndElement (pctxt, "partiallyFilledCells", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NewATMVCCommand_aal_aal5                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NewATMVCCommand_aal_aal5 (OOCTXT* pctxt, H245NewATMVCCommand_aal_aal5* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode forwardMaximumSDUSize */

   rtInvokeStartElement (pctxt, "forwardMaximumSDUSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->forwardMaximumSDUSize, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->forwardMaximumSDUSize);

   rtInvokeEndElement (pctxt, "forwardMaximumSDUSize", -1);

   /* decode backwardMaximumSDUSize */

   rtInvokeStartElement (pctxt, "backwardMaximumSDUSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->backwardMaximumSDUSize, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->backwardMaximumSDUSize);

   rtInvokeEndElement (pctxt, "backwardMaximumSDUSize", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NewATMVCCommand_aal                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NewATMVCCommand_aal (OOCTXT* pctxt, H245NewATMVCCommand_aal* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* aal1 */
         case 0:
            rtInvokeStartElement (pctxt, "aal1", -1);

            pvalue->u.aal1 = ALLOC_ASN1ELEM (pctxt, H245NewATMVCCommand_aal_aal1);
            if (pvalue->u.aal1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NewATMVCCommand_aal_aal1 (pctxt, pvalue->u.aal1);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "aal1", -1);

            break;

         /* aal5 */
         case 1:
            rtInvokeStartElement (pctxt, "aal5", -1);

            pvalue->u.aal5 = ALLOC_ASN1ELEM (pctxt, H245NewATMVCCommand_aal_aal5);
            if (pvalue->u.aal5 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NewATMVCCommand_aal_aal5 (pctxt, pvalue->u.aal5);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "aal5", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NewATMVCCommand_multiplex                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NewATMVCCommand_multiplex (OOCTXT* pctxt, H245NewATMVCCommand_multiplex* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* noMultiplex */
         case 0:
            rtInvokeStartElement (pctxt, "noMultiplex", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "noMultiplex", -1);

            break;

         /* transportStream */
         case 1:
            rtInvokeStartElement (pctxt, "transportStream", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "transportStream", -1);

            break;

         /* programStream */
         case 2:
            rtInvokeStartElement (pctxt, "programStream", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "programStream", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NewATMVCCommand_reverseParameters_multiplex               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NewATMVCCommand_reverseParameters_multiplex (OOCTXT* pctxt, H245NewATMVCCommand_reverseParameters_multiplex* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* noMultiplex */
         case 0:
            rtInvokeStartElement (pctxt, "noMultiplex", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "noMultiplex", -1);

            break;

         /* transportStream */
         case 1:
            rtInvokeStartElement (pctxt, "transportStream", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "transportStream", -1);

            break;

         /* programStream */
         case 2:
            rtInvokeStartElement (pctxt, "programStream", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "programStream", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NewATMVCCommand_reverseParameters                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NewATMVCCommand_reverseParameters (OOCTXT* pctxt, H245NewATMVCCommand_reverseParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode bitRate */

   rtInvokeStartElement (pctxt, "bitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->bitRate, 1U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->bitRate);

   rtInvokeEndElement (pctxt, "bitRate", -1);

   /* decode bitRateLockedToPCRClock */

   rtInvokeStartElement (pctxt, "bitRateLockedToPCRClock", -1);

   stat = DECODEBIT (pctxt, &pvalue->bitRateLockedToPCRClock);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->bitRateLockedToPCRClock);

   rtInvokeEndElement (pctxt, "bitRateLockedToPCRClock", -1);

   /* decode bitRateLockedToNetworkClock */

   rtInvokeStartElement (pctxt, "bitRateLockedToNetworkClock", -1);

   stat = DECODEBIT (pctxt, &pvalue->bitRateLockedToNetworkClock);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->bitRateLockedToNetworkClock);

   rtInvokeEndElement (pctxt, "bitRateLockedToNetworkClock", -1);

   /* decode multiplex */

   rtInvokeStartElement (pctxt, "multiplex", -1);

   stat = asn1PD_H245NewATMVCCommand_reverseParameters_multiplex (pctxt, &pvalue->multiplex);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "multiplex", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NewATMVCCommand                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NewATMVCCommand (OOCTXT* pctxt, H245NewATMVCCommand* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode resourceID */

   rtInvokeStartElement (pctxt, "resourceID", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->resourceID, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->resourceID);

   rtInvokeEndElement (pctxt, "resourceID", -1);

   /* decode bitRate */

   rtInvokeStartElement (pctxt, "bitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->bitRate, 1U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->bitRate);

   rtInvokeEndElement (pctxt, "bitRate", -1);

   /* decode bitRateLockedToPCRClock */

   rtInvokeStartElement (pctxt, "bitRateLockedToPCRClock", -1);

   stat = DECODEBIT (pctxt, &pvalue->bitRateLockedToPCRClock);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->bitRateLockedToPCRClock);

   rtInvokeEndElement (pctxt, "bitRateLockedToPCRClock", -1);

   /* decode bitRateLockedToNetworkClock */

   rtInvokeStartElement (pctxt, "bitRateLockedToNetworkClock", -1);

   stat = DECODEBIT (pctxt, &pvalue->bitRateLockedToNetworkClock);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->bitRateLockedToNetworkClock);

   rtInvokeEndElement (pctxt, "bitRateLockedToNetworkClock", -1);

   /* decode aal */

   rtInvokeStartElement (pctxt, "aal", -1);

   stat = asn1PD_H245NewATMVCCommand_aal (pctxt, &pvalue->aal);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "aal", -1);

   /* decode multiplex */

   rtInvokeStartElement (pctxt, "multiplex", -1);

   stat = asn1PD_H245NewATMVCCommand_multiplex (pctxt, &pvalue->multiplex);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "multiplex", -1);

   /* decode reverseParameters */

   rtInvokeStartElement (pctxt, "reverseParameters", -1);

   stat = asn1PD_H245NewATMVCCommand_reverseParameters (pctxt, &pvalue->reverseParameters);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "reverseParameters", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MobileMultilinkReconfigurationCommand_status              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MobileMultilinkReconfigurationCommand_status (OOCTXT* pctxt, H245MobileMultilinkReconfigurationCommand_status* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* synchronized_ */
         case 0:
            rtInvokeStartElement (pctxt, "synchronized_", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "synchronized_", -1);

            break;

         /* reconfiguration */
         case 1:
            rtInvokeStartElement (pctxt, "reconfiguration", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "reconfiguration", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MobileMultilinkReconfigurationCommand                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MobileMultilinkReconfigurationCommand (OOCTXT* pctxt, H245MobileMultilinkReconfigurationCommand* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode sampleSize */

   rtInvokeStartElement (pctxt, "sampleSize", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->sampleSize, 1U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->sampleSize);

   rtInvokeEndElement (pctxt, "sampleSize", -1);

   /* decode samplesPerFrame */

   rtInvokeStartElement (pctxt, "samplesPerFrame", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->samplesPerFrame, 1U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->samplesPerFrame);

   rtInvokeEndElement (pctxt, "samplesPerFrame", -1);

   /* decode status */

   rtInvokeStartElement (pctxt, "status", -1);

   stat = asn1PD_H245MobileMultilinkReconfigurationCommand_status (pctxt, &pvalue->status);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "status", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CommandMessage                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245CommandMessage (OOCTXT* pctxt, H245CommandMessage* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 6);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardMessage);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardMessage (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* maintenanceLoopOffCommand */
         case 1:
            rtInvokeStartElement (pctxt, "maintenanceLoopOffCommand", -1);

            pvalue->u.maintenanceLoopOffCommand = ALLOC_ASN1ELEM (pctxt, H245MaintenanceLoopOffCommand);
            if (pvalue->u.maintenanceLoopOffCommand == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MaintenanceLoopOffCommand (pctxt, pvalue->u.maintenanceLoopOffCommand);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "maintenanceLoopOffCommand", -1);

            break;

         /* sendTerminalCapabilitySet */
         case 2:
            rtInvokeStartElement (pctxt, "sendTerminalCapabilitySet", -1);

            pvalue->u.sendTerminalCapabilitySet = ALLOC_ASN1ELEM (pctxt, H245SendTerminalCapabilitySet);
            if (pvalue->u.sendTerminalCapabilitySet == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245SendTerminalCapabilitySet (pctxt, pvalue->u.sendTerminalCapabilitySet);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "sendTerminalCapabilitySet", -1);

            break;

         /* encryptionCommand */
         case 3:
            rtInvokeStartElement (pctxt, "encryptionCommand", -1);

            pvalue->u.encryptionCommand = ALLOC_ASN1ELEM (pctxt, H245EncryptionCommand);
            if (pvalue->u.encryptionCommand == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245EncryptionCommand (pctxt, pvalue->u.encryptionCommand);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "encryptionCommand", -1);

            break;

         /* flowControlCommand */
         case 4:
            rtInvokeStartElement (pctxt, "flowControlCommand", -1);

            pvalue->u.flowControlCommand = ALLOC_ASN1ELEM (pctxt, H245FlowControlCommand);
            if (pvalue->u.flowControlCommand == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245FlowControlCommand (pctxt, pvalue->u.flowControlCommand);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "flowControlCommand", -1);

            break;

         /* endSessionCommand */
         case 5:
            rtInvokeStartElement (pctxt, "endSessionCommand", -1);

            pvalue->u.endSessionCommand = ALLOC_ASN1ELEM (pctxt, H245EndSessionCommand);
            if (pvalue->u.endSessionCommand == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245EndSessionCommand (pctxt, pvalue->u.endSessionCommand);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "endSessionCommand", -1);

            break;

         /* miscellaneousCommand */
         case 6:
            rtInvokeStartElement (pctxt, "miscellaneousCommand", -1);

            pvalue->u.miscellaneousCommand = ALLOC_ASN1ELEM (pctxt, H245MiscellaneousCommand);
            if (pvalue->u.miscellaneousCommand == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MiscellaneousCommand (pctxt, pvalue->u.miscellaneousCommand);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "miscellaneousCommand", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 8;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* communicationModeCommand */
         case 8:
            rtInvokeStartElement (pctxt, "communicationModeCommand", -1);

            pvalue->u.communicationModeCommand = ALLOC_ASN1ELEM (pctxt, H245CommunicationModeCommand);
            if (pvalue->u.communicationModeCommand == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245CommunicationModeCommand (pctxt, pvalue->u.communicationModeCommand);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "communicationModeCommand", -1);

            break;

         /* conferenceCommand */
         case 9:
            rtInvokeStartElement (pctxt, "conferenceCommand", -1);

            pvalue->u.conferenceCommand = ALLOC_ASN1ELEM (pctxt, H245ConferenceCommand);
            if (pvalue->u.conferenceCommand == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245ConferenceCommand (pctxt, pvalue->u.conferenceCommand);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "conferenceCommand", -1);

            break;

         /* h223MultiplexReconfiguration */
         case 10:
            rtInvokeStartElement (pctxt, "h223MultiplexReconfiguration", -1);

            pvalue->u.h223MultiplexReconfiguration = ALLOC_ASN1ELEM (pctxt, H245H223MultiplexReconfiguration);
            if (pvalue->u.h223MultiplexReconfiguration == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H223MultiplexReconfiguration (pctxt, pvalue->u.h223MultiplexReconfiguration);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h223MultiplexReconfiguration", -1);

            break;

         /* newATMVCCommand */
         case 11:
            rtInvokeStartElement (pctxt, "newATMVCCommand", -1);

            pvalue->u.newATMVCCommand = ALLOC_ASN1ELEM (pctxt, H245NewATMVCCommand);
            if (pvalue->u.newATMVCCommand == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NewATMVCCommand (pctxt, pvalue->u.newATMVCCommand);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "newATMVCCommand", -1);

            break;

         /* mobileMultilinkReconfigurationCommand */
         case 12:
            rtInvokeStartElement (pctxt, "mobileMultilinkReconfigurationCommand", -1);

            pvalue->u.mobileMultilinkReconfigurationCommand = ALLOC_ASN1ELEM (pctxt, H245MobileMultilinkReconfigurationCommand);
            if (pvalue->u.mobileMultilinkReconfigurationCommand == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MobileMultilinkReconfigurationCommand (pctxt, pvalue->u.mobileMultilinkReconfigurationCommand);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "mobileMultilinkReconfigurationCommand", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FunctionNotUnderstood                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245FunctionNotUnderstood (OOCTXT* pctxt, H245FunctionNotUnderstood* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* request */
      case 0:
         rtInvokeStartElement (pctxt, "request", -1);

         pvalue->u.request = ALLOC_ASN1ELEM (pctxt, H245RequestMessage);
         if (pvalue->u.request == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H245RequestMessage (pctxt, pvalue->u.request);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

         rtInvokeEndElement (pctxt, "request", -1);

         break;

      /* response */
      case 1:
         rtInvokeStartElement (pctxt, "response", -1);

         pvalue->u.response = ALLOC_ASN1ELEM (pctxt, H245ResponseMessage);
         if (pvalue->u.response == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H245ResponseMessage (pctxt, pvalue->u.response);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

         rtInvokeEndElement (pctxt, "response", -1);

         break;

      /* command */
      case 2:
         rtInvokeStartElement (pctxt, "command", -1);

         pvalue->u.command = ALLOC_ASN1ELEM (pctxt, H245CommandMessage);
         if (pvalue->u.command == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H245CommandMessage (pctxt, pvalue->u.command);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

         rtInvokeEndElement (pctxt, "command", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MasterSlaveDeterminationRelease                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MasterSlaveDeterminationRelease (OOCTXT* pctxt, H245MasterSlaveDeterminationRelease* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalCapabilitySetRelease                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245TerminalCapabilitySetRelease (OOCTXT* pctxt, H245TerminalCapabilitySetRelease* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OpenLogicalChannelConfirm                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245OpenLogicalChannelConfirm (OOCTXT* pctxt, H245OpenLogicalChannelConfirm* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode forwardLogicalChannelNumber */

   rtInvokeStartElement (pctxt, "forwardLogicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->forwardLogicalChannelNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "forwardLogicalChannelNumber", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestChannelCloseRelease                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestChannelCloseRelease (OOCTXT* pctxt, H245RequestChannelCloseRelease* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode forwardLogicalChannelNumber */

   rtInvokeStartElement (pctxt, "forwardLogicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->forwardLogicalChannelNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "forwardLogicalChannelNumber", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexEntrySendRelease_multiplexTableEntryNumber       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplexEntrySendRelease_multiplexTableEntryNumber (OOCTXT* pctxt, H245MultiplexEntrySendRelease_multiplexTableEntryNumber* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 15, 0 };
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      stat = asn1PD_H245MultiplexTableEntryNumber (pctxt, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultiplexEntrySendRelease                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultiplexEntrySendRelease (OOCTXT* pctxt, H245MultiplexEntrySendRelease* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode multiplexTableEntryNumber */

   rtInvokeStartElement (pctxt, "multiplexTableEntryNumber", -1);

   stat = asn1PD_H245MultiplexEntrySendRelease_multiplexTableEntryNumber (pctxt, &pvalue->multiplexTableEntryNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "multiplexTableEntryNumber", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestMultiplexEntryRelease_entryNumbers                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestMultiplexEntryRelease_entryNumbers (OOCTXT* pctxt, H245RequestMultiplexEntryRelease_entryNumbers* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 15, 0 };
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      rtInvokeStartElement (pctxt, "elem", xx1);

      stat = asn1PD_H245MultiplexTableEntryNumber (pctxt, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeEndElement (pctxt, "elem", xx1);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestMultiplexEntryRelease                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestMultiplexEntryRelease (OOCTXT* pctxt, H245RequestMultiplexEntryRelease* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode entryNumbers */

   rtInvokeStartElement (pctxt, "entryNumbers", -1);

   stat = asn1PD_H245RequestMultiplexEntryRelease_entryNumbers (pctxt, &pvalue->entryNumbers);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "entryNumbers", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RequestModeRelease                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245RequestModeRelease (OOCTXT* pctxt, H245RequestModeRelease* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MiscellaneousIndication_type_videoNotDecodedMBs           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MiscellaneousIndication_type_videoNotDecodedMBs (OOCTXT* pctxt, H245MiscellaneousIndication_type_videoNotDecodedMBs* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode firstMB */

   rtInvokeStartElement (pctxt, "firstMB", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->firstMB, 1U, 8192U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->firstMB);

   rtInvokeEndElement (pctxt, "firstMB", -1);

   /* decode numberOfMBs */

   rtInvokeStartElement (pctxt, "numberOfMBs", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->numberOfMBs, 1U, 8192U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->numberOfMBs);

   rtInvokeEndElement (pctxt, "numberOfMBs", -1);

   /* decode temporalReference */

   rtInvokeStartElement (pctxt, "temporalReference", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->temporalReference, 0U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->temporalReference);

   rtInvokeEndElement (pctxt, "temporalReference", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MiscellaneousIndication_type                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MiscellaneousIndication_type (OOCTXT* pctxt, H245MiscellaneousIndication_type* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 9);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* logicalChannelActive */
         case 0:
            rtInvokeStartElement (pctxt, "logicalChannelActive", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "logicalChannelActive", -1);

            break;

         /* logicalChannelInactive */
         case 1:
            rtInvokeStartElement (pctxt, "logicalChannelInactive", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "logicalChannelInactive", -1);

            break;

         /* multipointConference */
         case 2:
            rtInvokeStartElement (pctxt, "multipointConference", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "multipointConference", -1);

            break;

         /* cancelMultipointConference */
         case 3:
            rtInvokeStartElement (pctxt, "cancelMultipointConference", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "cancelMultipointConference", -1);

            break;

         /* multipointZeroComm */
         case 4:
            rtInvokeStartElement (pctxt, "multipointZeroComm", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "multipointZeroComm", -1);

            break;

         /* cancelMultipointZeroComm */
         case 5:
            rtInvokeStartElement (pctxt, "cancelMultipointZeroComm", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "cancelMultipointZeroComm", -1);

            break;

         /* multipointSecondaryStatus */
         case 6:
            rtInvokeStartElement (pctxt, "multipointSecondaryStatus", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "multipointSecondaryStatus", -1);

            break;

         /* cancelMultipointSecondaryStatus */
         case 7:
            rtInvokeStartElement (pctxt, "cancelMultipointSecondaryStatus", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "cancelMultipointSecondaryStatus", -1);

            break;

         /* videoIndicateReadyToActivate */
         case 8:
            rtInvokeStartElement (pctxt, "videoIndicateReadyToActivate", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "videoIndicateReadyToActivate", -1);

            break;

         /* videoTemporalSpatialTradeOff */
         case 9:
            rtInvokeStartElement (pctxt, "videoTemporalSpatialTradeOff", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->u.videoTemporalSpatialTradeOff, 0U, 31U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.videoTemporalSpatialTradeOff);

            rtInvokeEndElement (pctxt, "videoTemporalSpatialTradeOff", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 11;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* videoNotDecodedMBs */
         case 11:
            rtInvokeStartElement (pctxt, "videoNotDecodedMBs", -1);

            pvalue->u.videoNotDecodedMBs = ALLOC_ASN1ELEM (pctxt, H245MiscellaneousIndication_type_videoNotDecodedMBs);
            if (pvalue->u.videoNotDecodedMBs == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MiscellaneousIndication_type_videoNotDecodedMBs (pctxt, pvalue->u.videoNotDecodedMBs);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "videoNotDecodedMBs", -1);

            break;

         /* transportCapability */
         case 12:
            rtInvokeStartElement (pctxt, "transportCapability", -1);

            pvalue->u.transportCapability = ALLOC_ASN1ELEM (pctxt, H245TransportCapability);
            if (pvalue->u.transportCapability == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245TransportCapability (pctxt, pvalue->u.transportCapability);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "transportCapability", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MiscellaneousIndication                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MiscellaneousIndication (OOCTXT* pctxt, H245MiscellaneousIndication* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode logicalChannelNumber */

   rtInvokeStartElement (pctxt, "logicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "logicalChannelNumber", -1);

   /* decode type */

   rtInvokeStartElement (pctxt, "type", -1);

   stat = asn1PD_H245MiscellaneousIndication_type (pctxt, &pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "type", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  JitterIndication_scope                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245JitterIndication_scope (OOCTXT* pctxt, H245JitterIndication_scope* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* logicalChannelNumber */
      case 0:
         rtInvokeStartElement (pctxt, "logicalChannelNumber", -1);

         stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.logicalChannelNumber);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

         rtInvokeEndElement (pctxt, "logicalChannelNumber", -1);

         break;

      /* resourceID */
      case 1:
         rtInvokeStartElement (pctxt, "resourceID", -1);

         stat = decodeConsUInt16 (pctxt, &pvalue->u.resourceID, 0U, 65535U);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         rtInvokeUIntValue (pctxt, pvalue->u.resourceID);

         rtInvokeEndElement (pctxt, "resourceID", -1);

         break;

      /* wholeMultiplex */
      case 2:
         rtInvokeStartElement (pctxt, "wholeMultiplex", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "wholeMultiplex", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  JitterIndication                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245JitterIndication (OOCTXT* pctxt, H245JitterIndication* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.skippedFrameCountPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.additionalDecoderBufferPresent = optbit;

   /* decode scope */

   rtInvokeStartElement (pctxt, "scope", -1);

   stat = asn1PD_H245JitterIndication_scope (pctxt, &pvalue->scope);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "scope", -1);

   /* decode estimatedReceivedJitterMantissa */

   rtInvokeStartElement (pctxt, "estimatedReceivedJitterMantissa", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->estimatedReceivedJitterMantissa, 0U, 3U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->estimatedReceivedJitterMantissa);

   rtInvokeEndElement (pctxt, "estimatedReceivedJitterMantissa", -1);

   /* decode estimatedReceivedJitterExponent */

   rtInvokeStartElement (pctxt, "estimatedReceivedJitterExponent", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->estimatedReceivedJitterExponent, 0U, 7U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->estimatedReceivedJitterExponent);

   rtInvokeEndElement (pctxt, "estimatedReceivedJitterExponent", -1);

   /* decode skippedFrameCount */

   if (pvalue->m.skippedFrameCountPresent) {
      rtInvokeStartElement (pctxt, "skippedFrameCount", -1);

      stat = decodeConsUInt8 (pctxt, &pvalue->skippedFrameCount, 0U, 15U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->skippedFrameCount);

      rtInvokeEndElement (pctxt, "skippedFrameCount", -1);
   }

   /* decode additionalDecoderBuffer */

   if (pvalue->m.additionalDecoderBufferPresent) {
      rtInvokeStartElement (pctxt, "additionalDecoderBuffer", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->additionalDecoderBuffer, 0U, 262143U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->additionalDecoderBuffer);

      rtInvokeEndElement (pctxt, "additionalDecoderBuffer", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H223SkewIndication                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H223SkewIndication (OOCTXT* pctxt, H245H223SkewIndication* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode logicalChannelNumber1 */

   rtInvokeStartElement (pctxt, "logicalChannelNumber1", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "logicalChannelNumber1", -1);

   /* decode logicalChannelNumber2 */

   rtInvokeStartElement (pctxt, "logicalChannelNumber2", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber2);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "logicalChannelNumber2", -1);

   /* decode skew */

   rtInvokeStartElement (pctxt, "skew", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->skew, 0U, 4095U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->skew);

   rtInvokeEndElement (pctxt, "skew", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NewATMVCIndication_aal_aal1_clockRecovery                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NewATMVCIndication_aal_aal1_clockRecovery (OOCTXT* pctxt, H245NewATMVCIndication_aal_aal1_clockRecovery* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nullClockRecovery */
         case 0:
            rtInvokeStartElement (pctxt, "nullClockRecovery", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "nullClockRecovery", -1);

            break;

         /* srtsClockRecovery */
         case 1:
            rtInvokeStartElement (pctxt, "srtsClockRecovery", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "srtsClockRecovery", -1);

            break;

         /* adaptiveClockRecovery */
         case 2:
            rtInvokeStartElement (pctxt, "adaptiveClockRecovery", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "adaptiveClockRecovery", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NewATMVCIndication_aal_aal1_errorCorrection               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NewATMVCIndication_aal_aal1_errorCorrection (OOCTXT* pctxt, H245NewATMVCIndication_aal_aal1_errorCorrection* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nullErrorCorrection */
         case 0:
            rtInvokeStartElement (pctxt, "nullErrorCorrection", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "nullErrorCorrection", -1);

            break;

         /* longInterleaver */
         case 1:
            rtInvokeStartElement (pctxt, "longInterleaver", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "longInterleaver", -1);

            break;

         /* shortInterleaver */
         case 2:
            rtInvokeStartElement (pctxt, "shortInterleaver", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "shortInterleaver", -1);

            break;

         /* errorCorrectionOnly */
         case 3:
            rtInvokeStartElement (pctxt, "errorCorrectionOnly", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "errorCorrectionOnly", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NewATMVCIndication_aal_aal1                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NewATMVCIndication_aal_aal1 (OOCTXT* pctxt, H245NewATMVCIndication_aal_aal1* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode clockRecovery */

   rtInvokeStartElement (pctxt, "clockRecovery", -1);

   stat = asn1PD_H245NewATMVCIndication_aal_aal1_clockRecovery (pctxt, &pvalue->clockRecovery);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "clockRecovery", -1);

   /* decode errorCorrection */

   rtInvokeStartElement (pctxt, "errorCorrection", -1);

   stat = asn1PD_H245NewATMVCIndication_aal_aal1_errorCorrection (pctxt, &pvalue->errorCorrection);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "errorCorrection", -1);

   /* decode structuredDataTransfer */

   rtInvokeStartElement (pctxt, "structuredDataTransfer", -1);

   stat = DECODEBIT (pctxt, &pvalue->structuredDataTransfer);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->structuredDataTransfer);

   rtInvokeEndElement (pctxt, "structuredDataTransfer", -1);

   /* decode partiallyFilledCells */

   rtInvokeStartElement (pctxt, "partiallyFilledCells", -1);

   stat = DECODEBIT (pctxt, &pvalue->partiallyFilledCells);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->partiallyFilledCells);

   rtInvokeEndElement (pctxt, "partiallyFilledCells", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NewATMVCIndication_aal_aal5                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NewATMVCIndication_aal_aal5 (OOCTXT* pctxt, H245NewATMVCIndication_aal_aal5* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode forwardMaximumSDUSize */

   rtInvokeStartElement (pctxt, "forwardMaximumSDUSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->forwardMaximumSDUSize, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->forwardMaximumSDUSize);

   rtInvokeEndElement (pctxt, "forwardMaximumSDUSize", -1);

   /* decode backwardMaximumSDUSize */

   rtInvokeStartElement (pctxt, "backwardMaximumSDUSize", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->backwardMaximumSDUSize, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->backwardMaximumSDUSize);

   rtInvokeEndElement (pctxt, "backwardMaximumSDUSize", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NewATMVCIndication_aal                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NewATMVCIndication_aal (OOCTXT* pctxt, H245NewATMVCIndication_aal* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* aal1 */
         case 0:
            rtInvokeStartElement (pctxt, "aal1", -1);

            pvalue->u.aal1 = ALLOC_ASN1ELEM (pctxt, H245NewATMVCIndication_aal_aal1);
            if (pvalue->u.aal1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NewATMVCIndication_aal_aal1 (pctxt, pvalue->u.aal1);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "aal1", -1);

            break;

         /* aal5 */
         case 1:
            rtInvokeStartElement (pctxt, "aal5", -1);

            pvalue->u.aal5 = ALLOC_ASN1ELEM (pctxt, H245NewATMVCIndication_aal_aal5);
            if (pvalue->u.aal5 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NewATMVCIndication_aal_aal5 (pctxt, pvalue->u.aal5);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "aal5", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NewATMVCIndication_multiplex                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NewATMVCIndication_multiplex (OOCTXT* pctxt, H245NewATMVCIndication_multiplex* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* noMultiplex */
         case 0:
            rtInvokeStartElement (pctxt, "noMultiplex", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "noMultiplex", -1);

            break;

         /* transportStream */
         case 1:
            rtInvokeStartElement (pctxt, "transportStream", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "transportStream", -1);

            break;

         /* programStream */
         case 2:
            rtInvokeStartElement (pctxt, "programStream", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "programStream", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NewATMVCIndication_reverseParameters_multiplex            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NewATMVCIndication_reverseParameters_multiplex (OOCTXT* pctxt, H245NewATMVCIndication_reverseParameters_multiplex* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* noMultiplex */
         case 0:
            rtInvokeStartElement (pctxt, "noMultiplex", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "noMultiplex", -1);

            break;

         /* transportStream */
         case 1:
            rtInvokeStartElement (pctxt, "transportStream", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "transportStream", -1);

            break;

         /* programStream */
         case 2:
            rtInvokeStartElement (pctxt, "programStream", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "programStream", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NewATMVCIndication_reverseParameters                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NewATMVCIndication_reverseParameters (OOCTXT* pctxt, H245NewATMVCIndication_reverseParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode bitRate */

   rtInvokeStartElement (pctxt, "bitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->bitRate, 1U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->bitRate);

   rtInvokeEndElement (pctxt, "bitRate", -1);

   /* decode bitRateLockedToPCRClock */

   rtInvokeStartElement (pctxt, "bitRateLockedToPCRClock", -1);

   stat = DECODEBIT (pctxt, &pvalue->bitRateLockedToPCRClock);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->bitRateLockedToPCRClock);

   rtInvokeEndElement (pctxt, "bitRateLockedToPCRClock", -1);

   /* decode bitRateLockedToNetworkClock */

   rtInvokeStartElement (pctxt, "bitRateLockedToNetworkClock", -1);

   stat = DECODEBIT (pctxt, &pvalue->bitRateLockedToNetworkClock);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->bitRateLockedToNetworkClock);

   rtInvokeEndElement (pctxt, "bitRateLockedToNetworkClock", -1);

   /* decode multiplex */

   rtInvokeStartElement (pctxt, "multiplex", -1);

   stat = asn1PD_H245NewATMVCIndication_reverseParameters_multiplex (pctxt, &pvalue->multiplex);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "multiplex", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NewATMVCIndication                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245NewATMVCIndication (OOCTXT* pctxt, H245NewATMVCIndication* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   /* decode resourceID */

   rtInvokeStartElement (pctxt, "resourceID", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->resourceID, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->resourceID);

   rtInvokeEndElement (pctxt, "resourceID", -1);

   /* decode bitRate */

   rtInvokeStartElement (pctxt, "bitRate", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->bitRate, 1U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->bitRate);

   rtInvokeEndElement (pctxt, "bitRate", -1);

   /* decode bitRateLockedToPCRClock */

   rtInvokeStartElement (pctxt, "bitRateLockedToPCRClock", -1);

   stat = DECODEBIT (pctxt, &pvalue->bitRateLockedToPCRClock);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->bitRateLockedToPCRClock);

   rtInvokeEndElement (pctxt, "bitRateLockedToPCRClock", -1);

   /* decode bitRateLockedToNetworkClock */

   rtInvokeStartElement (pctxt, "bitRateLockedToNetworkClock", -1);

   stat = DECODEBIT (pctxt, &pvalue->bitRateLockedToNetworkClock);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeBoolValue (pctxt, pvalue->bitRateLockedToNetworkClock);

   rtInvokeEndElement (pctxt, "bitRateLockedToNetworkClock", -1);

   /* decode aal */

   rtInvokeStartElement (pctxt, "aal", -1);

   stat = asn1PD_H245NewATMVCIndication_aal (pctxt, &pvalue->aal);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "aal", -1);

   /* decode multiplex */

   rtInvokeStartElement (pctxt, "multiplex", -1);

   stat = asn1PD_H245NewATMVCIndication_multiplex (pctxt, &pvalue->multiplex);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "multiplex", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 1 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.reverseParametersPresent = 1;

                     rtInvokeStartElement (pctxt, "reverseParameters", -1);

                     stat = asn1PD_H245NewATMVCIndication_reverseParameters (pctxt, &pvalue->reverseParameters);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

                     rtInvokeEndElement (pctxt, "reverseParameters", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 1) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UserInputIndication_userInputSupportIndication            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245UserInputIndication_userInputSupportIndication (OOCTXT* pctxt, H245UserInputIndication_userInputSupportIndication* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* basicString */
         case 1:
            rtInvokeStartElement (pctxt, "basicString", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "basicString", -1);

            break;

         /* iA5String */
         case 2:
            rtInvokeStartElement (pctxt, "iA5String", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "iA5String", -1);

            break;

         /* generalString */
         case 3:
            rtInvokeStartElement (pctxt, "generalString", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "generalString", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UserInputIndication_signal_rtp                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245UserInputIndication_signal_rtp (OOCTXT* pctxt, H245UserInputIndication_signal_rtp* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.timestampPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.expirationTimePresent = optbit;

   /* decode timestamp */

   if (pvalue->m.timestampPresent) {
      rtInvokeStartElement (pctxt, "timestamp", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->timestamp, 0U, ASN1UINT_MAX);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->timestamp);

      rtInvokeEndElement (pctxt, "timestamp", -1);
   }

   /* decode expirationTime */

   if (pvalue->m.expirationTimePresent) {
      rtInvokeStartElement (pctxt, "expirationTime", -1);

      stat = decodeConsUnsigned (pctxt, &pvalue->expirationTime, 0U, ASN1UINT_MAX);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->expirationTime);

      rtInvokeEndElement (pctxt, "expirationTime", -1);
   }

   /* decode logicalChannelNumber */

   rtInvokeStartElement (pctxt, "logicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "logicalChannelNumber", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UserInputIndication_signal                                */
/*                                                            */
/**************************************************************/

extern EXTERN const char* gs_MULTIMEDIA_SYSTEM_CONTROL_UserInputIndication_signal_signalType_CharSet;

EXTERN int asn1PD_H245UserInputIndication_signal (OOCTXT* pctxt, H245UserInputIndication_signal* pvalue)
{
   static Asn1SizeCnst signalType_lsize1 = { 0, 1, 1, 0 };
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.durationPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rtpPresent = optbit;

   /* decode signalType */

   rtInvokeStartElement (pctxt, "signalType", -1);

   stat = addSizeConstraint (pctxt, &signalType_lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeConstrainedStringEx (pctxt, &pvalue->signalType, gs_MULTIMEDIA_SYSTEM_CONTROL_UserInputIndication_signal_signalType_CharSet, 8, 5, 7);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeCharStrValue (pctxt, pvalue->signalType);

   rtInvokeEndElement (pctxt, "signalType", -1);

   /* decode duration */

   if (pvalue->m.durationPresent) {
      rtInvokeStartElement (pctxt, "duration", -1);

      stat = decodeConsUInt16 (pctxt, &pvalue->duration, 1U, 65535U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeUIntValue (pctxt, pvalue->duration);

      rtInvokeEndElement (pctxt, "duration", -1);
   }

   /* decode rtp */

   if (pvalue->m.rtpPresent) {
      rtInvokeStartElement (pctxt, "rtp", -1);

      stat = asn1PD_H245UserInputIndication_signal_rtp (pctxt, &pvalue->rtp);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "rtp", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 1 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.rtpPayloadIndicationPresent = 1;

                     rtInvokeStartElement (pctxt, "rtpPayloadIndication", -1);

                     /* NULL */
                     rtInvokeNullValue (pctxt);

                     rtInvokeEndElement (pctxt, "rtpPayloadIndication", -1);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
               pOpenType->numocts = openType.numocts;
               pOpenType->data = openType.data;
               dListAppend (pctxt, &pvalue->extElem1, pOpenType);
            }
         }
         else if (i >= 1) {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UserInputIndication_signalUpdate_rtp                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245UserInputIndication_signalUpdate_rtp (OOCTXT* pctxt, H245UserInputIndication_signalUpdate_rtp* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode logicalChannelNumber */

   rtInvokeStartElement (pctxt, "logicalChannelNumber", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "logicalChannelNumber", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UserInputIndication_signalUpdate                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245UserInputIndication_signalUpdate (OOCTXT* pctxt, H245UserInputIndication_signalUpdate* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rtpPresent = optbit;

   /* decode duration */

   rtInvokeStartElement (pctxt, "duration", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->duration, 1U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->duration);

   rtInvokeEndElement (pctxt, "duration", -1);

   /* decode rtp */

   if (pvalue->m.rtpPresent) {
      rtInvokeStartElement (pctxt, "rtp", -1);

      stat = asn1PD_H245UserInputIndication_signalUpdate_rtp (pctxt, &pvalue->rtp);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "rtp", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UserInputIndication_extendedAlphanumeric                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245UserInputIndication_extendedAlphanumeric (OOCTXT* pctxt, H245UserInputIndication_extendedAlphanumeric* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.rtpPayloadIndicationPresent = optbit;

   /* decode alphanumeric */

   rtInvokeStartElement (pctxt, "alphanumeric", -1);

   stat = decodeVarWidthCharString (pctxt, &pvalue->alphanumeric);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeCharStrValue (pctxt, pvalue->alphanumeric);

   rtInvokeEndElement (pctxt, "alphanumeric", -1);

   /* decode rtpPayloadIndication */

   if (pvalue->m.rtpPayloadIndicationPresent) {
      rtInvokeStartElement (pctxt, "rtpPayloadIndication", -1);

      /* NULL */
      rtInvokeNullValue (pctxt);

      rtInvokeEndElement (pctxt, "rtpPayloadIndication", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UserInputIndication                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245UserInputIndication (OOCTXT* pctxt, H245UserInputIndication* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* alphanumeric */
         case 1:
            rtInvokeStartElement (pctxt, "alphanumeric", -1);

            stat = decodeVarWidthCharString (pctxt, &pvalue->u.alphanumeric);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeCharStrValue (pctxt, pvalue->u.alphanumeric);

            rtInvokeEndElement (pctxt, "alphanumeric", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* userInputSupportIndication */
         case 3:
            rtInvokeStartElement (pctxt, "userInputSupportIndication", -1);

            pvalue->u.userInputSupportIndication = ALLOC_ASN1ELEM (pctxt, H245UserInputIndication_userInputSupportIndication);
            if (pvalue->u.userInputSupportIndication == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245UserInputIndication_userInputSupportIndication (pctxt, pvalue->u.userInputSupportIndication);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "userInputSupportIndication", -1);

            break;

         /* signal */
         case 4:
            rtInvokeStartElement (pctxt, "signal", -1);

            pvalue->u.signal = ALLOC_ASN1ELEM (pctxt, H245UserInputIndication_signal);
            if (pvalue->u.signal == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245UserInputIndication_signal (pctxt, pvalue->u.signal);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "signal", -1);

            break;

         /* signalUpdate */
         case 5:
            rtInvokeStartElement (pctxt, "signalUpdate", -1);

            pvalue->u.signalUpdate = ALLOC_ASN1ELEM (pctxt, H245UserInputIndication_signalUpdate);
            if (pvalue->u.signalUpdate == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245UserInputIndication_signalUpdate (pctxt, pvalue->u.signalUpdate);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "signalUpdate", -1);

            break;

         /* extendedAlphanumeric */
         case 6:
            rtInvokeStartElement (pctxt, "extendedAlphanumeric", -1);

            pvalue->u.extendedAlphanumeric = ALLOC_ASN1ELEM (pctxt, H245UserInputIndication_extendedAlphanumeric);
            if (pvalue->u.extendedAlphanumeric == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245UserInputIndication_extendedAlphanumeric (pctxt, pvalue->u.extendedAlphanumeric);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "extendedAlphanumeric", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H2250MaximumSkewIndication                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245H2250MaximumSkewIndication (OOCTXT* pctxt, H245H2250MaximumSkewIndication* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode logicalChannelNumber1 */

   rtInvokeStartElement (pctxt, "logicalChannelNumber1", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "logicalChannelNumber1", -1);

   /* decode logicalChannelNumber2 */

   rtInvokeStartElement (pctxt, "logicalChannelNumber2", -1);

   stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->logicalChannelNumber2);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "logicalChannelNumber2", -1);

   /* decode maximumSkew */

   rtInvokeStartElement (pctxt, "maximumSkew", -1);

   stat = decodeConsUInt16 (pctxt, &pvalue->maximumSkew, 0U, 4095U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->maximumSkew);

   rtInvokeEndElement (pctxt, "maximumSkew", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MCLocationIndication                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MCLocationIndication (OOCTXT* pctxt, H245MCLocationIndication* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode signalAddress */

   rtInvokeStartElement (pctxt, "signalAddress", -1);

   stat = asn1PD_H245TransportAddress (pctxt, &pvalue->signalAddress);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "signalAddress", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalYouAreSeeingInSubPictureNumber                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245TerminalYouAreSeeingInSubPictureNumber (OOCTXT* pctxt, H245TerminalYouAreSeeingInSubPictureNumber* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode terminalNumber */

   rtInvokeStartElement (pctxt, "terminalNumber", -1);

   stat = asn1PD_H245TerminalNumber (pctxt, &pvalue->terminalNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "terminalNumber", -1);

   /* decode subPictureNumber */

   rtInvokeStartElement (pctxt, "subPictureNumber", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->subPictureNumber, 0U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->subPictureNumber);

   rtInvokeEndElement (pctxt, "subPictureNumber", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VideoIndicateCompose                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245VideoIndicateCompose (OOCTXT* pctxt, H245VideoIndicateCompose* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode compositionNumber */

   rtInvokeStartElement (pctxt, "compositionNumber", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->compositionNumber, 0U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->compositionNumber);

   rtInvokeEndElement (pctxt, "compositionNumber", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConferenceIndication                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245ConferenceIndication (OOCTXT* pctxt, H245ConferenceIndication* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 9);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* sbeNumber */
         case 0:
            rtInvokeStartElement (pctxt, "sbeNumber", -1);

            stat = decodeConsUInt8 (pctxt, &pvalue->u.sbeNumber, 0U, 9U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            rtInvokeUIntValue (pctxt, pvalue->u.sbeNumber);

            rtInvokeEndElement (pctxt, "sbeNumber", -1);

            break;

         /* terminalNumberAssign */
         case 1:
            rtInvokeStartElement (pctxt, "terminalNumberAssign", -1);

            pvalue->u.terminalNumberAssign = ALLOC_ASN1ELEM (pctxt, H245TerminalLabel);
            if (pvalue->u.terminalNumberAssign == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245TerminalLabel (pctxt, pvalue->u.terminalNumberAssign);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "terminalNumberAssign", -1);

            break;

         /* terminalJoinedConference */
         case 2:
            rtInvokeStartElement (pctxt, "terminalJoinedConference", -1);

            pvalue->u.terminalJoinedConference = ALLOC_ASN1ELEM (pctxt, H245TerminalLabel);
            if (pvalue->u.terminalJoinedConference == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245TerminalLabel (pctxt, pvalue->u.terminalJoinedConference);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "terminalJoinedConference", -1);

            break;

         /* terminalLeftConference */
         case 3:
            rtInvokeStartElement (pctxt, "terminalLeftConference", -1);

            pvalue->u.terminalLeftConference = ALLOC_ASN1ELEM (pctxt, H245TerminalLabel);
            if (pvalue->u.terminalLeftConference == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245TerminalLabel (pctxt, pvalue->u.terminalLeftConference);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "terminalLeftConference", -1);

            break;

         /* seenByAtLeastOneOther */
         case 4:
            rtInvokeStartElement (pctxt, "seenByAtLeastOneOther", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "seenByAtLeastOneOther", -1);

            break;

         /* cancelSeenByAtLeastOneOther */
         case 5:
            rtInvokeStartElement (pctxt, "cancelSeenByAtLeastOneOther", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "cancelSeenByAtLeastOneOther", -1);

            break;

         /* seenByAll */
         case 6:
            rtInvokeStartElement (pctxt, "seenByAll", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "seenByAll", -1);

            break;

         /* cancelSeenByAll */
         case 7:
            rtInvokeStartElement (pctxt, "cancelSeenByAll", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "cancelSeenByAll", -1);

            break;

         /* terminalYouAreSeeing */
         case 8:
            rtInvokeStartElement (pctxt, "terminalYouAreSeeing", -1);

            pvalue->u.terminalYouAreSeeing = ALLOC_ASN1ELEM (pctxt, H245TerminalLabel);
            if (pvalue->u.terminalYouAreSeeing == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245TerminalLabel (pctxt, pvalue->u.terminalYouAreSeeing);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "terminalYouAreSeeing", -1);

            break;

         /* requestForFloor */
         case 9:
            rtInvokeStartElement (pctxt, "requestForFloor", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "requestForFloor", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 11;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* withdrawChairToken */
         case 11:
            rtInvokeStartElement (pctxt, "withdrawChairToken", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "withdrawChairToken", -1);

            break;

         /* floorRequested */
         case 12:
            rtInvokeStartElement (pctxt, "floorRequested", -1);

            pvalue->u.floorRequested = ALLOC_ASN1ELEM (pctxt, H245TerminalLabel);
            if (pvalue->u.floorRequested == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245TerminalLabel (pctxt, pvalue->u.floorRequested);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "floorRequested", -1);

            break;

         /* terminalYouAreSeeingInSubPictureNumber */
         case 13:
            rtInvokeStartElement (pctxt, "terminalYouAreSeeingInSubPictureNumber", -1);

            pvalue->u.terminalYouAreSeeingInSubPictureNumber = ALLOC_ASN1ELEM (pctxt, H245TerminalYouAreSeeingInSubPictureNumber);
            if (pvalue->u.terminalYouAreSeeingInSubPictureNumber == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245TerminalYouAreSeeingInSubPictureNumber (pctxt, pvalue->u.terminalYouAreSeeingInSubPictureNumber);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "terminalYouAreSeeingInSubPictureNumber", -1);

            break;

         /* videoIndicateCompose */
         case 14:
            rtInvokeStartElement (pctxt, "videoIndicateCompose", -1);

            pvalue->u.videoIndicateCompose = ALLOC_ASN1ELEM (pctxt, H245VideoIndicateCompose);
            if (pvalue->u.videoIndicateCompose == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245VideoIndicateCompose (pctxt, pvalue->u.videoIndicateCompose);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "videoIndicateCompose", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VendorIdentification                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245VendorIdentification (OOCTXT* pctxt, H245VendorIdentification* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.productNumberPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.versionNumberPresent = optbit;

   /* decode vendor */

   rtInvokeStartElement (pctxt, "vendor", -1);

   stat = asn1PD_H245NonStandardIdentifier (pctxt, &pvalue->vendor);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "vendor", -1);

   /* decode productNumber */

   if (pvalue->m.productNumberPresent) {
      rtInvokeStartElement (pctxt, "productNumber", -1);

      stat = asn1PD_H245VendorIdentification_productNumber (pctxt, &pvalue->productNumber);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "productNumber", -1);
   }

   /* decode versionNumber */

   if (pvalue->m.versionNumberPresent) {
      rtInvokeStartElement (pctxt, "versionNumber", -1);

      stat = asn1PD_H245VendorIdentification_versionNumber (pctxt, &pvalue->versionNumber);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      rtInvokeEndElement (pctxt, "versionNumber", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FunctionNotSupported_cause                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245FunctionNotSupported_cause (OOCTXT* pctxt, H245FunctionNotSupported_cause* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* syntaxError */
         case 0:
            rtInvokeStartElement (pctxt, "syntaxError", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "syntaxError", -1);

            break;

         /* semanticError */
         case 1:
            rtInvokeStartElement (pctxt, "semanticError", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "semanticError", -1);

            break;

         /* unknownFunction */
         case 2:
            rtInvokeStartElement (pctxt, "unknownFunction", -1);

            /* NULL */
            rtInvokeNullValue (pctxt);

            rtInvokeEndElement (pctxt, "unknownFunction", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FunctionNotSupported                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245FunctionNotSupported (OOCTXT* pctxt, H245FunctionNotSupported* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   dListInit (&pvalue->extElem1);

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.returnedFunctionPresent = optbit;

   /* decode cause */

   rtInvokeStartElement (pctxt, "cause", -1);

   stat = asn1PD_H245FunctionNotSupported_cause (pctxt, &pvalue->cause);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "cause", -1);

   /* decode returnedFunction */

   if (pvalue->m.returnedFunctionPresent) {
      rtInvokeStartElement (pctxt, "returnedFunction", -1);

      stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->returnedFunction);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      rtInvokeOctStrValue (pctxt, pvalue->returnedFunction.numocts, pvalue->returnedFunction.data);

      rtInvokeEndElement (pctxt, "returnedFunction", -1);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultilinkIndication_crcDesired                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultilinkIndication_crcDesired (OOCTXT* pctxt, H245MultilinkIndication_crcDesired* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultilinkIndication_excessiveError                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultilinkIndication_excessiveError (OOCTXT* pctxt, H245MultilinkIndication_excessiveError* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode connectionIdentifier */

   rtInvokeStartElement (pctxt, "connectionIdentifier", -1);

   stat = asn1PD_H245ConnectionIdentifier (pctxt, &pvalue->connectionIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "connectionIdentifier", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultilinkIndication                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultilinkIndication (OOCTXT* pctxt, H245MultilinkIndication* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardMessage);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardMessage (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* crcDesired */
         case 1:
            rtInvokeStartElement (pctxt, "crcDesired", -1);

            pvalue->u.crcDesired = ALLOC_ASN1ELEM (pctxt, H245MultilinkIndication_crcDesired);
            if (pvalue->u.crcDesired == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultilinkIndication_crcDesired (pctxt, pvalue->u.crcDesired);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "crcDesired", -1);

            break;

         /* excessiveError */
         case 2:
            rtInvokeStartElement (pctxt, "excessiveError", -1);

            pvalue->u.excessiveError = ALLOC_ASN1ELEM (pctxt, H245MultilinkIndication_excessiveError);
            if (pvalue->u.excessiveError == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultilinkIndication_excessiveError (pctxt, pvalue->u.excessiveError);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "excessiveError", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LogicalChannelRateRelease                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245LogicalChannelRateRelease (OOCTXT* pctxt, H245LogicalChannelRateRelease* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FlowControlIndication_scope                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245FlowControlIndication_scope (OOCTXT* pctxt, H245FlowControlIndication_scope* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* logicalChannelNumber */
      case 0:
         rtInvokeStartElement (pctxt, "logicalChannelNumber", -1);

         stat = asn1PD_H245LogicalChannelNumber (pctxt, &pvalue->u.logicalChannelNumber);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

         rtInvokeEndElement (pctxt, "logicalChannelNumber", -1);

         break;

      /* resourceID */
      case 1:
         rtInvokeStartElement (pctxt, "resourceID", -1);

         stat = decodeConsUInt16 (pctxt, &pvalue->u.resourceID, 0U, 65535U);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         rtInvokeUIntValue (pctxt, pvalue->u.resourceID);

         rtInvokeEndElement (pctxt, "resourceID", -1);

         break;

      /* wholeMultiplex */
      case 2:
         rtInvokeStartElement (pctxt, "wholeMultiplex", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "wholeMultiplex", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FlowControlIndication_restriction                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245FlowControlIndication_restriction (OOCTXT* pctxt, H245FlowControlIndication_restriction* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* maximumBitRate */
      case 0:
         rtInvokeStartElement (pctxt, "maximumBitRate", -1);

         stat = decodeConsUnsigned (pctxt, &pvalue->u.maximumBitRate, 0U, 16777215U);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         rtInvokeUIntValue (pctxt, pvalue->u.maximumBitRate);

         rtInvokeEndElement (pctxt, "maximumBitRate", -1);

         break;

      /* noRestriction */
      case 1:
         rtInvokeStartElement (pctxt, "noRestriction", -1);

         /* NULL */
         rtInvokeNullValue (pctxt);

         rtInvokeEndElement (pctxt, "noRestriction", -1);

         break;

      default:
         return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FlowControlIndication                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245FlowControlIndication (OOCTXT* pctxt, H245FlowControlIndication* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode scope */

   rtInvokeStartElement (pctxt, "scope", -1);

   stat = asn1PD_H245FlowControlIndication_scope (pctxt, &pvalue->scope);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "scope", -1);

   /* decode restriction */

   rtInvokeStartElement (pctxt, "restriction", -1);

   stat = asn1PD_H245FlowControlIndication_restriction (pctxt, &pvalue->restriction);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   rtInvokeEndElement (pctxt, "restriction", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MobileMultilinkReconfigurationIndication                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MobileMultilinkReconfigurationIndication (OOCTXT* pctxt, H245MobileMultilinkReconfigurationIndication* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   dListInit (&pvalue->extElem1);

   /* decode sampleSize */

   rtInvokeStartElement (pctxt, "sampleSize", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->sampleSize, 1U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->sampleSize);

   rtInvokeEndElement (pctxt, "sampleSize", -1);

   /* decode samplesPerFrame */

   rtInvokeStartElement (pctxt, "samplesPerFrame", -1);

   stat = decodeConsUInt8 (pctxt, &pvalue->samplesPerFrame, 1U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   rtInvokeUIntValue (pctxt, pvalue->samplesPerFrame);

   rtInvokeEndElement (pctxt, "samplesPerFrame", -1);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pOpenType = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            dListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            dListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IndicationMessage                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245IndicationMessage (OOCTXT* pctxt, H245IndicationMessage* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 13);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            rtInvokeStartElement (pctxt, "nonStandard", -1);

            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H245NonStandardMessage);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NonStandardMessage (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "nonStandard", -1);

            break;

         /* functionNotUnderstood */
         case 1:
            rtInvokeStartElement (pctxt, "functionNotUnderstood", -1);

            pvalue->u.functionNotUnderstood = ALLOC_ASN1ELEM (pctxt, H245FunctionNotUnderstood);
            if (pvalue->u.functionNotUnderstood == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245FunctionNotUnderstood (pctxt, pvalue->u.functionNotUnderstood);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "functionNotUnderstood", -1);

            break;

         /* masterSlaveDeterminationRelease */
         case 2:
            rtInvokeStartElement (pctxt, "masterSlaveDeterminationRelease", -1);

            pvalue->u.masterSlaveDeterminationRelease = ALLOC_ASN1ELEM (pctxt, H245MasterSlaveDeterminationRelease);
            if (pvalue->u.masterSlaveDeterminationRelease == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MasterSlaveDeterminationRelease (pctxt, pvalue->u.masterSlaveDeterminationRelease);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "masterSlaveDeterminationRelease", -1);

            break;

         /* terminalCapabilitySetRelease */
         case 3:
            rtInvokeStartElement (pctxt, "terminalCapabilitySetRelease", -1);

            pvalue->u.terminalCapabilitySetRelease = ALLOC_ASN1ELEM (pctxt, H245TerminalCapabilitySetRelease);
            if (pvalue->u.terminalCapabilitySetRelease == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245TerminalCapabilitySetRelease (pctxt, pvalue->u.terminalCapabilitySetRelease);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "terminalCapabilitySetRelease", -1);

            break;

         /* openLogicalChannelConfirm */
         case 4:
            rtInvokeStartElement (pctxt, "openLogicalChannelConfirm", -1);

            pvalue->u.openLogicalChannelConfirm = ALLOC_ASN1ELEM (pctxt, H245OpenLogicalChannelConfirm);
            if (pvalue->u.openLogicalChannelConfirm == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245OpenLogicalChannelConfirm (pctxt, pvalue->u.openLogicalChannelConfirm);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "openLogicalChannelConfirm", -1);

            break;

         /* requestChannelCloseRelease */
         case 5:
            rtInvokeStartElement (pctxt, "requestChannelCloseRelease", -1);

            pvalue->u.requestChannelCloseRelease = ALLOC_ASN1ELEM (pctxt, H245RequestChannelCloseRelease);
            if (pvalue->u.requestChannelCloseRelease == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RequestChannelCloseRelease (pctxt, pvalue->u.requestChannelCloseRelease);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "requestChannelCloseRelease", -1);

            break;

         /* multiplexEntrySendRelease */
         case 6:
            rtInvokeStartElement (pctxt, "multiplexEntrySendRelease", -1);

            pvalue->u.multiplexEntrySendRelease = ALLOC_ASN1ELEM (pctxt, H245MultiplexEntrySendRelease);
            if (pvalue->u.multiplexEntrySendRelease == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultiplexEntrySendRelease (pctxt, pvalue->u.multiplexEntrySendRelease);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "multiplexEntrySendRelease", -1);

            break;

         /* requestMultiplexEntryRelease */
         case 7:
            rtInvokeStartElement (pctxt, "requestMultiplexEntryRelease", -1);

            pvalue->u.requestMultiplexEntryRelease = ALLOC_ASN1ELEM (pctxt, H245RequestMultiplexEntryRelease);
            if (pvalue->u.requestMultiplexEntryRelease == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RequestMultiplexEntryRelease (pctxt, pvalue->u.requestMultiplexEntryRelease);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "requestMultiplexEntryRelease", -1);

            break;

         /* requestModeRelease */
         case 8:
            rtInvokeStartElement (pctxt, "requestModeRelease", -1);

            pvalue->u.requestModeRelease = ALLOC_ASN1ELEM (pctxt, H245RequestModeRelease);
            if (pvalue->u.requestModeRelease == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RequestModeRelease (pctxt, pvalue->u.requestModeRelease);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "requestModeRelease", -1);

            break;

         /* miscellaneousIndication */
         case 9:
            rtInvokeStartElement (pctxt, "miscellaneousIndication", -1);

            pvalue->u.miscellaneousIndication = ALLOC_ASN1ELEM (pctxt, H245MiscellaneousIndication);
            if (pvalue->u.miscellaneousIndication == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MiscellaneousIndication (pctxt, pvalue->u.miscellaneousIndication);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "miscellaneousIndication", -1);

            break;

         /* jitterIndication */
         case 10:
            rtInvokeStartElement (pctxt, "jitterIndication", -1);

            pvalue->u.jitterIndication = ALLOC_ASN1ELEM (pctxt, H245JitterIndication);
            if (pvalue->u.jitterIndication == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245JitterIndication (pctxt, pvalue->u.jitterIndication);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "jitterIndication", -1);

            break;

         /* h223SkewIndication */
         case 11:
            rtInvokeStartElement (pctxt, "h223SkewIndication", -1);

            pvalue->u.h223SkewIndication = ALLOC_ASN1ELEM (pctxt, H245H223SkewIndication);
            if (pvalue->u.h223SkewIndication == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H223SkewIndication (pctxt, pvalue->u.h223SkewIndication);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h223SkewIndication", -1);

            break;

         /* newATMVCIndication */
         case 12:
            rtInvokeStartElement (pctxt, "newATMVCIndication", -1);

            pvalue->u.newATMVCIndication = ALLOC_ASN1ELEM (pctxt, H245NewATMVCIndication);
            if (pvalue->u.newATMVCIndication == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245NewATMVCIndication (pctxt, pvalue->u.newATMVCIndication);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "newATMVCIndication", -1);

            break;

         /* userInput */
         case 13:
            rtInvokeStartElement (pctxt, "userInput", -1);

            pvalue->u.userInput = ALLOC_ASN1ELEM (pctxt, H245UserInputIndication);
            if (pvalue->u.userInput == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245UserInputIndication (pctxt, pvalue->u.userInput);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "userInput", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 15;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* h2250MaximumSkewIndication */
         case 15:
            rtInvokeStartElement (pctxt, "h2250MaximumSkewIndication", -1);

            pvalue->u.h2250MaximumSkewIndication = ALLOC_ASN1ELEM (pctxt, H245H2250MaximumSkewIndication);
            if (pvalue->u.h2250MaximumSkewIndication == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245H2250MaximumSkewIndication (pctxt, pvalue->u.h2250MaximumSkewIndication);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "h2250MaximumSkewIndication", -1);

            break;

         /* mcLocationIndication */
         case 16:
            rtInvokeStartElement (pctxt, "mcLocationIndication", -1);

            pvalue->u.mcLocationIndication = ALLOC_ASN1ELEM (pctxt, H245MCLocationIndication);
            if (pvalue->u.mcLocationIndication == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MCLocationIndication (pctxt, pvalue->u.mcLocationIndication);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "mcLocationIndication", -1);

            break;

         /* conferenceIndication */
         case 17:
            rtInvokeStartElement (pctxt, "conferenceIndication", -1);

            pvalue->u.conferenceIndication = ALLOC_ASN1ELEM (pctxt, H245ConferenceIndication);
            if (pvalue->u.conferenceIndication == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245ConferenceIndication (pctxt, pvalue->u.conferenceIndication);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "conferenceIndication", -1);

            break;

         /* vendorIdentification */
         case 18:
            rtInvokeStartElement (pctxt, "vendorIdentification", -1);

            pvalue->u.vendorIdentification = ALLOC_ASN1ELEM (pctxt, H245VendorIdentification);
            if (pvalue->u.vendorIdentification == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245VendorIdentification (pctxt, pvalue->u.vendorIdentification);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "vendorIdentification", -1);

            break;

         /* functionNotSupported */
         case 19:
            rtInvokeStartElement (pctxt, "functionNotSupported", -1);

            pvalue->u.functionNotSupported = ALLOC_ASN1ELEM (pctxt, H245FunctionNotSupported);
            if (pvalue->u.functionNotSupported == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245FunctionNotSupported (pctxt, pvalue->u.functionNotSupported);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "functionNotSupported", -1);

            break;

         /* multilinkIndication */
         case 20:
            rtInvokeStartElement (pctxt, "multilinkIndication", -1);

            pvalue->u.multilinkIndication = ALLOC_ASN1ELEM (pctxt, H245MultilinkIndication);
            if (pvalue->u.multilinkIndication == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MultilinkIndication (pctxt, pvalue->u.multilinkIndication);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "multilinkIndication", -1);

            break;

         /* logicalChannelRateRelease */
         case 21:
            rtInvokeStartElement (pctxt, "logicalChannelRateRelease", -1);

            pvalue->u.logicalChannelRateRelease = ALLOC_ASN1ELEM (pctxt, H245LogicalChannelRateRelease);
            if (pvalue->u.logicalChannelRateRelease == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245LogicalChannelRateRelease (pctxt, pvalue->u.logicalChannelRateRelease);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "logicalChannelRateRelease", -1);

            break;

         /* flowControlIndication */
         case 22:
            rtInvokeStartElement (pctxt, "flowControlIndication", -1);

            pvalue->u.flowControlIndication = ALLOC_ASN1ELEM (pctxt, H245FlowControlIndication);
            if (pvalue->u.flowControlIndication == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245FlowControlIndication (pctxt, pvalue->u.flowControlIndication);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "flowControlIndication", -1);

            break;

         /* mobileMultilinkReconfigurationIndication */
         case 23:
            rtInvokeStartElement (pctxt, "mobileMultilinkReconfigurationIndication", -1);

            pvalue->u.mobileMultilinkReconfigurationIndication = ALLOC_ASN1ELEM (pctxt, H245MobileMultilinkReconfigurationIndication);
            if (pvalue->u.mobileMultilinkReconfigurationIndication == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245MobileMultilinkReconfigurationIndication (pctxt, pvalue->u.mobileMultilinkReconfigurationIndication);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "mobileMultilinkReconfigurationIndication", -1);

            break;

         default:
            pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            pvalue->u.extElem1->data = openType.data;
            pvalue->u.extElem1->numocts = openType.numocts;

      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MultimediaSystemControlMessage                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H245MultimediaSystemControlMessage (OOCTXT* pctxt, H245MultimediaSystemControlMessage* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* request */
         case 0:
            rtInvokeStartElement (pctxt, "request", -1);

            pvalue->u.request = ALLOC_ASN1ELEM (pctxt, H245RequestMessage);
            if (pvalue->u.request == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245RequestMessage (pctxt, pvalue->u.request);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "request", -1);

            break;

         /* response */
         case 1:
            rtInvokeStartElement (pctxt, "response", -1);

            pvalue->u.response = ALLOC_ASN1ELEM (pctxt, H245ResponseMessage);
            if (pvalue->u.response == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245ResponseMessage (pctxt, pvalue->u.response);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "response", -1);

            break;

         /* command */
         case 2:
            rtInvokeStartElement (pctxt, "command", -1);

            pvalue->u.command = ALLOC_ASN1ELEM (pctxt, H245CommandMessage);
            if (pvalue->u.command == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245CommandMessage (pctxt, pvalue->u.command);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "command", -1);

            break;

         /* indication */
         case 3:
            rtInvokeStartElement (pctxt, "indication", -1);

            pvalue->u.indication = ALLOC_ASN1ELEM (pctxt, H245IndicationMessage);
            if (pvalue->u.indication == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H245IndicationMessage (pctxt, pvalue->u.indication);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            rtInvokeEndElement (pctxt, "indication", -1);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      pvalue->u.extElem1 = ALLOC_ASN1ELEM (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

